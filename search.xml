<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MarkDown语法简记</title>
    <url>/2019/07/18/MarkDown%E8%AF%AD%E6%B3%95%E7%AE%80%E8%AE%B0/</url>
    <content><![CDATA[<p>常用的MarkDown语法</p>
<span id="more"></span>
<h2 id="初识MarkDown"><a href="#初识MarkDown" class="headerlink" title="初识MarkDown"></a>初识MarkDown</h2><p>作为一个未来的码农，越早接触这一语法越好。毕竟我是拿来来练习打字速度的（手动滑稽）。</p>
<h2 id="列表（注意中间需要空格）"><a href="#列表（注意中间需要空格）" class="headerlink" title="列表（注意中间需要空格）"></a>列表（注意中间需要空格）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 这是第一点</span><br><span class="line">2. 这是第二点</span><br><span class="line">-  前面一个点</span><br></pre></td></tr></table></figure>
<p>显示效果：</p>
<ol>
<li>这是第一点</li>
<li>这是第二点</li>
</ol>
<ul>
<li>前面一个点</li>
</ul>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">*斜体*</span><br><span class="line">~~删除线~~ (注意这是英文键盘下的~)</span><br><span class="line">**注意**：当需要打出*时，在前面加入\即可</span><br><span class="line">&gt;这是用来  \*演示\* 的 \_文本\_</span><br></pre></td></tr></table></figure>
<p>效果：<br><strong>加粗</strong><br><em>斜体</em><br><del>删除线</del> (注意这是英文键盘下的~)<br><strong>注意</strong>：当需要打出*时，在前面加入\即可</p>
<blockquote>
<p>这是用来  *演示* 的 _文本_</p>
</blockquote>
<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><p>或者使用`代码片段&#96;</p>
<p><code>if(a=b)</code></p>
<h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure>
<h2 id="效果："><a href="#效果：" class="headerlink" title="效果：***"></a>效果：<br>***</h2><hr>
<h2 id="超链接-需要用英文括号"><a href="#超链接-需要用英文括号" class="headerlink" title="超链接(需要用英文括号)"></a>超链接(需要用英文括号)</h2><p><a href="http://www.google.com/">Google</a><br><em>以下是中文括号显示效果：</em><br>[Google]（<a href="http://www.google.com/%EF%BC%89">http://www.google.com/）</a></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>插入图片的格式和插入<strong>超链接</strong>语法基本一致，只不过需要在前面加一个英文！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![GitHub](https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 <span class="string">&quot;GitHub,Social Coding&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://avatars2.githubusercontent.com/u/3265208?v=3&s=100" alt="GitHub" title="GitHub,Social Coding"></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>用前后各三个点来包含多行代码，在第一个三点后面加入代码的语言就可以高亮显示关键词：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;a\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用  |   来分隔不同的单元格，使用 ---来分隔表头和其它行</span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">name | age</span><br><span class="line">--- | ---</span><br><span class="line">LearnShare | 12</span><br><span class="line">Mike |  32</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>LearnShare</td>
<td>12</td>
</tr>
<tr>
<td>Mike</td>
<td>32</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>2019前端面试题总汇</title>
    <url>/2020/02/25/2019%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E6%B1%87/</url>
    <content><![CDATA[<p>#前端面试题</p>
<blockquote>
<p>2019各个公司前端面试题总汇</p>
</blockquote>
<h1 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h1><p>1.https与http区别(百度)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">http是基于tcp协议的，https是基于ssl协议的，ssl协议在tcp协议的基础上的做了一层加密认证。</span><br><span class="line">https比http传输数据更安全，http是明文传递数据，不安全；而https传输数据经过加密。</span><br><span class="line">https需要证书来验证身份，证书需要购买，http不需要。</span><br><span class="line">https默认端口号是443，http默认是80。</span><br><span class="line">https不能向http发出请求。</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">了解https通讯过程：</span><br><span class="line"></span><br><span class="line">（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</span><br><span class="line"></span><br><span class="line">（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</span><br><span class="line"></span><br><span class="line">（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</span><br><span class="line"></span><br><span class="line">（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</span><br><span class="line"></span><br><span class="line">（5）Web服务器利用自己的私钥解密出会话密钥。</span><br><span class="line"></span><br><span class="line">（6）Web服务器利用会话密钥加密与客户端之间的通信</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.http请求过程及拿到响应后的渲染过程？（苏宁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">http请求过程：</span><br><span class="line">1.浏览器检查当前请求的url是否存在强缓存？命中强缓存，则缓存中读取。</span><br><span class="line">2.dns解析：</span><br><span class="line">  a.浏览器缓存的dns解析，是否存在。</span><br><span class="line">  b.操作系统DNS缓存中搜索</span><br><span class="line">  c.本地host进行dns解析。</span><br><span class="line">  d.向dns服务器发起请求进行dns解析</span><br><span class="line">3.建立tcp链接，三次握手。</span><br><span class="line">4.浏览器发出http请求</span><br><span class="line">5.服务器分析路由，处理请求，返回响应。</span><br><span class="line">6.浏览器接受响应，渲染页面，构建dom</span><br><span class="line">7。关闭tcp链接（4次挥手）  </span><br><span class="line"></span><br><span class="line">渲染过程：</span><br><span class="line">1.解析html文件，浏览器按照文档流顺序，构建dom树。（深度遍历，当所有子节点都构建好后，才会去构建当前节点的下一个兄弟节点）</span><br><span class="line">2.浏览器解析css形成css规则树。</span><br><span class="line">3.根据dom树和css规则树，构造出渲染树。</span><br><span class="line">   渲染树：浏览器可以知道网页中有那些节点，各个节点的css以及他们从属关系</span><br><span class="line">   </span><br><span class="line">4.遍历渲染树，计算每个节点位置大小信息，然后进行绘制。</span><br><span class="line"></span><br><span class="line">扩展：重绘 和 回流</span><br><span class="line">重绘：dom的一部分进行重画，不影响整体布局。</span><br><span class="line">触发：css背景色...</span><br><span class="line">回流：重新计算渲染树，重新遍历渲染树，重新渲染，浪费性能；</span><br><span class="line">触发：宽高、字体、resize等。</span><br><span class="line">优化：利用文档碎片document.createDocumentFragment并不是真正的dom，操作dom；</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.http缓存机制。(百度、滴滴都有问)</p>
<p><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57">点击查看详细浏览器缓存技术，面试难不倒</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">强缓存： </span><br><span class="line">    响应报文头：</span><br><span class="line">    catch-control：max-age=212121； 最长生效时常。</span><br><span class="line">    expires:服务器绝对时间</span><br><span class="line">    </span><br><span class="line">    客户端发请求前，会用当前客户端时间与 （上次请求时间+max-age）进行比较，命中则走缓存。</span><br><span class="line">    expires是一个绝对时间，采用的是服务器的。客户端发送请求前，用客户端时间与这个时间进行比较，命中则走缓存。</span><br><span class="line">    max-age优先级比expires高，并且更加靠谱；</span><br><span class="line">    </span><br><span class="line">弱缓存（协商缓存）:</span><br><span class="line">    响应报文头:</span><br><span class="line">    last-modified：最后一次修改时间</span><br><span class="line">    Etag：当前请求的资源生成的一个唯一标识，只要资源不一样这个串就不一样</span><br><span class="line">    </span><br><span class="line">    请求报文头：</span><br><span class="line">    if-modified-since:缓存中文件的最后修改时间</span><br><span class="line">    if-None-Match:缓存中文件的etag</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    客户端发出请求，携带if-modified-since，if-None-Match字段，服务器收到请求 与当前文件的最后修改时间和</span><br><span class="line">    重新生成etag进行比较，命中则返回304； </span><br><span class="line">    如果命中if-none-match，返回304的响应头中，会携带服务器最新生成的etag;</span><br><span class="line">    如果命中if-modified-since则304响应头中不会携带last-modified，因为最后修改时间没有改变。</span><br><span class="line">    </span><br><span class="line">    注意：etag优先级比 last-modified要高。但是各有优缺点；</span><br><span class="line">        分布式系统里多台机器文件的last-modified必须保持一致，要不负载均衡到不同机器导致对比失败。</span><br><span class="line">        分布式系统计量关闭掉etag，因为每台服务器生成的etag都不一样。</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    使用：协商缓存需要配合强缓存使用，</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>4.http get和post区别？（马蜂窝）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GET在浏览器回退时是无害的，而POST会再次提交请求。</span><br><span class="line"></span><br><span class="line">GET产生的URL地址可以被Bookmark，而POST不可以。</span><br><span class="line"></span><br><span class="line">GET请求会被浏览器主动cache，而POST不会，除非手动设置。</span><br><span class="line"></span><br><span class="line">GET请求只能进行url编码，而POST支持多种编码方式。</span><br><span class="line"></span><br><span class="line">GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</span><br><span class="line"></span><br><span class="line">GET请求在URL中传送的参数是有长度限制的，而POST么有。</span><br><span class="line">get传送的数据量较小，不能大于2KB。post传送的数据量较大</span><br><span class="line"></span><br><span class="line">对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</span><br><span class="line"></span><br><span class="line">GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 </span><br><span class="line"></span><br><span class="line">GET参数通过URL传递，POST放在Request body中。</span><br><span class="line"></span><br><span class="line">GET产生一个TCP数据包；POST产生两个TCP数据包</span><br><span class="line">对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</span><br><span class="line">而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>5.http状态码（百度，水滴筹，今日头条）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 成功</span><br><span class="line">5** 服务器</span><br><span class="line">304 缓存</span><br><span class="line">301 永久重定向</span><br><span class="line">302 临时重定向</span><br><span class="line">400 Bad Request，通用的客户端错误状态，当其他4XX响应代码不适用时，就采用400</span><br><span class="line">401 权限不够访问该资源。</span><br><span class="line">404 not found 当客户端所请求的URI不对应于任何资源时，发送此响应代码，找不到资源。</span><br><span class="line">403 Forbidden 服务器拒绝访问</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.列举你所知道的请求头中的字段和响应头中的字段（美团，小米）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求头</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01 //告诉服务器,客户端支持的数据类型</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8 //告诉服务器,发送的数据类型</span><br><span class="line">Origin: http://dev-mrytuan.chuchujie.com            //源</span><br><span class="line">Referer: http://dev-mrytuan.chuchujie.com/          //源页面</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36</span><br><span class="line">// 浏览器信息</span><br><span class="line">cookie:&#x27;&#x27;,                  //cookie信息</span><br><span class="line">if-modified-since:xxxxx          //上次请求响应头返回的最后修改时间</span><br><span class="line">if-none-match:xxx               //上次请求响应头返回的etag信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">options请求</span><br><span class="line"> Access-Control-Request-Method：，用来列出浏览器的CORS请求会用到哪些HTTP方法</span><br><span class="line"> Access-Control-Request-Headers：浏览器CORS请求会额外发送的头信息字段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">响应头：</span><br><span class="line">Access-Contronl-Allow-origin:* ，//允许源访问</span><br><span class="line">access-control-allow-methods：get ,post //允许请求方式</span><br><span class="line">access-control-allow-headers：&#x27;name&#x27;    //允许携带的请求头</span><br><span class="line">access-control-expose-headers：&#x27;name&#x27;    //允许浏览器读取的头信息</span><br><span class="line">access-control-allow-credentials:true //表示服务器允许浏览器携带cookie发送</span><br><span class="line">content-type: application/json         响应数据格式</span><br><span class="line">date: Tue, 02 Apr 2019 16:30:02 GMT   //服务器时间</span><br><span class="line">catch-control:max-age=36000             //强缓存最强生效时长</span><br><span class="line">expires:xx-xx-xx                        //服务器失效绝对时间</span><br><span class="line">last-modified：xxx-xxx-xx                //服务器最后修改时间</span><br><span class="line">etag：xxxxxx                             //服务器资源唯一标示符          </span><br><span class="line"></span><br><span class="line">options</span><br><span class="line">  Access-Control-Max-Age：秒,                      本次预检请求的有效期</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>7.复杂请求的与简单请求的区别<br> <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">阮一峰详解</a><br>  复杂请求 会比 简单请求多一个options请求（预检查请求）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cors请求分两种:简单请求 和非简单请求</span><br><span class="line"></span><br><span class="line">==============================================</span><br><span class="line">简单请求：</span><br><span class="line"> 浏览器请求头中会默认增加origin字段，表示来自哪个源</span><br><span class="line"> 服务器接收请求后，根据指定的源作出回应。</span><br><span class="line"> 响应头中：Access-Control-Allow-Origin:* || domain</span><br><span class="line">        Access-Control-Allow-Credentials:true， //表示是否允许跨域携带cookie。（后续进行讲解）</span><br><span class="line">        Access-Control-Expose-Headers：xxx      //指定浏览器可以获取到的 自定义响应头</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=============================================        </span><br><span class="line">非简单请求：</span><br><span class="line"> 出现条件：请求方法是PUT或DELETE，</span><br><span class="line">         Content-Type字段的类型是application/json</span><br><span class="line">         增加额外的header字段；   </span><br><span class="line"> 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;options请求（preflight）</span><br><span class="line"> </span><br><span class="line"> 浏览器发出options请求头：</span><br><span class="line">   origin:源</span><br><span class="line">   Access-Control-Request-Method：，用来列出浏览器的CORS请求会用到哪些HTTP方法</span><br><span class="line">   Access-Control-Request-Headers：浏览器CORS请求会额外发送的头信息字段</span><br><span class="line">   </span><br><span class="line"> 服务器返回options响应头：</span><br><span class="line">   Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">   Access-Control-Allow-Methods: GET, POST, PUT    服务器支持的所有跨域请求的方法</span><br><span class="line">   Access-Control-Allow-Headers: X-Custom-Header   表示服务器支持的所有头信息字段</span><br><span class="line">   Access-Control-Max-Age：秒,                      本次预检请求的有效期</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"> 服务器如果否定了options请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。浏览器就</span><br><span class="line"> 会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"> ====================================</span><br><span class="line"> </span><br><span class="line"> withCredentials属性</span><br><span class="line"> cors请求不发送cooki，如果要发送cookie到服务器，一方面要服务器同意。</span><br><span class="line"> Access-Control-Allow-Origin：不能设置*号，必须指定和明确的、与请求网页一致的域名</span><br><span class="line"> Access-Control-Allow-credentials：true；//这个只能设为true；如果不需要cookie，则删除该字段即可。</span><br><span class="line"> </span><br><span class="line"> 另一方面，浏览器ajax需要打开 withCredentials      </span><br><span class="line"> var xhr = new XMLHttpRequest();</span><br><span class="line"> xhr.withCredentials = true; </span><br><span class="line"> </span><br><span class="line"> 特点：Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，</span><br><span class="line"> 且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</span><br><span class="line"> </span><br><span class="line"> a.com 请求b.com ，设置了此属性，携带的cookie也只能是b.com 这个域下的cookie；</span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>8.http2 和http1.1的区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[区别详解](https://juejin.im/post/5a4dfb2ef265da43305ee2d0)</span><br><span class="line">1.首部压缩，使报头更紧凑，更快速传输</span><br><span class="line">2.多路复用，</span><br><span class="line">在HTTP1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制。超过限制数目的请求会被阻塞</span><br><span class="line">http2中，只使用一个链接即可并行发送多个请求和响应，而且互不影响</span><br><span class="line"></span><br><span class="line">3.支持服务器推送</span><br><span class="line">如果一个请求是由你的主页发送的，服务器可能会响应主页内容、logo以及样式表，因为他知道客户端会用到这些东西。</span><br><span class="line">这样不但减轻了数据传送冗余步骤，也加快了页面响应的速度，提高了用户体验。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="js基础相关"><a href="#js基础相关" class="headerlink" title="js基础相关"></a>js基础相关</h1><p>1.js继承？原型链查找原理。（蚂蚁金服）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function inheritPrototype(subType, superType)&#123; </span><br><span class="line">    // 继承父类的原型</span><br><span class="line">    var prototype = Object.create(superType.prototype);</span><br><span class="line">    // 重写被污染的construct</span><br><span class="line">    prototype.constructor = subType; </span><br><span class="line">    // 重写子类的原型  </span><br><span class="line">    subType.prototype = Object.assign(prototype, subType.prototype); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>2.es6 class继承如何实现？（蚂蚁金服）</p>
<p>3.var let const 区别 （基本每个公司都问）</p>
<p>4.promise的特点，使用及原理。（基本每个公司都问）</p>
<p><a href="https://segmentfault.com/a/1190000013871753">手写promise</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">特点：then链式调用</span><br><span class="line">     catch捕获</span><br><span class="line">     all方法</span><br><span class="line">     race方法</span><br><span class="line">     promise对象三种状态 pendding,fulfilled,rejected;</span><br><span class="line">     状态改变，只能改一次；</span><br><span class="line">     promise对象已经是成功状态或是失败状态时，都可以继续通过then传入函数，会通过当前的状态，来决定执行成功还失败，并且把结果或是错误传给相应的函数。</span><br><span class="line">      </span><br><span class="line">原理：状态机 + then方法返回新的promise2对象实现链式调用；</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">new promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        resolve(&#x27;成功&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(()=&gt;&#123;&#125;,()=&gt;&#123;&#125;).catch(e=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">Promise.all([promise1,promise2]).then();</span><br><span class="line">Promise.race([promise1,promise2]).then();</span><br><span class="line">Promise.resolve(1)</span><br><span class="line">Promise.reject(1)</span><br><span class="line">Promise.deferred();</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>5.generator函数的使用及原理 （蚂蚁金服）</p>
<p><a href="https://segmentfault.com/a/1190000014028204">generator</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">generator 函数可以控制函数的执行，类似将函数分割成多个小函数，依次执行；</span><br><span class="line">用 * 表示一个generator 函数，用 yield 控制函数执行，并且产出；</span><br><span class="line">generator是有两部分组成；* 表示 的函数 是生成器，函数执行的返回结果是迭代器；</span><br><span class="line">迭代器.next();会将yield的值 返回，&#123;value:&#x27;返回值&#x27;，done：&#x27;是否迭代完成&#x27;&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line"></span><br><span class="line">function *read()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    var content1 = yield &#x27;qs&#x27;;</span><br><span class="line">    console.log(content1);</span><br><span class="line">    var content2 = yield &#x27;9&#x27;;![图片描述][1]</span><br><span class="line">    console.log(content2);</span><br><span class="line">    return content2;</span><br><span class="line">&#125;</span><br><span class="line">var it = read();</span><br><span class="line">var a = it.next() //输出 1  a:&#123;value:&#x27;qs&#x27;,done:false&#125;</span><br><span class="line">var b = it.next(&#x27;hello&#x27;)//输出hello  b:&#123;value:&#x27;9&#x27;,done:false&#125;</span><br><span class="line">var c = it.next(&#x27;generator&#x27;)//输出generator  c:&#123;value:&#x27;generator&#x27;,done:true&#125;</span><br><span class="line">var d = it.next(&#x27;123&#x27;)//输出generator  c:&#123;value:undefined,done:true&#125;</span><br><span class="line">console.log(a,b,c,d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用：一般和promise结合使用；</span><br><span class="line"></span><br><span class="line">function *g()&#123;</span><br><span class="line">    let result1 = yield ajax(&#x27;1&#x27;);</span><br><span class="line">    let result2 = yield ajax(result1);</span><br><span class="line">    return result2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ite = g();</span><br><span class="line">ite.next().value.then(res=&gt;&#123;</span><br><span class="line">    ite.next(res).value.then(res=&gt;&#123;</span><br><span class="line">        let result = ite.next(res).value;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//为了更好的结合promise使用，出现了co库；</span><br><span class="line">//把一个生成器函数的迭代器，迭代完成后，统一执行一个成功回调；</span><br><span class="line"></span><br><span class="line">let co = require(&#x27;co&#x27;);</span><br><span class="line"></span><br><span class="line">function *g()&#123;</span><br><span class="line">    let result1 = yield ajax(&#x27;1&#x27;);</span><br><span class="line">    let result2 = yield ajax(result1);</span><br><span class="line">    return result2;</span><br><span class="line">&#125;</span><br><span class="line">co(g).then(res=&gt;&#123;console.log(res)&#125;);</span><br><span class="line"></span><br><span class="line">//co库的原理：利用next产出值的done的状态，去判断是否需要再次递归执行next方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function co(g)&#123;</span><br><span class="line">    let ite = g();</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        function next(data)&#123;</span><br><span class="line">            let &#123;value,done&#125; = item.next(data)</span><br><span class="line">            if(!done)&#123;</span><br><span class="line">                value.then(res=&gt;&#123;</span><br><span class="line">                    next(res)</span><br><span class="line">                &#125;,reject)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>






<p>6.es6 解构赋值和数组的操作方法</p>
<p>7.讲一下js循环事件池event loop，微任务和宏任务 （boss直聘、小米，苏宁）</p>
<p><a href="https://juejin.im/post/5aa5dcabf265da239c7afe1e">浏览器event loop 和node event-loop</a></p>
<p>浏览器的event loop</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js执行会存在一个执行栈，当前执行的同步代码都会放到执行栈中执行(宏任务)；</span><br><span class="line">同步代码执行过程中，如果遇到异步代码（settIimeout、promise等）,会将他们挂起，继续执行同步代码；</span><br><span class="line">同步代码执行完毕后，执行栈清空，会去查看微任务队列是否有可执行函数，然后拿到执行栈执行；</span><br><span class="line">当微任务队列执行完成后， 会去宏任务取一个任务放到执行栈执行，执行完成后再去查看微任务是不是有可执行函数，</span><br><span class="line">有的话取到执行栈执行；如此循环下去，就是event loop；</span><br><span class="line"></span><br><span class="line">挂起的异步代码，可执行后，会放到异步任务队列；异步任务队列分为两种队列，一种是微任务(promise,process.nextTick)</span><br><span class="line">一种是宏任务（setTimeout等）；</span><br><span class="line">微任务包括 process.nextTick ，promise ，MutationObserver。</span><br><span class="line">宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">执行完主执行线程中的任务。</span><br><span class="line">取出Microtask Queue中任务执行直到清空。</span><br><span class="line">取出Macrotask Queue中一个任务执行。</span><br><span class="line">取出Microtask Queue中任务执行直到清空。</span><br><span class="line">重复3和4。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>node环境 event loop 是区分阶段的；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">按照我们的循环的6个阶段依次执行，每次拿出当前阶段中的全部任务执行，清空NextTick Queue，清空Microtask Queue。再执行下一阶段，全部6个阶段执行完毕后，进入下轮循环。即：</span><br><span class="line"></span><br><span class="line">清空当前循环内的Timers Queue，清空NextTick Queue，清空Microtask Queue。</span><br><span class="line">清空当前循环内的I/O Queue，清空NextTick Queue，清空Microtask Queue。</span><br><span class="line">清空当前循环内的Check Queu，清空NextTick Queue，清空Microtask Queue。</span><br><span class="line">清空当前循环内的Close Queu，清空NextTick Queue，清空Microtask Queue。</span><br><span class="line">进入下轮循环。</span><br><span class="line"></span><br><span class="line">*注意：如果在timers阶段执行时创建了setImmediate则会在此轮循环的check阶段执行，如果在timers阶段创建了setTimeout，由于timers已取出完毕，则会进入下轮循环，check阶段创建timers任务同理。</span><br><span class="line"></span><br><span class="line">console.log(&#x27;1&#x27;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;2&#x27;);</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;4&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;5&#x27;);</span><br><span class="line">        setTimeout(function()&#123;console.log(11)&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    process.nextTick(function () &#123;</span><br><span class="line">        console.log(10)</span><br><span class="line">    &#125;)</span><br><span class="line">    setImmediate(function () &#123;</span><br><span class="line">        console.log(12)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,500);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;6&#x27;);</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;7&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;8&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">    process.nextTick(function () &#123;</span><br><span class="line">        console.log(9)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,500)</span><br><span class="line">// 第一次事件环</span><br><span class="line">//timer 阶段 1，2，4，6，7，; nexttick:10,9;//微任务队列  5，8</span><br><span class="line">//io 阶段 无</span><br><span class="line">//check 阶段 12</span><br><span class="line">//close 阶段 无</span><br><span class="line"></span><br><span class="line">//第二次事件环</span><br><span class="line">//timer 阶段 11;</span><br><span class="line">//io 阶段 无</span><br><span class="line">//check 阶段</span><br><span class="line">//close 阶段</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">两种环境对比：</span><br><span class="line">console.log(&#x27;1&#x27;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;2&#x27;);</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;4&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;5&#x27;); </span><br><span class="line">        setTimeout(function()&#123;console.log(100)&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,500)</span><br><span class="line">   </span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;6&#x27;);</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;7&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;8&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,500)</span><br><span class="line"></span><br><span class="line">浏览器执行：</span><br><span class="line">1，2，4，5，6，7，8 100</span><br><span class="line"></span><br><span class="line">node</span><br><span class="line">1，2，4，6，7，5，8，100；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(1);</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(()=&gt;&#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;)</span><br><span class="line">setImmediate(()=&gt;&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">&#125;)</span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">    resolve();</span><br><span class="line">    console.log(6)</span><br><span class="line">&#125;).then(()=&gt;&#123;</span><br><span class="line">    console.log(7)</span><br><span class="line">&#125;)</span><br><span class="line">//代码从上往下往下执行：</span><br><span class="line">// 1,5,6 同步执行；然后查看nextTick,输出3；然后查看微任务列表，输出7；输出7</span><br><span class="line">//然后timmer 阶段：输出2，无nextTick 无微任务</span><br><span class="line">// 然后io阶段，无</span><br><span class="line">//然后check阶段：Immediate执行输出 4；</span><br><span class="line">// 然后close阶段，无</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>8.js的垃圾回收处理机制的原理？（马蜂窝，美团）</p>
<p>(垃圾处理机制)[<a href="https://www.cnblogs.com/guoyongfeng/p/3907994.html]">https://www.cnblogs.com/guoyongfeng/p/3907994.html]</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不再用到的内存（一个不用到的值）没有及时释放，就叫做内存泄漏（memory leak）。</span><br><span class="line"></span><br><span class="line">垃圾回收机制：引用计数</span><br><span class="line">最常使用的方法叫做&quot;引用计数&quot;（reference counting）：语言引擎有一张&quot;引用表&quot;，</span><br><span class="line">保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就</span><br><span class="line">表示这个值不再用到了，因此可以将这块内存释放</span><br><span class="line"></span><br><span class="line">JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，</span><br><span class="line">他就知道不再需要这个对象，可以把它所占用的内存释放掉了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4]</span><br><span class="line">数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数</span><br><span class="line">为1。尽管后面的代码没有用到arr，它还是会持续占用内存;就会造成内存泄漏</span><br><span class="line"></span><br><span class="line">arr = null;</span><br><span class="line">如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">垃圾回收机制:标记清除：</span><br><span class="line">js中最常用的垃圾回收方式就是标记清除。</span><br><span class="line">当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为&quot;进入环境&quot;，</span><br><span class="line">从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，</span><br><span class="line">就可能会用到它们。而当变量离开环境时，则将其标记为&quot;离开环境&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>9.localstorage、sessionStorage 、cookie区别？（水滴）</p>
<p>二级域名是否可以取到一级域名的数据？<br>cookie是可以的 ，只要在一个主域即可<br>localstorage不可以，他是跨站点的，只要域名变了就取不到了。</p>
<p>10.什么是闭包，说下项目中应用场景？（水滴）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放</span><br><span class="line"> 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。</span><br><span class="line"> </span><br><span class="line"> 场景：</span><br><span class="line"> 1.可以实现公有变量，函数外或在其他函数中访问某一函数内部的参数</span><br><span class="line">  function add() &#123;</span><br><span class="line">           var num = 0;</span><br><span class="line">           function demo()&#123;</span><br><span class="line">              num++;</span><br><span class="line">              console.log(num);</span><br><span class="line">              &#125;</span><br><span class="line">              return demo;</span><br><span class="line">         &#125;</span><br><span class="line">  var test = add();</span><br><span class="line">  test();//1</span><br><span class="line">  test();//2</span><br><span class="line"> </span><br><span class="line">2.为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点</span><br><span class="line"></span><br><span class="line">3.计数器</span><br><span class="line">  function checkCount(target)&#123;</span><br><span class="line">      let count = 0;</span><br><span class="line">      let callbacks = [];</span><br><span class="line">      return function(fn)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            if(count == target)&#123;</span><br><span class="line">               callbacks.forEach(fn=&gt;fn())</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               callbacks.push(fn)</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let d = checkCount(3);</span><br><span class="line">  d(fn);</span><br><span class="line">  d(fn);</span><br><span class="line">  d(n)</span><br><span class="line">  </span><br><span class="line">  4.函数节流和防抖</span><br><span class="line">  </span><br></pre></td></tr></table></figure>


<p>11.ajax工作原理？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;GET&#x27;,&#x27;/api&#x27;,true);//true表示异步</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">      console.log(xhr.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤：1.创建xhr请求对象</span><br><span class="line">     2.创建http请求</span><br><span class="line">     3.监听状态变化</span><br><span class="line">     4.根据状态码处理结果,</span><br><span class="line">            ⑴未初始化状态。在创建完XMLHttpRequest对象时，该对象处于未初始化状态，此时XMLHttpRequest对象的readyState属性值为0。</span><br><span class="line">     </span><br><span class="line">            ⑵初始化状态。在创建完XMLHttpRequest对象后使用open()方法创建了HTTP请求时，该对象处于初始化状态。此时XMLHttpRequest对象的readyState属性值为1。</span><br><span class="line">     </span><br><span class="line">            ⑶发送数据状态。在初始化XMLHttpRequest对象后，使用send()方法发送数据时，该对象处于发送数据状态，此时XMLHttpRequest对象的readyState属性值为2。</span><br><span class="line">     </span><br><span class="line">            ⑷接收数据状态。Web服务器接收完数据并进行处理完毕之后，向客户端传送返回的结果。此时，XMLHttpRequest对象处于接收数据状态，XMLHttpRequest对象的readyState属性值为3。</span><br><span class="line">     </span><br><span class="line">            ⑸完成状态。XMLHttpRequest对象接收数据完毕后，进入完成状态，此时XMLHttpRequest对象的readyState属性值为4。此时接收完毕后的数据存入在客户端计算机的内存中，可以使用responseText属性或responseXml属性来获取数据。</span><br><span class="line">     </span><br><span class="line">      只有在XMLHttpRequest对象完成了以上5个步骤之后，才可以获取从服务器端返回的数据。因此，如果要获得从服务器端返回的数据，就必须要先判断XMLHttpRequest对象的状态</span><br><span class="line">     5.发送请求</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>12.js事件代理？（传智播客，58，瓜子二手车）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</span><br><span class="line"></span><br><span class="line">举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</span><br><span class="line"></span><br><span class="line">jquery:</span><br><span class="line">$(&quot;#nav&quot;).on(&#x27;click&#x27;,function(e)&#123;</span><br><span class="line">    $(e.target) =&gt;是每个点击的项目</span><br><span class="line">    $(this) =&gt;nav</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">$(&#x27;#nav&#x27;).on(&#x27;click&#x27;,&#x27;li&#x27;,function()&#123;</span><br><span class="line">   $(this) =&gt;点击的每一项</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展 jsdom事件流阶段：</span><br><span class="line">   捕获阶段-&gt;目标阶段-&gt;冒泡阶段</span><br><span class="line">   外内   -&gt;  当前 -&gt;冒泡</span><br><span class="line">   </span><br><span class="line">   如何执行冒泡 在捕获？</span><br><span class="line">   在捕获阶段的函数暂缓执行，等冒泡执行完后在执行捕获函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>13.js中this是如何工作的（基本都问）</p>
<p>14.怎么判断引用数据类型？（为什么能用Object.prototype.toString.call()去判断？）（水滴）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.instanceof 判断不准确</span><br><span class="line">var a = [];</span><br><span class="line">a instanceof Array  true</span><br><span class="line">a instanceof Object  true </span><br><span class="line"></span><br><span class="line">2.Object.prototype.toString.call([])  &#x27;[object Array]&#x27;</span><br><span class="line">  Object.prototype.toString.call(&#123;&#125;)   &quot;[object Object]&quot;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">3.isPrototypeOf</span><br><span class="line">Array.prototype.isPrototypeOf([]) true</span><br><span class="line">Object.prototype.isPrototypeOf([]) true</span><br><span class="line"> </span><br><span class="line"> isPrototypeOf 与instanceOf一样 都是查找原型链上是否存在。</span><br><span class="line"></span><br><span class="line">4.[].constructor == Array.prototype.constructor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line">Array.toString == Function.prototype.toString  true，</span><br><span class="line">根据原型链查找，查到Function.prototype.toString就停了。不会查到Object.prototype</span><br><span class="line"></span><br><span class="line">[].toString == Array.prototype.toString  true.</span><br><span class="line">根据原型链查找，查到Array.prototype.toString就停了。不会查到Object.prototype</span><br><span class="line"></span><br><span class="line">Array,Function 都在各自的原型上重新定义了toString方法，阻断了查找。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>15.js变量提升和作用域查找？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(type a) //undefined  变量提升</span><br><span class="line">console.log(type b) //err:b is not defined ,后续代码不执行</span><br><span class="line">console.log(type c) </span><br><span class="line">var a = function()&#123;return true&#125;; //变量提升</span><br><span class="line">window.b = function()&#123;  //给window创建属性，不存在变量提升</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a() &amp;&amp; b() &amp;&amp; c())</span><br><span class="line">function c()&#123;return c&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">	a:1,</span><br><span class="line">	f()&#123;</span><br><span class="line">		return this.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(o.f()); //1</span><br><span class="line">var o1 = o;</span><br><span class="line">console.log(o1.f());//1</span><br><span class="line">var o2 = o.f;</span><br><span class="line">console.log(o2()); //undefined  =&gt;this是window，window.a undefined;</span><br><span class="line">o.a=  5;</span><br><span class="line">console.log(o1.f());//5  堆内存 和 栈内存</span><br><span class="line">var o3 = &#123;a:5&#125;; </span><br><span class="line">console.log(o.f.call(o3)) //5 </span><br></pre></td></tr></table></figure>

<p>16.call apply bind 区别？如何实现？（基本都问）</p>
<p>17.实现跨域的方法？说一下JSOP的原理？（水滴）<br>（nginx服务器反向代理)[<a href="https://segmentfault.com/a/1190000012859206]">https://segmentfault.com/a/1190000012859206]</a><br>(postMessage + iframe实现页面跨域)[<a href="http://www.cnblogs.com/zhouzme/p/5758386.html]">http://www.cnblogs.com/zhouzme/p/5758386.html]</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsonp;</span><br><span class="line">   利用script标签src属性不受同源策略影响，可实现跨域；</span><br><span class="line">   通过与api方，对接好 回调参数字段～ cb=fn,fn在前端是一个全局的方法。后端返回script代码&quot;fn(&#123;name:1&#125;)&quot;,浏览器会执行；</span><br><span class="line">     前端代码：</span><br><span class="line">     function b(data) &#123;</span><br><span class="line">           console.log(data)</span><br><span class="line">       &#125;</span><br><span class="line">       let script = document.createElement(&#x27;script&#x27;)</span><br><span class="line">       script.src = &quot;http://localhost:3002/jsonp?cb=b&quot;;</span><br><span class="line">       document.body.appendChild(script)</span><br><span class="line">     node模拟后端：</span><br><span class="line">     </span><br><span class="line">     http.createServer((req, res) =&gt; &#123;</span><br><span class="line">         let &#123;pathname, query&#125; = url.parse(req.url, true);</span><br><span class="line">         if (pathname == &#x27;/jsonp&#x27;) &#123;</span><br><span class="line">            let school = JSON.stringify(&#123;name:&#x27;zfpx&#x27;&#125;);</span><br><span class="line">            // res.end(`var a  = $&#123;school&#125;`) //在全局就可以获取到 变量a</span><br><span class="line">            //  res.end(`b($&#123;school&#125;)`)</span><br><span class="line">             res.end(`$&#123;query.cb&#125;($&#123;school&#125;)`)</span><br><span class="line">             return ;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).listen(port, () =&gt; &#123;</span><br><span class="line">         console.log(`$&#123;port&#125; 服务器启动`)</span><br><span class="line">     &#125;);</span><br><span class="line">CORS</span><br><span class="line">   服务端响应：</span><br><span class="line">       res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&quot;*&quot;);//设置允许访问的源</span><br><span class="line">       res.setHeader(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;GET,POST,PUT,DELETE,OPTIONS&#x27;)</span><br><span class="line">       res.setHeader(&#x27;Access-Control-Allow-headers&#x27;,&#x27;name&#x27;)</span><br><span class="line">nginx服务器反向代理</span><br><span class="line"></span><br><span class="line">   //前端a.com 请求 后端api b.com/login 会出现跨域，</span><br><span class="line">   //在a.com所在服务器启动一个nginx代理服务器，监听a.com 的80端口；</span><br><span class="line">   //配置代理规则  ^/apis/ =&gt; b.com/ ,</span><br><span class="line">   //这让我们在请求a.com/apis/login 的时候，被nginx拦截，代理到 b.com/login</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">处理页面之间的跨域</span><br><span class="line"></span><br><span class="line">window.name+iframe 需要目标服务器响应window.name。</span><br><span class="line"></span><br><span class="line">window.location.hash+iframe 同样需要目标服务器作处理。</span><br><span class="line"></span><br><span class="line">html5的 postMessage+ifrme 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a.com/index.html </span><br><span class="line"></span><br><span class="line"> &lt;iframe src=&quot;b.com/index.html&quot; id=&quot;a&quot;&gt;</span><br><span class="line"> var data= &#123;name:1&#125;</span><br><span class="line"> document.getElementById(&quot;a&quot;).contentWindow.postMessage(data, &#x27;*&#x27;);</span><br><span class="line"> window.addEventListener(&#x27;message&#x27;,function(data)&#123;</span><br><span class="line">     </span><br><span class="line"> &#125;) </span><br><span class="line"> </span><br><span class="line">b.com/index.html</span><br><span class="line">注册监听消息事件：</span><br><span class="line">window.addEventListener(&#x27;message&#x27;,function(data)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;) </span><br><span class="line">//向父页面post消息</span><br><span class="line">window.parent.postMessage(&#123; </span><br><span class="line">            </span><br><span class="line"> &#125;, &#x27;*&#x27;);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>18.正则相关（小米,boss，头条）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a.正则捕获规则</span><br><span class="line">b.如果是嵌套捕获，得到的顺序是什么样的。</span><br><span class="line">c.正则捕获的引用和反向引用是什么</span><br><span class="line">d.正则的匹配默认是贪婪匹配么</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>19.[].toString()为啥会返回逗号隔开的字符串</p>
<p>20.数据proxy劫持与defineProperty对比。<br><a href="https://blog.csdn.net/qq_42833001/article/details/83302149">defineProperty 和 proxy 对比</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">es5</span><br><span class="line">defineProperty:修改或者定义一个对象的新属性， 返回这个对象</span><br><span class="line"></span><br><span class="line">1.不能监听数组变化 </span><br><span class="line">push, pop, shift, unshift,splice, sort, reverse，这些能修改原数组的方法成为变异方法；</span><br><span class="line">vue的做法是把这些方法重写来实现数组的劫持；</span><br><span class="line"></span><br><span class="line">2.必须遍历对象的每个属性，单独设置；</span><br><span class="line">Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">3.必须深层遍历嵌套对象</span><br><span class="line">vue的深度劫持；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">知识：</span><br><span class="line">基础描述符</span><br><span class="line">configrable:false,默认false,表示该属性是否可以修改 描述符配置；</span><br><span class="line">enumerable:false,默认false，表示该属性是否可以枚举</span><br><span class="line"></span><br><span class="line">设置和获取描述符</span><br><span class="line">set(newval)&#123;&#125;</span><br><span class="line">get()&#123;&#125;</span><br><span class="line"></span><br><span class="line">赋值描述符</span><br><span class="line">value:&#x27;&#x27;,</span><br><span class="line">writable:false,表示值是否可被修改，默认false</span><br><span class="line"></span><br><span class="line">设置和获取描述符和赋值描述符，只能有一个出现，基础描述符可以一直存在。</span><br><span class="line"></span><br><span class="line">============================</span><br><span class="line">es6</span><br><span class="line">proxy 代理，将一个对象进行包装，从而可以代理 操作对象的一些行为；</span><br><span class="line"></span><br><span class="line">1.针对对象:针对整个对象,而不是对象的某个属性; 不用 遍历属性；</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  name: &#x27;Eason&#x27;,</span><br><span class="line">  age: 30</span><br><span class="line">&#125;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  get (target, key, receiver) &#123;</span><br><span class="line">    console.log(&#x27;get&#x27;, key)</span><br><span class="line">    return Reflect.get(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value, receiver) &#123;</span><br><span class="line">    console.log(&#x27;set&#x27;, key, value)</span><br><span class="line">    return Reflect.set(target, key, value, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy = new Proxy(obj, handler)</span><br><span class="line">proxy.name = &#x27;Zoe&#x27; // set name Zoe</span><br><span class="line">proxy.age = 18 // set age 18</span><br><span class="line"></span><br><span class="line">// Reflect.get 和 Reflect.set 可以理解为类继承里的 super，即调用原来的方法</span><br><span class="line">Reflect.get():获取对象身上某个属性的值，类似于 target[name]。</span><br><span class="line">Reflect.set():将值分配给属性的函数,返回一个Boolean，如果更新成功，则返回true。</span><br><span class="line"></span><br><span class="line">2.支持数组:不需要对数组的方法进行重载，省去了众多 hack</span><br><span class="line">let arr = [1,2,3]</span><br><span class="line">let proxy = new Proxy(arr, &#123;</span><br><span class="line">    get (target, key, receiver) &#123;</span><br><span class="line">        console.log(&#x27;get&#x27;, key)</span><br><span class="line">        return Reflect.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set (target, key, value, receiver) &#123;</span><br><span class="line">        console.log(&#x27;set&#x27;, key, value)</span><br><span class="line">        return Reflect.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(4)</span><br><span class="line">// 能够打印出很多内容</span><br><span class="line">// get push     (寻找 proxy.push 方法)</span><br><span class="line">// get length   (获取当前的 length)</span><br><span class="line">// set 3 4      (设置 proxy[3] = 4)</span><br><span class="line">// set length 4 (设置 proxy.length = 4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.嵌套支持: get 里面递归调用 Proxy 并返回</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  info: &#123;</span><br><span class="line">    name: &#x27;eason&#x27;,</span><br><span class="line">    blogs: [&#x27;webpack&#x27;, &#x27;babel&#x27;, &#x27;cache&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  get (target, key, receiver) &#123;</span><br><span class="line">    console.log(&#x27;get&#x27;, key)</span><br><span class="line">    // 递归创建并返回</span><br><span class="line">    if (typeof target[key] === &#x27;object&#x27; &amp;&amp; target[key] !== null) &#123;</span><br><span class="line">      return new Proxy(target[key], handler)</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.get(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value, receiver) &#123;</span><br><span class="line">    console.log(&#x27;set&#x27;, key, value)</span><br><span class="line">    return Reflect.set(target, key, value, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy = new Proxy(obj, handler)</span><br><span class="line">// 以下两句都能够进入 set</span><br><span class="line">proxy.info.name = &#x27;Zoe&#x27;</span><br><span class="line">proxy.info.blogs.push(&#x27;proxy&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>21.js为什么要有protoType？如果没有会怎么样？(阿里)</p>
<p>22.generator函数？跟async有什么区别？（阿里）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">generator函数？跟async有什么区别？</span><br><span class="line">  async函数实际上是通过gnnerator函数实现的,实际上就是将一个generator函数自动执行的结果；</span><br><span class="line">  generator 需要配合 co这样的库，才方便调用；</span><br><span class="line">  async 是结合了co和generator的思想，实现的 ；</span><br><span class="line">  </span><br><span class="line">  async function fn()&#123;</span><br><span class="line">        let content1 = await ajax(&#x27;1&#x27;);</span><br><span class="line">        let content2 = await ajax(&#x27;2&#x27;);</span><br><span class="line">        return content2;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">  fn().then(res=&gt;&#123;</span><br><span class="line">  </span><br><span class="line">    //可以获取到content2</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  实际上实现的原理：</span><br><span class="line">  </span><br><span class="line">  function co(g)&#123;</span><br><span class="line">    let ite = g();</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        function next(data)&#123;</span><br><span class="line">            let &#123;value,done&#125; = ite.next(data);</span><br><span class="line">            if(!done)&#123;</span><br><span class="line">                if(value instanceOf Promise)&#123;</span><br><span class="line">                    value.then(res=&gt;&#123;</span><br><span class="line">                        next(res);</span><br><span class="line">                    &#125;,reject)</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    next(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  function fn()&#123;</span><br><span class="line">  </span><br><span class="line">    return co( </span><br><span class="line">            function *()&#123;</span><br><span class="line">               let content1 = yield ajax(&#x27;1&#x27;);</span><br><span class="line">               let content2 = yield ajax(&#x27;2&#x27;);</span><br><span class="line">               return content2;</span><br><span class="line">               </span><br><span class="line">         &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">`</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">23.</span><br><span class="line">mouseover和mouseenter的区别</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```$javascript</span><br><span class="line"></span><br><span class="line">mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</span><br></pre></td></tr></table></figure>






<p><a href="https://www.jianshu.com/p/81eb68ae5eb1">阮一峰es6要点总结——Proxy</a></p>
<h1 id="HTML-CSS相关"><a href="#HTML-CSS相关" class="headerlink" title="HTML+CSS相关"></a>HTML+CSS相关</h1><p>1.meta标签常用有哪些，列举？viewport属性有哪些分别代表什么（水滴）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">忽略页面中数字识别为电话 忽略email识别</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;</span><br><span class="line">关键字</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;楚楚推，楚楚推平台&quot;&gt;</span><br><span class="line">网页描述</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;楚楚推，分享生活，分享爱。&quot;&gt;</span><br><span class="line"></span><br><span class="line">允许加载哪个域的资源，防止xss攻击</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</span><br><span class="line"> </span><br><span class="line"> viewport虚拟窗口</span><br><span class="line"> width：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。</span><br><span class="line"> height：和 width 相对应，指定高度。</span><br><span class="line"> initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</span><br><span class="line"> maximum-scale：允许用户缩放到的最大比例。</span><br><span class="line"> minimum-scale：允许用户缩放到的最小比例。</span><br><span class="line"> user-scalable：用户是否可以手动缩放</span><br><span class="line">&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.清除浮动方法？（水滴）<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.添加空div，增加clear：both属性</span><br><span class="line">  </span><br><span class="line">  b.给父元素定义overflow：hidden，氟元素必须设置width</span><br><span class="line">  </span><br><span class="line">  c:给父元素增加伪元素 </span><br><span class="line">        .clearfix:after &#123;</span><br><span class="line">                clear: both;</span><br><span class="line">                content: &#x27;&#x27;;</span><br><span class="line">                font-size: 0;</span><br><span class="line">                display: block;</span><br><span class="line">                visibility: hidden;</span><br><span class="line">                height: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure></p>
<p>3.口述css盒子模型（水滴）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-box:</span><br><span class="line">    可以使设置的宽度和高度值应用到元素的内容框，盒子的width只包含内容。即总宽度=margin+border+padding+width</span><br><span class="line">border-box:</span><br><span class="line"> 设置的width值其实是除margin外的border+padding+element的总宽度，盒子的width包含border+padding+内容；即总宽度=margin+width</span><br></pre></td></tr></table></figure>

<p>4.实现左右固定宽度中间自适应布局有哪几种？（水滴）</p>
<p>  a. 最外层元素 {padding:0 200px};<br>     所有子元素都向左浮动<br>     第一个子元素：width：100%；float：left<br>     第二个子元素：width：200px;float:left;margin-left:-100%;position:relative;left:-200px;<br>     第三个子元素：width：200px;float:left;margin-left:-200px;position:relative;left:200px;</p>
<p>  b.<br>     前两个子元素浮动，第三个子元素通过margin来控制宽度；<br>        <div><br>        <div style="width: 200px;height: 200px;float: left;background: red"></div><br>        <div style="width: 200px;height: 200px;float: right;background: green"></div><br>        <div style="height:200px;margin:0 200px;background: blueviolet"></div><br>        </div><br>  c.<br>    flex布局；<br>  <div style="display: flex;"><br>        <div style="width: 200px;height: 200px;background: red"></div><br>        <div style="flex: 1;height: 200px;background: yellow"></div><br>        <div style="width: 200px;height: 200px;background: green"></div><br>    </div></p>
<p>5.position属性有哪几种，区别？（水滴）<br>  static、relative、absolute、fixed。</p>
<p>6.左侧固定宽度，右侧自适应？ 多种。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.左侧设置固定宽并且左浮动，右侧加个margin-left;</span><br><span class="line">.box1&#123;</span><br><span class="line">	background: red;</span><br><span class="line">	width: 200px;</span><br><span class="line">	float: left;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">	background: darkcyan;</span><br><span class="line">  margin-left: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.calc 计算右侧宽度,右浮动</span><br><span class="line">.box1&#123;</span><br><span class="line">  background:red;</span><br><span class="line">  width:200px;</span><br><span class="line">  float:left;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">  background:green;</span><br><span class="line">  width:cacl(100% - 200px)</span><br><span class="line">  float:right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.flex布局</span><br><span class="line"></span><br><span class="line">.outer&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  flex-direction:row;  </span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">  width:200px;</span><br><span class="line">  background:red</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">  flex:1;</span><br><span class="line">  background:green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d.左侧设置固定宽并且左浮动，右侧加overflow：hidden；</span><br><span class="line"></span><br><span class="line"> .box1&#123;</span><br><span class="line">    background:red;</span><br><span class="line">    width:200px;</span><br><span class="line">    float:left;</span><br><span class="line">  &#125;</span><br><span class="line">  .box2&#123;</span><br><span class="line">    background:green;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> e.absolute+margin</span><br><span class="line">   左侧设置固定宽并且绝对定位，右侧加margin-left；</span><br><span class="line">   .box1&#123;</span><br><span class="line">         background:red;</span><br><span class="line">         width:200px;</span><br><span class="line">         position:absolute;</span><br><span class="line">         left:0;</span><br><span class="line">       &#125;</span><br><span class="line">       .box2&#123;</span><br><span class="line">         background:green;</span><br><span class="line">         margin-left:200px;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7.用css实现一个三角形，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.triangle &#123;</span><br><span class="line">            width : 0;</span><br><span class="line">            height: 0;</span><br><span class="line">            border : 100px solid transparent;</span><br><span class="line">            border-top : 100px solid blue; /*这里可以设置border的top、bottom、left、right四个方向的三角*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>8.div垂直水平居中，多种方式（宽高不限）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            margin-left: -100px;</span><br><span class="line">            margin-top: -100px;</span><br><span class="line">        &#125;</span><br><span class="line">        .box1&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            transform: translate(-50%,-50%);</span><br><span class="line">        &#125;</span><br><span class="line">        .box1&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top:0;</span><br><span class="line">            left: 0;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            margin: auto;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .parent&#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            align-items: center;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>



<p>9.img i iframe video canvas q ol nav form em dl dt dd br hr audio abbr span<br>strong sub textarea  那些是块？</p>
<p>10.块元素 和行内元素有哪些?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用的 </span><br><span class="line">    div ul li  p h1 </span><br><span class="line">    </span><br><span class="line">    span i img input  a em  textarea</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">快元素：独占一行；自上至下；可设置狂傲</span><br><span class="line">行内元素：不独占一行；自左至右；设置宽高无效；设置margin padding，上下方向无效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可继承：font相关 font-size family weight font-style</span><br><span class="line">      line-height</span><br><span class="line">      text-align</span><br><span class="line">      text-indent 文本缩进</span><br><span class="line">      color 字体颜色</span><br><span class="line">      word-spacing字间隔</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>11.css高度宽度分别为视窗的20%的盒子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种:width:20%;padding-bottom:20%;</span><br><span class="line">第二种：width:20vw;height:20vw</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="前端框架相关"><a href="#前端框架相关" class="headerlink" title="前端框架相关"></a>前端框架相关</h1><p>1.什么是mvvm？mvvm实现原理？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">双向数据绑定</span><br><span class="line">M 数据层</span><br><span class="line">V 视图层</span><br><span class="line">VM View-Modle层，主要用于数据和视图的通讯</span><br><span class="line"></span><br><span class="line">利用Object.definedProperty 对data属性的get 和set 进行拦截和监听，并对每个data属性创建一个订阅池。</span><br><span class="line">在编译dom阶段，对dom进行解析，&quot;v-**&quot; &quot;&#123;&#123;&#125;&#125;&quot;，每编译到一处， 完成首次渲染，而且注册一个监听者，添加到data属性的订阅池中。</span><br><span class="line">数据影响视图：当数据改变，则通知该属性对应订阅池中所有的watcher，进行更新。</span><br><span class="line">视图影响数据(v-model): 通过绑定事件，然后改变data属性值，data属性值发生改变，通知所有watcher更新视图。</span><br><span class="line"></span><br><span class="line">设计思想：发布订阅模式，es6 definedProperty拦截。</span><br><span class="line"></span><br><span class="line">某一个属性，具备多个watcher，存入到一个dep中。当属性变化，才会去执行dep中的watcher。是由被监听属性（目标属性所触发），所以属于观察者模式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.vue兄弟组件传递数据？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父传子：通过给子组件绑定属性传值，:data=&quot;&quot;。子组件接收通过props设置接收的属性。</span><br><span class="line">子传父：通过事件传值，给子组件绑定事件，@事件名=&quot;父组件方法&quot;,子组件改变了数据，</span><br><span class="line">通过this.$emit(事件名,data)通知父组件。</span><br><span class="line"></span><br><span class="line">兄弟组件传值:中间件</span><br><span class="line">1.</span><br><span class="line">创建一个单独的vm实例。</span><br><span class="line">通过vm.$on(&#x27;事件名&#x27;,方法)绑定事件</span><br><span class="line">通过vm.$emit(事件名，data)通知兄弟组件修改数据。</span><br><span class="line">2.合并到同一个父组件下，通过父组件进行传值。</span><br><span class="line">3.vuex</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.vuex的使用场景？如何使用？原理？（阿里）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">应用场景:非父子关系的组件通信及共享数据，例如兄弟组件、祖孙组件。</span><br><span class="line">当你打算开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态</span><br><span class="line"> </span><br><span class="line">1.组件销毁，仍想保留数据，再进渲染组件直接获取数据。</span><br><span class="line">  举例：form表单弹窗组件，用户填写信息后，关闭弹窗。可在组件destroyed</span><br><span class="line">  时将用户填写信息保存到state中。在created时，读取state中数据进行渲染</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">2.有些组件构建和加载是依赖异步数据。v-if=&quot;&#123;&#123;store.userInfo.vip&#125;&#125;&quot;</span><br><span class="line"> 举例：有几个组件是与用户等级挂钩的，用户等级不同，展示的组件不同，并且这些组件</span><br><span class="line">     都在不同的父组件中。</span><br><span class="line">     可以将异步请求数据的方法和请求回来的数据保存到state中，集中管理调用。</span><br><span class="line">     这样异步请求结束，所有的组件就都能得到状态，从而进行渲染。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">3.多处共用数据，多处可更改数据，互相影响。</span><br><span class="line">举例：购物车，详情页添加、删除，购物车页面添加删除</span><br><span class="line">     消息列表消息数量</span><br><span class="line">     订单相关跳转路由，订单列表跳转订单详情，订单详情跳转订单评价，</span><br><span class="line">     不同路由之间订单数据共享。</span><br><span class="line"> </span><br><span class="line">============================================</span><br><span class="line">如何使用：</span><br><span class="line"></span><br><span class="line">============================================</span><br><span class="line">原理:</span><br><span class="line">1.全局注入store：</span><br><span class="line">vuex 利用插件机制调用install进行安装vuex，install过程中利用mixin混入，全局注册混入对象，将会影响所有之后创建的Vue实例。</span><br><span class="line">混入 beforeCreate 钩子，每个实例生成都会先调用混入的beforeCreate钩子（vuexInit），vueInit检查当前options中是否有store对象，</span><br><span class="line">如果没有则会去父组件中查找。</span><br><span class="line"></span><br><span class="line">a. Vue.use(Vuex) =&gt;安装Vuex插件,调用Vuex的install方法。</span><br><span class="line"></span><br><span class="line">b. Vuex.install =  function()&#123;</span><br><span class="line">    Vue.mixin(&#123; beforeCreate: vuexInit &#125;);</span><br><span class="line">&#125;</span><br><span class="line">store注入 vue的实例组件的方式，是通过vue的 mixin机制，借助vue组件的生命周期钩子beforeCreate 完成的。</span><br><span class="line">即 每个vue组件实例化过程中，会在 beforeCreate 钩子前调用 vuexInit 方法。</span><br><span class="line"></span><br><span class="line">c.vuexInit核心代码如下：</span><br><span class="line">this.$store = typeof options.store === &#x27;function&#x27;</span><br><span class="line">    ? options.store()</span><br><span class="line">    : options.store</span><br><span class="line">    </span><br><span class="line">this的指向，得益于mixin机制，this将指向 vue组件实例！最终，我们可以再vue组件实例上获得vuex的store </span><br><span class="line">对象的引用 $store！</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">function applyMixin (Vue) &#123;</span><br><span class="line">  var version = Number(Vue.version.split(&#x27;.&#x27;)[0]);</span><br><span class="line"></span><br><span class="line">  if (version &gt;= 2) &#123;</span><br><span class="line">    Vue.mixin(&#123; beforeCreate: vuexInit &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    var _init = Vue.prototype._init;</span><br><span class="line">    Vue.prototype._init = function (options) &#123;</span><br><span class="line">      if ( options === void 0 ) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      options.init = options.init</span><br><span class="line">        ? [vuexInit].concat(options.init)</span><br><span class="line">        : vuexInit;</span><br><span class="line">      _init.call(this, options);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function vuexInit () &#123;</span><br><span class="line">    var options = this.$options;</span><br><span class="line">    if (options.store) &#123;</span><br><span class="line">      this.$store = typeof options.store === &#x27;function&#x27;</span><br><span class="line">        ? options.store()</span><br><span class="line">        : options.store;</span><br><span class="line">    &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">      this.$store = options.parent.$store;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.数据响应式，state 和 getter数据更新如何映射到各个组件实例中自动更新，并update组件。</span><br><span class="line">某一组件store更新时，如何通知其他组件进行数据更新，和UI更新！通过简单分析可知，问题的根本就是组件通信的问题！</span><br><span class="line"></span><br><span class="line">原理：vuex的state是借助vue的响应式data实现的，getter是借助vue的computed属性实现的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在 new Vuex.Store(&#123;state,getters&#125;)实例过程中，</span><br><span class="line">Store的构造函数执行了这样一个函数 resetStoreVM(this, state); this-&gt;store实例，就是我们用到的this.$store</span><br><span class="line">作用:</span><br><span class="line">    初始化了一个vue实例_vm。</span><br><span class="line">    将state注入到该实例中，由于vue的data是响应式的，所以$$state 是响应式的。当我们在更改this.$store.state.xxx时，基于vue的data的响应式机制，所有相关的state.xxx的值都会自动更新，ui自动更新。</span><br><span class="line">    </span><br><span class="line">    将store.getters作为computed属性注入到_vm上，然后将store.getter映射出一个新的对象，定义get拦截去获取_vm.xxx;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">实际应用中,我们修改this.$store.state.xxx  =&gt; this.$store._vm.data.$$state =&gt; store._vm.$$state</span><br><span class="line">get state () &#123;</span><br><span class="line">    return this._vm._data.$$state</span><br><span class="line">  &#125;</span><br><span class="line">实际应用中，我们获取getter属性， this.$store.getters.xxx ,实际上取得的 this.$store._vm.xxx 取得是_vm的计算属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 源码:</span><br><span class="line"> function resetStoreVM (store, state, hot) &#123;</span><br><span class="line">    //处理getter</span><br><span class="line">    store.getters = &#123;&#125;;</span><br><span class="line">    var wrappedGetters = store._wrappedGetters;</span><br><span class="line">    var computed = &#123;&#125;;</span><br><span class="line">    forEachValue(wrappedGetters, function (fn, key) &#123;</span><br><span class="line">      computed[key] = function () &#123; return fn(store); &#125;;</span><br><span class="line">      Object.defineProperty(store.getters, key, &#123;</span><br><span class="line">        get: function () &#123; return store._vm[key]; &#125;,</span><br><span class="line">        enumerable: true // for local getters</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    //创建vue实例，响应数据</span><br><span class="line">    store._vm = new Vue(&#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        $$state: state</span><br><span class="line">      &#125;,</span><br><span class="line">      computed: computed</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>4.用vue-router实现导航切换 类似tab栏的那种；（一个tab有三个页，下面展示的内容怎么组件实现）</p>
<p>5.vue和react区别 </p>
<p><a href="https://www.sohu.com/a/244192046_100180425">区别</a></p>
<p>6.vue 的watch中可以使用箭头函数吗</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不能使用,箭头函数在声明时就确定了this指向，指向的是父级作用域上下文。</span><br><span class="line">当函数执行时，里面的this并不是vue实例。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>7.vue自定义组件的双向绑定怎么实现？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件;</span><br><span class="line">&lt;search-input v-model=&quot;text&quot;&quot;&gt;&lt;/search-input &gt;</span><br><span class="line">等价于&lt;search-input v-bind:value=&quot;searchText&quot;</span><br><span class="line">                   v-on:input=&quot;searchText = $event&quot;&gt;&lt;/search-input &gt;</span><br><span class="line">                   </span><br><span class="line">所以 在组件内部的input标签上，就不能用v-model了</span><br><span class="line">为了让它正常工作，这个组件内的 &lt;input&gt; 必须：</span><br><span class="line">将其 value 特性绑定到一个名叫 value 的 prop 上</span><br><span class="line">在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出</span><br><span class="line"></span><br><span class="line">Vue.component(&#x27;custom-input&#x27;, &#123;</span><br><span class="line">  props: [&#x27;value&#x27;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      v-bind:value=&quot;value&quot;</span><br><span class="line">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>8.mvc和mvvm的区别，手画一个原理流程图，类似view model viewmodel的一个流程交互图</p>
<p>9.v-if 和 v-show的区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏,首次渲染消耗大，适合频繁切换</span><br><span class="line">v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果，。具备懒惰性，不适合频繁切换，首次消耗小。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10.v-if跟 v-else，如果太多了你可以怎么优化，可以用什么设计模式</p>
<p>11.<keep-alive></keep-alive>的作用是什么?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;&lt;/keep-alive&gt; </span><br><span class="line">包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。</span><br><span class="line">用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素</span><br><span class="line">大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是</span><br><span class="line">一个频率很高的页面，那么就可以对列表组件使用&lt;keep-alive&gt;&lt;/keep-alive&gt;进行缓存，这样用户每次返回列表的时候，</span><br><span class="line">都能从缓存中快速渲染，而不是重新渲染.</span><br><span class="line"></span><br><span class="line">使用了 keep-alive组件的两种状态 </span><br><span class="line">actived  组件被激活时调用，</span><br><span class="line">deactived 组件被移除时调用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>12.mixin 全局混入</p>
<p><a href="https://cn.vuejs.org/v2/guide/mixins.html">vue官方混入</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">混入规则： </span><br><span class="line"> 混入内容值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</span><br><span class="line"> 混入的是钩子函数时 created...等，同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</span><br><span class="line"> </span><br><span class="line"> 特点：mixin中的this指的 当前vue实例。</span><br><span class="line"> </span><br><span class="line"> 全局混入： 每个vue实例都混入该对象，包括组件的实例。</span><br><span class="line"> Vue.mixin(&#123;</span><br><span class="line">    created:function()&#123;</span><br><span class="line">        this.$options.xxx</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> new Vue(&#123;</span><br><span class="line">    el:xxx</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> 局部混入:只在当前实例混入</span><br><span class="line"> var mixin = &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name:1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> new Vue(&#123;</span><br><span class="line">    mixins:[mixin]</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>13.vue插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">插件通常会为 Vue 添加全局功能。插件的范围没有限制——一般有下面几种：</span><br><span class="line">添加全局方法或者属性，如: vue-custom-element</span><br><span class="line"></span><br><span class="line">添加全局资源：指令/过滤器/过渡等，如 vue-touch</span><br><span class="line"></span><br><span class="line">通过全局 mixin 方法添加一些组件选项，如: vue-router</span><br><span class="line"></span><br><span class="line">添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</span><br><span class="line"></span><br><span class="line">开发:</span><br><span class="line">let myplugin = &#123;&#125;</span><br><span class="line"> myplugin.install= （Vue,optiosn）=&gt;&#123;</span><br><span class="line">    //增加全局方法或者属性，Vue类调用的</span><br><span class="line">    Vue.globalMethod = ()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">    // 2. 添加全局资源，全局指令 全局过滤器等</span><br><span class="line">      Vue.directive(&#x27;my-directive&#x27;, &#123;</span><br><span class="line">        bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">          // 逻辑...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">     // 3. 注入组件，混入对象等，比如vue-router vuex</span><br><span class="line">        Vue.mixin(&#123;</span><br><span class="line">          created: function () &#123;</span><br><span class="line">            // 逻辑...</span><br><span class="line">          &#125;,</span><br><span class="line">          conponents:&#123;&#125;</span><br><span class="line">          ...</span><br><span class="line">        &#125;)</span><br><span class="line">      //4.添加实例方法</span><br><span class="line">      Vue.prototype.$myMethod = function (methodOptions) &#123;</span><br><span class="line">          // 逻辑...</span><br><span class="line">        &#125;</span><br><span class="line">      //</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：Vue.use(myplugin);</span><br><span class="line">use方法会自动调用myPlugin.install并且传入Vue这个类</span><br></pre></td></tr></table></figure>
<p>14.Vue.extend 和 Vue.component区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Vue.component</span><br><span class="line">// 注册组件，传入一个扩展过的构造器</span><br><span class="line">Vue.component(&#x27;my-component&#x27;, Vue.extend(&#123; /* ... */ &#125;))</span><br><span class="line"></span><br><span class="line">// 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span><br><span class="line">Vue.component(&#x27;my-component&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line"></span><br><span class="line">// 获取注册的组件 (始终返回构造器)</span><br><span class="line">var MyComponent = Vue.component(&#x27;my-component&#x27;)</span><br><span class="line"></span><br><span class="line">注册组件，不管是Vue.component() 或者 局部components&#123;&#125;,都可 传入组件选项或者组件构造器；</span><br><span class="line"></span><br><span class="line">=============================================</span><br><span class="line">Vue.extend </span><br><span class="line">//使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</span><br><span class="line">// 是需要new的，或者通过 Vue.component注册组件，或者 注册局部组件 components:&#123;构造器&#125;</span><br><span class="line"></span><br><span class="line">var Profile = Vue.extend(&#123;</span><br><span class="line">  template: &#x27;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&#x27;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      firstName: &#x27;Walter&#x27;,</span><br><span class="line">      lastName: &#x27;White&#x27;,</span><br><span class="line">      alias: &#x27;Heisenberg&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 创建 Profile 实例，并挂载到一个元素上。</span><br><span class="line">new Profile().$mount(&#x27;#mount-point&#x27;)</span><br><span class="line">new Profile(&#123;el:&#x27;#mount-point&#x27;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>15.vue插件机制 封装组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只用于渲染页面的组件</span><br><span class="line">使用：Vue.use(search)全局就会可以用 &lt;search-input&gt;&lt;/search-input&gt;</span><br><span class="line">import _search from &#x27;./search.vue&#x27;</span><br><span class="line">search.install = function(Vue,options)&#123;</span><br><span class="line">   let searchPlugin  = Vue.extend(_search)</span><br><span class="line">   //1.通过注册全局组件的方式</span><br><span class="line">   Vue.component(&#x27;search-input&#x27;,searchPlugin) </span><br><span class="line">   Vue.component(&#x27;search-input&#x27;,_search) </span><br><span class="line">   </span><br><span class="line">   //2.通过Vue.mixin 全局混入的方式</span><br><span class="line">   Vue.mixin(&#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            &#x27;search-input&#x27;:_search</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">   &#125;)</span><br><span class="line">   Vue.mixin(&#123;</span><br><span class="line">           components:&#123;</span><br><span class="line">               &#x27;search-input&#x27;:searchPlugin </span><br><span class="line">           &#125; </span><br><span class="line">      &#125;)</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">可报漏api 可受控制的组件</span><br><span class="line">使用：Vue.use(toast)   调用this.$toast.show()</span><br><span class="line"></span><br><span class="line">import _toast from &#x27;./toast.vue&#x27;</span><br><span class="line">let $vm</span><br><span class="line">toast.install = function(Vue,options)&#123;</span><br><span class="line">    if(!$vm)&#123;</span><br><span class="line">        let searchPlugin  = Vue.extend(_toast)</span><br><span class="line">        let $vm = new searchPlugin(&#123; </span><br><span class="line">            el:document.createElement(&quot;div&quot;);</span><br><span class="line">        &#125;)</span><br><span class="line">        document.body.appendChild($vm.$el)</span><br><span class="line">    &#125;</span><br><span class="line">    1.toast内部method提供两个方法show 和hide；</span><br><span class="line">    </span><br><span class="line">    2.在此处扩展</span><br><span class="line">    $vm.show = function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    $vm.hide = function()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    $vm.changePropsData = function(title)&#123;</span><br><span class="line">        //title 为组件内部生声明的props</span><br><span class="line">        $vm.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        created:funtion()&#123;</span><br><span class="line">            this.$vm = $vm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>16.vue 在计算属性的时候，computed和用method里的方法计算有什么区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">computed </span><br><span class="line">计算属性会依赖于他使用的data中的属性，只要是依赖的属性值有改变，则自动重新调用一下计算属性；</span><br><span class="line">如果他所依赖的这些属性值没有发生改变，那么计算属性的值是从缓存中来的，而不是重新编译，那么性能要高一些，</span><br><span class="line">所以vue中尽可能使用computed替代watch。</span><br><span class="line"></span><br><span class="line">method 是实时调用，实时计算；没有缓存</span><br><span class="line"></span><br><span class="line">watch 是监听属性，当属性变化就会执行响应的回调函数；</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>17.vue中render，nextTick介绍一下？</p>
<p>18.component中data:function(){} 和data:{}区别？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">类比与引用数据类型。如果不用function return 每个组件的data都是内存的同一个地址，那一个数据改变其他也改变了，这当然就不是我们想要的。用function return 其实就相当于申明了新的变量，相互独立，自然就不会有这样的问题；js在赋值object对象时，是直接一个相同的内存地址。所以为了每个组件的data独立，采用了这种方式。</span><br><span class="line">如果不是组件的话，正常data的写法可以直接写一个对象，比如data：&#123; msg ： &#x27; 下载 &#x27; &#125;，但由于组件是会在多个地方引用</span><br><span class="line">的，JS中直接共享对象会造成引用传递，也就是说修改了msg后所有按钮的msg都会跟着修改，所以这里用function来每次返回一个</span><br><span class="line">对象实例。</span><br><span class="line"></span><br><span class="line">如果组件用 data:&#123;&#125;，那么多个调用组件的地方，将公用一个data，会互相影响。</span><br><span class="line">为什么会公用一个data？</span><br><span class="line">import 引入的模块，es module导入导出的都是内存地址，导出值导入互相影响</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>19.vue生命周期钩子？<br>beforeCreate  实例创建之前<br>created 实例创建完成<br>beforeMount 挂载前<br>mounted 挂载后<br>beforeUpdate 更新前<br>updated  更新后<br>beforeDestory 销毁前<br>destoryed 销毁后</p>
<p> 20.vue-routers的实现</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.hash /#/  + onhashChange 事件</span><br><span class="line"></span><br><span class="line">改变hash，浏览器的请求不包括hash部分，不会刷新页面；通过hashchange事件监听路由变化</span><br><span class="line"></span><br><span class="line">b.history操作</span><br><span class="line">  </span><br><span class="line">  history.back() history.go() history.forward()，这些前进后退的操作会触发popstate事件；</span><br><span class="line">  window.addEventListener(&#x27;popstate&#x27;，fn）</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  pushState，replaceState 并不会触发popstate事件，这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。</span><br><span class="line">  只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求，也就不会刷新；</span><br><span class="line">  但是这两个方法不会触发popstate事件，需要我们手动去修改pushstate方法，增加消息通知；</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //1.对方法进行加工,并且发布消息;</span><br><span class="line">  function apo(type)&#123;</span><br><span class="line">    var source = window.history[type];</span><br><span class="line">    return  function()&#123;</span><br><span class="line">        var event = new Event(type);</span><br><span class="line">        event.arguments = arguments;</span><br><span class="line">        window.disptchEvent(event);</span><br><span class="line">        return source.apply(this,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  window.history.pushState = aop(&#x27;pushState&#x27;);</span><br><span class="line">  window.history.replaceState = aop(&#x27;replaceState&#x27;);</span><br><span class="line"> </span><br><span class="line"> window.addEventListener(&#x27;pushState&#x27;,function()&#123;console.log(1)&#125;)</span><br><span class="line">  </span><br><span class="line"> window.addEventListener(&#x27;replaceState&#x27;,function()&#123;console.log(2)&#125;)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">2.发布订阅模式，创建event bus来实现；拦截pushState 和replaceState ,发布消息；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
<h1 id="前端工程化相关"><a href="#前端工程化相关" class="headerlink" title="前端工程化相关"></a>前端工程化相关</h1><p>1.webpack基本配置有哪些？(都问)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">entry </span><br><span class="line">output</span><br><span class="line">module(loader)</span><br><span class="line">plugin</span><br><span class="line">resolve(alias extentions)</span><br><span class="line"></span><br><span class="line">webpack.dllPlugin();</span><br><span class="line">webpack.dllReferencePlugin();</span><br><span class="line">webpack.commonChunkPlugin();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.vue-cli3脚手架的基本配置？</p>
<p><a href="https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C">vue-cli3 支持全局注册基础化组件</a></p>
<p>3.webpack作用？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、合并js文件，压缩代码；处理图片资源等静态资源，减少http请求；</span><br><span class="line">2、css预处理，编译less/sass等浏览器不能直接识别的语言；</span><br><span class="line">3、对文件进行hash，可以防止浏览器缓存。</span><br><span class="line">4、一切皆模块，让模块更容易服用，避免重复加载或者加载不必要的模块，并且能够防止全局变量冲突。</span><br></pre></td></tr></table></figure>

<p>4.你对脚手架有研究过么?（小米）</p>
<p>5.项目打包部署你都是怎么弄的？（小米）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jekins部署，具体环境是运维来搭建的。</span><br></pre></td></tr></table></figure>



<h1 id="应用场景开发相关"><a href="#应用场景开发相关" class="headerlink" title="应用场景开发相关"></a>应用场景开发相关</h1><p>1.简述微信公众号授权过程？（每日优鲜）</p>
<p>2.客户端与前端的交互的原理 ，怎么交互？（瓜子二手车）</p>
<p>安卓:webview<br>1.js全局调用客户端方法：java向前端注入了全局对象ccjBridgeInstance，这个对象上面有一些客户端提供的方法 供前端调用；<br>                     url传参，native拦截；</p>
<pre><code>                 协议拦截，与客户端定义协议，通过动态向html插入 iframe，请求协议地址传带参数；native进行拦截
                 shareFriends://com.culiu.JiuKuaiJiu###分享标题###分享地址             
                
</code></pre>
<p>2.客户端调用js:window上声明响应的回调地址，window.方法名_callback，提供给客户端调用；</p>
<p>ios:UIwebview wkwebview<br>UIwebview:<br>1.js全局调用客户端方法：java向前端注入了全局对象ccjBridgeInstance，这个对象上面有一些客户端提供的方法 供前端调用；<br>                    url传参，native拦截</p>
<p>2.客户端调用js:window上声明响应的回调地址，window.方法名_callback，提供给客户端调用；</p>
<p>WKwebview:<br>js调用客户端：window.webkit.messageHandlers[方法名].possmessage(data)；去调用<br>            url传参，native拦截<br>客户端调用js:window上声明响应的回调地址，window.方法名_callback，提供给客户端调用；</p>
<p>回调方法遇到的问题：<br>连续调用相同的bridge，native只调用一次回调；<br>而且当时我们的回调地址都是直接赋给window的一个属性了，导致我们的回调一次次覆盖，只保留了最后一次；<br>解决方案：将回调收拢，每个bridge方法，对应一个回调函数池，提供给native的方法就是遍历这个回调函数池中的回调，依次执行；<br>        调用brigde时，就是向回调函数池中添加 函数；</p>
<p>#场景算法题</p>
<p>1.将aabbcccda 字符传替换成abcda？（将连续重复的字符去重）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将连续重复的字符去重,这种会有重复项，aabbcccdc=&gt;字符传替换成abcdc</span><br><span class="line">reduce拼接，</span><br><span class="line">function switchStr(str) &#123;</span><br><span class="line">    let arr = str.split(&#x27;&#x27;);</span><br><span class="line">    return arr.reduce((prev,next,index,origin)=&gt;&#123;</span><br><span class="line">        if(prev.slice(prev.length-1) == next)&#123;</span><br><span class="line">            return prev;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return prev + next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,&#x27;&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function switchStr(str)&#123;</span><br><span class="line">    return str.replace(/(.)(/1)+/,function(...args)&#123;</span><br><span class="line">        retrun args[1]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.js实现字符串trim方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原生：</span><br><span class="line">var a = &#x27;  123  &#x27;</span><br><span class="line">a.trim();</span><br><span class="line"></span><br><span class="line">js实现：</span><br><span class="line">String.prototype.trim = function()&#123;</span><br><span class="line">    return this.replace(/(^\s+|\s+$)/g,function()&#123;</span><br><span class="line">       return &quot;&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.原生js实现字符串split方法？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>3.函数节流？防抖？有何区别？</p>
<p><a href="https://juejin.im/post/5c87b54ce51d455f7943dddb">防抖,节流</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数节流</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.<span class="title function_">call</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">          fn.<span class="title function_">call</span>(<span class="variable language_">this</span>,args);</span><br><span class="line">          flag = <span class="literal">true</span>;</span><br><span class="line">      &#125;,<span class="number">500</span>)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//防抖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        fn.<span class="title function_">call</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.<span class="title function_">call</span>(<span class="variable language_">this</span>,args)</span><br><span class="line">        &#125;,<span class="number">300</span>) </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//区分： 节流在一定时间内调用多次，总是执行第一次调用的，执行完成后，才能再次调用。</span></span><br><span class="line">  <span class="comment">//      防抖在一定时间内调用多次，后续的调用会覆盖前面的调用，执行的永远是最后一次调用的。</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.[a,b,c],写个方法将数组全排列 ，变成[abc,acb,bac,bca,cab,cba] （百度）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思路:每次都取出一个，然后将除去这一个的其他数进行全排列。然后在将取出的那个数拼接到开头</span><br><span class="line">距离：取出a，然后b和c的全排列有两种：bc，cb； 这样就可以算出abc，acb；</span><br><span class="line">    取出b，然后a和c的全排列有两种：ac，ca； 这样就可以算出bac，bca；</span><br><span class="line">    取出c，然后a和b的全排列有两种：ab，ba； 这样就可以算出cab，cba；</span><br><span class="line">    </span><br><span class="line">    递归千万条，出口第一条：出口就是当数组为两项时，就可以自己写出 全排列。</span><br><span class="line"></span><br><span class="line">// [a,b,c]=&gt;[abc,acb,bac,bca,cab,cba]</span><br><span class="line">function permute(ary)&#123;</span><br><span class="line">    if(ary.length &lt;= 2)&#123;</span><br><span class="line">        if(ary.length == 2)&#123;</span><br><span class="line">            return [ary.join(&#x27;&#x27;),ary.reverse().join(&quot;&quot;)]</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return [ary[0]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let result = [];</span><br><span class="line">    ary.forEach((item,index)=&gt;&#123;</span><br><span class="line">        let all = permute(ary.slice(0,index).concat(ary.slice(index+1)));</span><br><span class="line">        all = all.map(val=&gt;&#123;</span><br><span class="line">            return item+val+&#x27;&#x27;;</span><br><span class="line">        &#125;)</span><br><span class="line">        result = result.concat(all);</span><br><span class="line">    &#125;)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(permute([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]));</span><br><span class="line"></span><br><span class="line">字符串全排列 abc =&gt;[abc,acb,bac,bca,cab,cba]</span><br><span class="line">const anagrams = str =&gt; &#123;</span><br><span class="line">    if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];</span><br><span class="line">    return str.split(&#x27;&#x27;).reduce((acc, letter, i) =&gt;</span><br><span class="line">        acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val =&gt; letter + val)), []);</span><br><span class="line">&#125;;</span><br><span class="line">console.log(anagrams(&#x27;1234&#x27;));</span><br><span class="line">数组全排列 [a,b,c]=&gt;[[a,b,c],[a,c,b]...]</span><br><span class="line">    function permute(arr) &#123;</span><br><span class="line">        if(arr.length &lt;= 2)&#123;</span><br><span class="line">            if(arr.length == 2)&#123;</span><br><span class="line">                return [arr,[arr[1],arr[0]]];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return [arr];</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        return arr.reduce((prev,next,i)=&gt;&#123;</span><br><span class="line">            let pool= permute(arr.slice(0,i).concat(arr.slice(i+1)));</span><br><span class="line">            pool = pool.map(item=&gt;&#123;</span><br><span class="line">                item.unshift(next);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;);</span><br><span class="line">            return prev.concat(pool)</span><br><span class="line">        &#125;,[])</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(permute([ 1, 2, 3]));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.数组对象去重(vipkid)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//key 和 value都对比；</span><br><span class="line">//[&#123;a:11,b:12&#125;,&#123;c:21,d:22&#125;,&#123;a:12,b:11&#125;,&#123;c:21,d:22&#125;,&#123;a:1,e:&#123;name:&#x27;1&#x27;&#125;&#125;,&#123;a:1,e:&#123;name:&#x27;1&#x27;&#125;&#125;]</span><br><span class="line">function fn(ary)&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    for(let i = 0 ;i &lt; ary.length;i++)&#123;</span><br><span class="line">        let key = JSON.stringify(ary[i]);</span><br><span class="line">        obj[key] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.keys(obj).map(item=&gt;&#123;</span><br><span class="line">        return JSON.parse(item)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//[&#123;a:11,b:12&#125;,&#123;c:21,d:22&#125;],[&#123;a:12,b:11&#125;,&#123;c:21,d:22&#125;]</span><br><span class="line">//找出两个数组对象中 key和value都相同的对象。找出&#123;c:21:d:22&#125;</span><br><span class="line"></span><br><span class="line">function fn(a1,a2)&#123;</span><br><span class="line">    let o1 = &#123;&#125;;</span><br><span class="line">    let result = []</span><br><span class="line">    for(let i = 0 ;i&lt;a1.length;i++)&#123;</span><br><span class="line">        let key = JSON.stringify(a1[i]);</span><br><span class="line">        o1[key] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i = 0 ;i&lt;a2.length;i++)&#123;</span><br><span class="line">        let key = JSON.stringify(a2[i])</span><br><span class="line">        if(o1[key])&#123;</span><br><span class="line">            result.push(a2[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.你所用到的排序方法</p>
<p>7.实现一个方法，能够把多重数组变成一个一维数组,flat方法。[1,[1,2],[3,4,5]]转换为[1,1,2,3,4,5] （vipkid）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flat</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr[i]) == <span class="string">&#x27;[object Array]&#x27;</span>)&#123;</span><br><span class="line">            result = result.<span class="title function_">concat</span>(<span class="title function_">flat</span>(arr[i]))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>8.12345数组混排 (水滴)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用随机数</span><br><span class="line"></span><br><span class="line">function switchAry(ary)&#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    let len = ary.length;</span><br><span class="line">    for(let i = 0 ;i&lt;len;i++)&#123;</span><br><span class="line">       let j =  Math.floor(Math.random()*ary.length); </span><br><span class="line">       let cur = ary.splice(j,1)[0];</span><br><span class="line">       result.push(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function sort(ary)&#123;</span><br><span class="line">    return ary.sort(function()&#123;</span><br><span class="line">        return Math.random() - 0.5 </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // Math.floor(Math.random()*5)  0-4，</span><br><span class="line"> // Math.ceil(Math.random()*5)   1-5</span><br><span class="line"> // Math.round(Math.random()*5)   0-5</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<p>9.将字符串中重复出现的字符，去重；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.转成数组，去重，然后拼接；</span><br><span class="line"> function uqinue(str)&#123;</span><br><span class="line">     let ary = str.split(&quot;&quot;);</span><br><span class="line">     return Array.from(new Set(ary)).join(&quot;&quot;)    </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">2.遍历</span><br><span class="line"> function uqinue(str)&#123;</span><br><span class="line">     let result = &quot;&quot;;</span><br><span class="line">     for(let i = 0;i&lt;str.length;i++)&#123;</span><br><span class="line">         if(result.indexOf(str[i])==-1)&#123;</span><br><span class="line">         result = result + str[i]</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>10.abcaaaaaabcabcabcabbbabc 获取abc的重复次数 和索引</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 方案1，利用abc进行拆分成数组，数组长度-1为出现次数，；然后计算索引</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">str,t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ary = str.<span class="title function_">split</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> n  = ary.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> iAry = [];</span><br><span class="line">    ary.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev,next,i,</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i ==<span class="number">0</span>)&#123;</span><br><span class="line">            iAry.<span class="title function_">push</span>(prev+next.<span class="property">length</span>);</span><br><span class="line">            <span class="keyword">return</span> prev + next.<span class="property">length</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == ary.<span class="property">length</span>-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iAry.<span class="title function_">push</span>( prev+t.<span class="property">length</span>+next.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">return</span> prev+t.<span class="property">length</span>+next.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;n,iAry&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abcaaaaaabcabcabcabbbabcb&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">get</span>(a, <span class="string">&#x27;abc&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//方案二：replace方法匹配，参数：[匹配到的整个串，分组，分组...，匹配到整个串的开始索引]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params">str,t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(t,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> iAry = [];</span><br><span class="line">    str.<span class="title function_">replace</span>(reg,<span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        iAry.<span class="title function_">push</span>(args[<span class="number">1</span>])</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;i,iAry&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abcaaaaaabcabcabcabbbabcb&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">get</span>(a, <span class="string">&#x27;abc&#x27;</span>));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>11.Function instanceof Object （阿里，头条）<br>   Object instanceof Function</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Function instanceof Object 返回true。</span><br><span class="line"> 原理：Function 是一个类同时也是一个函数，是Function类的一个实例;</span><br><span class="line"> Function instanceof Function 是true。</span><br><span class="line"> Function.__proto__ == Function.prototype；</span><br><span class="line"> 而Function.prototype.__proto__ 是Object.prototype；</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Object instanceof Function 返回true；</span><br><span class="line">原理：Object是一个类也是一个函数，所以是Function的一个实例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>12.用二分查找递归方法，插入一个值并返回索引；有序数组[1,2,3,5,7,8],插入4，返回索引3；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">   <span class="comment">//非递归,遍历找到第一个出现大于他的值，然后记住索引，向他前面插入进去。如果没找到，则直接push进去</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">ary,n</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> index;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ;i&lt;ary.<span class="property">length</span>;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(ary[i]&gt;n)&#123;</span><br><span class="line">              index = i;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(i&gt;=ary.<span class="property">length</span>)&#123;</span><br><span class="line">          ary.<span class="title function_">push</span>(n)</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          ary.<span class="title function_">splice</span>(index,<span class="number">0</span>,n)</span><br><span class="line">          <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">insert</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">arr,n</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> l = [];</span><br><span class="line">            <span class="keyword">var</span> r = [];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]&lt;n)&#123;</span><br><span class="line">                    l.<span class="title function_">push</span>(arr[i])</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r.<span class="title function_">push</span>(arr[i])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">index</span>:l.<span class="property">length</span>,</span><br><span class="line">                <span class="attr">ary</span>:l.<span class="title function_">concat</span>([n]).<span class="title function_">concat</span>(r)</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分插入，递归。</span></span><br><span class="line"><span class="comment">//思路：二分，用左侧最后一项进行比较，如果比插值大，说明应该插入到左侧数组中；</span></span><br><span class="line"><span class="comment">//    递归,继续二分记性比较。</span></span><br><span class="line"><span class="comment">//递归出口：当数组中只有一项时，就可以进行比较，就知道插入到哪了。</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">ary,num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ary.<span class="property">length</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ary[<span class="number">0</span>]&gt;num)&#123;</span><br><span class="line">            ary.<span class="title function_">unshift</span>(num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ary.<span class="title function_">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>(ary.<span class="property">length</span>/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> l = ary.<span class="title function_">slice</span>(<span class="number">0</span>,m);</span><br><span class="line">    <span class="keyword">let</span> r = ary.<span class="title function_">slice</span>(m);</span><br><span class="line">    <span class="keyword">if</span>(l[l.<span class="property">length</span>-<span class="number">1</span>]&gt;num)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">insert</span>(l,num).<span class="title function_">concat</span>(r)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="title function_">concat</span>(<span class="title function_">insert</span>(r,num))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">insert</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">34</span>,<span class="number">48</span>,<span class="number">68</span>], <span class="number">34</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>13.计算出数组的最大差值 <a href="%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">12,5,11,7,33,9</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">adjective</span>(<span class="params">arr</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(...arr);</span><br><span class="line"> <span class="keyword">let</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(...arr);</span><br><span class="line"> <span class="keyword">return</span> max - min </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">adjective</span>(<span class="params">arr</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> min = arr[<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">let</span> max = arr[<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr[i]&lt;=min)&#123;</span><br><span class="line">         min = arr[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(arr[i]&gt;=max)&#123;</span><br><span class="line">         max = arr[i]</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> max - min ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">     arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b)</span><br><span class="line">     <span class="keyword">return</span> arr[arr.<span class="property">length</span>-<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>14.请写出检查元素是否在屏幕可视区域的关键代码；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图片懒加载的原理：</span><br><span class="line">方案一：1.获取图片 距离 滑动内容盒子 顶部的offsetTop</span><br><span class="line">      （需要给滑动内容盒子增加position:relative属性，使他成为父级参照物）</span><br><span class="line">        offsetParent:父级参照物</span><br><span class="line">        第一个具有position属性且非static的父级，没有的话，最终是body</span><br><span class="line">        一般情况下页面中所有元素的父级参照物都是body;</span><br><span class="line">        document.body.offsetParent =&gt;null//body 的父级参照物是null）</span><br><span class="line">       2.获取滚动窗口的scrollTop值。</span><br><span class="line">       3.获取滚动窗口的clientHeight值。</span><br><span class="line">       </span><br><span class="line">       监听滚动事件：当clientHeight+scrollTop &gt;=offsetTop时，则进入了窗口。</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">方案二:dom.getBoundingClientRect()是获取某个元素相对于视窗的位置集合;</span><br><span class="line">      &#123;top,left,right,bottom&#125;，四个值都是距离左边或者顶部的距离。</span><br><span class="line">      1.通过getBoundingclientRect().top,获取当前原理距离视窗顶部的距离</span><br><span class="line">      2.获取可视窗的高度document.body.clientHeight。</span><br><span class="line">      3.当元素距离视窗顶部距离 &lt; 视窗高度，则出现在视窗内</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<p>15.将片段1 用正则表达式替换成片段2 （boss直聘）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">片段1 &lt;h1  class=&quot;h4&quot;&gt;&lt;span class=&quot;label&quot;&gt;boss直聘&lt;/span&gt;&lt;h1&gt;</span><br><span class="line"></span><br><span class="line">片段2 &lt;h1  class=\&quot;h4\&quot;&gt;&lt;span class=\&quot;label\&quot;&gt;boss直聘&lt;/span&gt;&lt;h1&gt;</span><br><span class="line">    function replaceStr(str) &#123;</span><br><span class="line">        let result = str.replace(/&quot;/g,function(...args) &#123;</span><br><span class="line">          return &quot;/&quot;+args[0]</span><br><span class="line">        &#125;)  </span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>16.计算”abcadadacvabc”中出现最多的字符？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//预设一个最大次数，利用对象存储次数 key是字符，value是次数；每次遍历都与最大次数进行比较；</span><br><span class="line">function fn(str)&#123;</span><br><span class="line">    let max;</span><br><span class="line">    let maxNum = 0 ;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    let ary = str.split(&#x27;&#x27;);</span><br><span class="line">    for(let i = 0 ; i&lt;ary.length;i++)&#123;</span><br><span class="line">        if(obj[ary[i]])&#123;</span><br><span class="line">            obj[ary[i]] =  obj[ary[i]] +1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            obj[ary[i]] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if( obj[ary[i]] &gt; maxNum)&#123;</span><br><span class="line">            maxNum = obj[ary[i]];</span><br><span class="line">            max = ary[i]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return `次数$&#123;maxNum&#125; 字符$&#123;max&#125;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>17.输入a&#x3D;2 b&#x3D;3 ,输出a&#x3D;3,b&#x3D;2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function fn(a,b)&#123;</span><br><span class="line">    var temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    return &#123;</span><br><span class="line">        a,</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn(a,b)&#123;</span><br><span class="line">    a = a+b;</span><br><span class="line">    b = a-b;</span><br><span class="line">    a = a-b;</span><br><span class="line">    console.log(a,b)</span><br><span class="line">&#125;</span><br><span class="line">function fn(a,b)&#123;</span><br><span class="line">    a = a -b;</span><br><span class="line">    b = a+b;</span><br><span class="line">    a = b-a;</span><br><span class="line">    return &#123;a,b&#125;</span><br><span class="line">&#125;</span><br><span class="line">function fn(a,b)&#123;</span><br><span class="line">  [b,a] = [a,b]</span><br><span class="line">  return &#123;a,b&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>18.找出整形数组中乘积最大的三位数 [-10,7,29,30,5,-10,-70]</p>
<p>思路：先排序由大到小排序，取前三位的乘机 和 末尾两位 * 首位的乘机进行比较。<br>   末尾两位可能是 负负得正，所以才要和前三位进行比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function get1(ary)&#123;</span><br><span class="line">    ary.sort((a,b)=&gt;b-a);</span><br><span class="line">    let sum = 1;</span><br><span class="line">    for(let i = 0;i&lt;3;i++)&#123;</span><br><span class="line">        sum = sum * ary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    let sum2 = 1;</span><br><span class="line">    if(ary.length&gt;3)&#123;</span><br><span class="line">        sum2 = ary[ary.length-2]*ary[ary.length-1]*ary[0]</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum&gt;sum2)&#123;</span><br><span class="line">        return ary.slice(0,3)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return ary.slice(0,1).concat(ary.slice(ary.length-2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>19.假设有n级台阶，每次最多允许跨m步（m&lt;&#x3D;n）,那么有多少种跨越方式？<br><a href="https://segmentfault.com/a/1190000010486342">该题解析</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思路：采用自顶向下的思考方式</span><br><span class="line">f(n,m) = f(n-1,m)+f(n-2,m)+...+f(n-m,m)</span><br><span class="line">当m=2时，这就是一个斐波那契数列。</span><br><span class="line">同时，对于n阶变态跳，即n=m时，用公式有以下特点：</span><br><span class="line">f(n) = f(n-1)+f(n-2)+...+f(1);//①</span><br><span class="line">f(n-1) = f(n-2)+f(n-3)+...+f(1);//②</span><br><span class="line">①-② 即f(n) = 2f(n-1)，可以看出n阶变态跳的结果，实际是一个等比数列，也就是f(n) = 2^(n-1)</span><br><span class="line"></span><br><span class="line">function fn(n,m)&#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    if(n&lt;=0)&#123;</span><br><span class="line">        return 1; </span><br><span class="line">    &#125;</span><br><span class="line">    if(n&gt;=m)&#123;</span><br><span class="line">        for(let i =1 ;i&lt;=m;i++)&#123;</span><br><span class="line">            count += fn(n-i,m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        count +=fn(n,n)</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line"> &#125;</span><br><span class="line">//首先根据规律，存储前m项结果，当n&lt;m时，有f(n,m)=f(n,n)=f(n)=2^(n-1)</span><br><span class="line">//接下来我们依次计算n=m+1时的结果并存入数组</span><br><span class="line">//根据思路提示，第n项结果等于数组逆序前m项的和，我们截取数组迭代求和</span><br><span class="line">//最后返回顶层的数据，即是f(n,m)</span><br><span class="line">function f(n,m) &#123;</span><br><span class="line">    var arr = [1];</span><br><span class="line">    for (var i=1; i&lt;m;i++) &#123;</span><br><span class="line">        arr.push(Math.pow(2,i));</span><br><span class="line">    &#125;</span><br><span class="line">    for (var j=m+1; j&lt;=n; j++) &#123;</span><br><span class="line">        arr.push(arr.slice(-m).reduce((a,b) =&gt; a+b))</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//简单递归</span><br><span class="line">function fn(n)&#123;</span><br><span class="line">    if(n==1)return 1;</span><br><span class="line">    return fn(n-1) * 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>20.写一个函数</p>
<p>输入：{ a:{<br>         b:{<br>            c:{<br>                d:’h’,<br>                j:’l’,<br>                o:{<br>                   p:’q’,<br>                   r:”s”<br>                }<br>                t:’u’<br>            }<br>         },<br>         v:{<br>            w:{<br>                x:{<br>                    y:’z’<br>                }<br>            }<br>         }<br>      }<br>      e:{<br>        f:{<br>           i:k<br>        },<br>        m:’n’<br>      }<br>}</p>
<p>输出结果，按照层数，把同一层的属性放在同一个子数组内；<br>[[a,e],[b,v,f,m],[c,w,i],[d,j,o,t,x],[p,r,y]]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">思路:每递归一遍，脱一层。</span><br><span class="line">function setAry(obj,result) &#123;</span><br><span class="line">    let keys = Object.keys(obj);</span><br><span class="line">    if(keys.length == 0 )&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(keys);</span><br><span class="line">    let next = &#123;&#125;;</span><br><span class="line">    for(let key in obj)&#123;</span><br><span class="line">        if(typeof obj[key] == &#x27;object&#x27;)&#123;</span><br><span class="line">            Object.assign(next,obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setAry(next,result) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>21.有两个链表，如何判断两个链表有交叉？</p>
<h1 id="DOM相关"><a href="#DOM相关" class="headerlink" title="DOM相关"></a>DOM相关</h1><p>1.如何判断一个dom是否在视窗中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图片懒加载的原理：</span><br><span class="line">方案一：1.获取图片 距离 滑动内容盒子 顶部的offsetTop</span><br><span class="line">      （需要给滑动内容盒子增加position:relative属性，使他成为父级参照物）</span><br><span class="line">        offsetParent:父级参照物</span><br><span class="line">        第一个具有position属性且非static的父级，没有的话，最终是body</span><br><span class="line">        一般情况下页面中所有元素的父级参照物都是body;</span><br><span class="line">        document.body.offsetParent =&gt;null//body 的父级参照物是null）</span><br><span class="line">       2.获取滚动窗口的scrollTop值。</span><br><span class="line">       3.获取滚动窗口的clientHeight值。</span><br><span class="line">       </span><br><span class="line">       监听滚动事件：当clientHeight+scrollTop &gt;=offsetTop时，则进入了窗口。</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">方案二:dom.getBoundingClientRect()是获取某个元素相对于视窗的位置集合;</span><br><span class="line">      &#123;top,left,right,bottom&#125;，四个值都是距离左边或者顶部的距离。</span><br><span class="line">      1.通过getBoundingclientRect().top,获取当前原理距离视窗顶部的距离</span><br><span class="line">      2.获取可视窗的高度document.body.clientHeight。</span><br><span class="line">      3.当元素距离视窗顶部距离 &lt; 视窗高度，则出现在视窗内</span><br><span class="line">     </span><br></pre></td></tr></table></figure>


<p>2.dom事件中 DOMContentLoaded和window.onload的触发实际是什么 ？图片加载完成后是一个什么情况？（苏宁）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//DOMContentLoaded 事件是DOM元素全部加载完成之后就会触发，图片等其他信息加载之前调用</span></span><br><span class="line"><span class="comment">// 在Dom节点创建完成后执行，如果有多个定义，则触发后会依次执行。</span></span><br><span class="line"><span class="comment">// jquery:</span></span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;)</span><br><span class="line">$().<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//do something </span></span><br><span class="line">  <span class="comment">//jquery默认参数是document $()</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 以上三种方式都是jq提供的dom加载完成事件，都是基于DOMContentLoaded dom2级事件的。</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">// 此方法为原生js DOM加载完成执行的事件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//windown.onload</span></span><br><span class="line"><span class="comment">// 加载完所有页面内容才会触发，包括所有内容,包括图片，flash等所有文件.如果页面的这些内容很多会让用户等待很 长时间.</span></span><br><span class="line"><span class="comment">//只能定义一个，如果有多个定义则只执行最后一个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line"><span class="comment">// 比如：页面中只有一个img标签，当img节点创建完后就会执行$(function()&#123;&#125;)中的代码，</span></span><br><span class="line"><span class="comment">// 当img的src指定的图片完全加载完后才会触发window.onload事件。</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.原生js实现jq的after方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思路：获取当前元素的氟元素节点 parentNode</span><br><span class="line">     获取当前元素的下一个元素节点nextElementsibling（或者nextSilbling &amp; nodeType==1，递归找出）</span><br><span class="line">     parentNode.inserBefore(被插入元素,nextElementsibling)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="性能优化相关？"><a href="#性能优化相关？" class="headerlink" title="性能优化相关？"></a>性能优化相关？</h1><p>1.列举你能想到的前端性能问题和安全问题</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">安全问题：</span><br><span class="line">   a.xss攻击,就是攻击者想尽一切办法将可以执行的代码注入到网页中。</span><br><span class="line">    评论功能，写入脚本内容，入库了。 get参数后面拼接了key=脚本； 这种很被容易写进页面；</span><br><span class="line">   </span><br><span class="line">    防御：</span><br><span class="line">    转义字符：对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义</span><br><span class="line">            利用js-xss 将内容进行过滤，转义；</span><br><span class="line">    </span><br><span class="line">    csp:建立白名单，配置规则，高速浏览器哪些外部资源可以加载；</span><br><span class="line">    通常可以通过两种方式来开启 CSP：</span><br><span class="line">    设置 HTTP Header 中的 Content-Security-Policy</span><br><span class="line">    设置 meta 标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</span><br><span class="line">    </span><br><span class="line">       只允许加载本站资源</span><br><span class="line">       Content-Security-Policy: default-src ‘self’</span><br><span class="line">       只允许加载 HTTPS 协议图片</span><br><span class="line">       Content-Security-Policy: img-src https://*</span><br><span class="line">       允许加载任何来源框架</span><br><span class="line">       Content-Security-Policy: child-src &#x27;none&#x27;</span><br><span class="line">  b.  CSRF攻击？跨站点请求伪造如何防范</span><br><span class="line">      原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，</span><br><span class="line">      后端就以为是用户在操作，从而进行相应的逻辑。</span><br><span class="line">      </span><br><span class="line">      防御：请求时post附带验证信息，比如验证码或者 Token；</span><br><span class="line">           get请求不对数据进行修改</span><br><span class="line">           服务端验证referer</span><br><span class="line">           </span><br><span class="line">  c.点击劫持，攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击    </span><br><span class="line">      防御：当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。     </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">前端性能优化：（都问）</span><br><span class="line">  </span><br><span class="line">  前端代码的压缩 合并，减少http请求，和文件大小</span><br><span class="line">  图片处理设置最大边界，base64；雪碧图；</span><br><span class="line">  </span><br><span class="line">  少操作dom减少dom回流，或者创建文档碎片；</span><br><span class="line">  缓存dom节点，减少查找次数；</span><br><span class="line">  应用节流和防抖处理函数；比如说滚动发出请求；</span><br><span class="line">  </span><br><span class="line">  preload资源预加载属性；</span><br><span class="line">  图片懒加载；</span><br><span class="line">  静态资源放到cdn上；</span><br><span class="line">  离线存储:配置manifest配置应用程序缓存：CACHE MANIFEST，NETWORK，FALLBACK</span><br><span class="line">    优点//</span><br><span class="line">    离线浏览 - 用户可在应用离线时使用它们</span><br><span class="line">    速度 - 已缓存资源加载得更快</span><br><span class="line">    减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</span><br><span class="line">    // 更新缓存 </span><br><span class="line">    用户清空浏览器缓存</span><br><span class="line">    manifest 文件修改，可以配置一个版本号，</span><br><span class="line">    由程序来更新应用缓存</span><br><span class="line">    // 其他 //</span><br><span class="line">    站点离线存储的容量限制是5M</span><br><span class="line">  浏览器缓存机制；</span><br><span class="line">    楚楚推：图片max-age：24小时；</span><br><span class="line">            js css文件max-age：15分钟；</span><br><span class="line">            协商缓存；</span><br><span class="line">       </span><br><span class="line">  webpack性能优化：</span><br><span class="line">  有哪些方式可以减少 Webpack 的打包时间？</span><br><span class="line">    1.优化loader，通过exclude和include，优化loader的文件搜索范围；</span><br><span class="line">  module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          // js 文件才使用 babel</span><br><span class="line">          test: /\.js$/,</span><br><span class="line">          loader: &#x27;babel-loader&#x27;,</span><br><span class="line">          // 只在 src 文件夹下查找</span><br><span class="line">          include: [resolve(&#x27;src&#x27;)],</span><br><span class="line">          // 不会去查找的路径</span><br><span class="line">          exclude: /node_modules/</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  2.使用HappyPack插件；</span><br><span class="line">  受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</span><br><span class="line">  HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        include: [resolve(&#x27;src&#x27;)],</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        // id 后面的内容对应下面</span><br><span class="line">        loader: &#x27;happypack/loader?id=happybabel&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HappyPack(&#123;</span><br><span class="line">      id: &#x27;happybabel&#x27;,</span><br><span class="line">      loaders: [&#x27;babel-loader?cacheDirectory&#x27;],</span><br><span class="line">      // 开启 4 个线程</span><br><span class="line">      threads: 4</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  3.webpack.DllPlugin + webpack.DllReferencePlugin</span><br><span class="line">  DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本</span><br><span class="line">  才有需要重新打包，并且也实现了 将公共代码抽离成单独文件的优化方案。</span><br><span class="line">  4.resolve.extensions：用来表明文件后缀列表，默认查找顺序是 [&#x27;.js&#x27;, &#x27;.json&#x27;]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</span><br><span class="line">  5.resolve.alias：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  有哪些方式可以让 Webpack 打出来的包更小？</span><br><span class="line">  1.按需加载，</span><br><span class="line">  原理：当使用时候再去下载对应文件，返回一个promise；</span><br><span class="line">  2.代码压缩；uglifyJS-webpack-plugin    webpack-parallel-uglify-plyugin 并行压缩js</span><br><span class="line">  3.Tree Shaking可以实现删除项目中未被引用的代码，</span><br><span class="line">   // test.js</span><br><span class="line">   export const a = 1</span><br><span class="line">   export const b = 2</span><br><span class="line">   // index.js</span><br><span class="line">   import &#123; a &#125; from &#x27;./test.js&#x27;</span><br><span class="line">  test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中</span><br><span class="line">  </span><br><span class="line">  4 Scope Hoisting Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: true</span><br><span class="line">  &#125;</span><br><span class="line">   Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

 
</code></pre>
<p>2.项目优化方法</p>
<p>3.错误检测上报日志怎么实现的?</p>
<p>  &#x2F;&#x2F;a.通过onerror 捕获代码运行错误，捕获到错误信息后可以向目标服务器img发一个请求，get传递错误信息；<br>  window.onerror &#x3D; function(msg, url, line, col, error){</p>
<p>  }<br>  &#x2F;&#x2F;b.页面埋点，监听用户交互和pv&#x2F;uv，请求服务器进行上报</p>
<p>  &#x2F;&#x2F;c. performance.getEntriesByType(‘navigation’) 针对一些复杂页面，获取页面的性能相关信息，进行上报；</p>
<p>4.fis3 和 webpack的区别是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.入口，</span><br><span class="line">webpack是从entry出发，将依赖的文件提取编译打包，通过commonschunkplugin、dll等提取公共代码；</span><br><span class="line">   fis3 是以file对象为中心构建编译的，所有文件同等对待，都会去分析文件依赖关系，生成一个静态资源表，</span><br><span class="line">   资源表记录每个文件的依赖关系；</span><br><span class="line">   fis3可以针对每个文件做出相应的配置，更加细致；</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">b.fis3的配置文件，fis.match到某些文件，然后对这些文件定义各自的各个阶段的插件处理、发布规则,是针对文件进行匹配的;</span><br><span class="line"> webpack配置文件，entry、output、plugins、module、resolve;</span><br><span class="line"></span><br><span class="line">c.fis3能对任何文件使用hash控制，在引用它的任何地方的路径会被自动替换为hash路径。</span><br><span class="line"> </span><br><span class="line">d.fis3，由于独有的静态资源标记，导致npm生态不太好；</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.请列举最重要的前端优化点(按重要性)</p>
<p>6.：我们为什么一再强调将css放在头部，将js文件放在尾部</p>
<p><a href="https://www.cnblogs.com/caizhenbo/p/6679478.html">浏览器解析</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在面试的过程中，经常会有人在回答页面的优化中提到将js放到body标签底部，原因是因为浏览器生成Dom树的时候是一行一行读HTML代</span><br><span class="line">码的，script标签放在最后面就不会影响前面的页面的渲染。那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读</span><br><span class="line">完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。</span><br><span class="line">  </span><br><span class="line">我们再来看一下chrome在页面渲染过程中的，绿色标志线是First Paint的时间。纳尼，为什么会出现firstpaint，页面的paint</span><br><span class="line">不是在渲染树生成之后吗？其实现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前</span><br><span class="line">开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。</span><br><span class="line">假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在</span><br><span class="line">后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7.vue首屏加载很慢，怎么进行优化？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.组件异步加载;</span><br><span class="line">   局部注册异步组件(`import` 函数会返回一个 `Promise` 对象。)</span><br><span class="line">   new Vue(&#123;</span><br><span class="line">     // ...</span><br><span class="line">     components: &#123;</span><br><span class="line">       &#x27;my-component&#x27;: () =&gt; import(&#x27;./my-async-component&#x27;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   =&gt;</span><br><span class="line">   new Vue(&#123;</span><br><span class="line">        // ...</span><br><span class="line">        components: &#123;</span><br><span class="line">          &#x27;my-component&#x27;: Promise.resolve(&#123;...组件定义对象&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   全局注册异步组件</span><br><span class="line">   Vue.component(&quot;custom&quot;,() =&gt; import(&#x27;./my-async-component&#x27;))</span><br><span class="line">   =&gt;Vue.component(&quot;custom&quot;,Promise.resolve(&#123;...组件定义对象&#125;))</span><br><span class="line">   或者</span><br><span class="line">   </span><br><span class="line">    Vue.component(&#x27;async-example&#x27;, function (resolve, reject) &#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">        template: &#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">Vue.component(&#x27;async-webpack-example&#x27;, function (resolve) &#123;</span><br><span class="line">  // 这个特殊的 `require` 语法将会告诉 webpack</span><br><span class="line">  // 自动将你的构建代码切割成多个包，这些包</span><br><span class="line">  // 会通过 Ajax 请求加载</span><br><span class="line">  require([&#x27;./my-async-component&#x27;], resolve)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  2.路由懒加载+分组打包；</span><br><span class="line">  没有指定webpackChunkName，每个组件打包成一个js文件；</span><br><span class="line">  指定了相同的webpackChunkName，会合并打包成一个js文件。</span><br><span class="line">  const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#x27;./Foo.vue&#x27;)</span><br><span class="line">  const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#x27;./Bar.vue&#x27;)</span><br><span class="line">  const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#x27;./Baz.vue&#x27;)</span><br><span class="line">  const router = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">      &#123; path: &#x27;/foo&#x27;, </span><br><span class="line">        component: Foo，</span><br><span class="line">        children:[</span><br><span class="line">            &#123;path:&#x27;/bar&#x27;,component:Bar&#125;</span><br><span class="line">            &#123;path:&#x27;/baz&#x27;,component:Baz&#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  3.组织复杂页面的代码时，可以考虑对于打开首屏时不需要渲染的子组件，使用v-if控制其只在需要的时候被渲染。</span><br><span class="line">  </span><br><span class="line">  4.cdn加载外部的css js文件，浏览器并发请求加载。</span><br><span class="line">  </span><br><span class="line">  html直接引入外部的js 和css文件，比如vue vuex</span><br><span class="line">  </span><br><span class="line">  利用webpack的externals忽略打包文件；key是导入的键，value是项目中用到的变量</span><br><span class="line">   externals: &#123;</span><br><span class="line">      jquery: &#x27;jQuery&#x27; ,</span><br><span class="line">      vue:&#x27;Vue&#x27;</span><br><span class="line">      //将需要忽略打包的都写在这个里面，但前提是index.html文件里面必须script引入</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   使用：import $ from &#x27;jquery&#x27;，正常使用</span><br><span class="line">   5.开启gzip压缩支持</span><br><span class="line">   npm install compression-webpack-plugin —save-dev </span><br><span class="line">   将config/index.js 开启压缩</span><br><span class="line">       productionGzip: true,</span><br><span class="line">       productionGzipExtensions: [&#x27;js&#x27;, &#x27;css&#x27;],</span><br><span class="line">   </span><br><span class="line">   注：想要线上使用还需还得配置后端。</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   扩展常用webpak插件</span><br><span class="line">   copy-webpack-plugin ：复制文件到目标文件夹。在开发时使用热模替换，（没有生成dist 文件夹，都在内存中），如果想引用某一个js文件，直接写script标签是找不到的，因为服务器内存中没有这个文件。所以复制这个文件，到dist中。</span><br><span class="line">   compression-webpack-plugin： 生产环境时可选择让代码压缩gzip.</span><br><span class="line">   html-webpack-plugin : 生成index.html 并自动注入打包后的js css 等</span><br><span class="line">   webpack.DefinePlugin： 可以生成配置常量。编译时就有的常量。</span><br><span class="line">   extract-text-webpack-plugin： 提取使用文件的css 组成一个或多个css 文件。</span><br><span class="line">   webpack.optimize.CommonsChunkPlugin： 让多个出口文件组成一个文件</span><br><span class="line">   webpack-dev-server: 开发时使用，静态服务器，并且有热替换等功能。</span><br><span class="line">   uglifyjs-webpack-plugin： 删除警告，压缩代码等</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="扩展知识？能聊就行～"><a href="#扩展知识？能聊就行～" class="headerlink" title="扩展知识？能聊就行～"></a>扩展知识？能聊就行～</h1><p>1.简述CI&#x2F;CD？</p>
<p>2.多态和重载？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重载：相同函数名，不同参数，则认为是两个不同的函数；</span><br><span class="line">js没有函数重载，可以通过参数个数，参数类型，内部模仿重载；</span><br><span class="line"></span><br><span class="line">多态的实际含义是，对象的多种形态；同一操作，作用在不同的对象上面，可以产生不同的解释和不同的执行结果。</span><br><span class="line">javascript的变量类型在运行期是可变的，这就意味着javascript对象的多态性是与生俱来的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.了解服务端的反向代理吗？</p>
<p>4.订餐功能 如何实现的？<br>利用express框架搭建node服务，对前端提供api请求接口；<br>利用express-router + app.use 实现父子路由管理,实现用户订餐的增删改；<br>利用node-schedule 包实现定时任务，每天定时抓取用户订餐状态,生成订餐名单；每天定时清除，所有用户的 订餐状态；<br>利用nodemailer向行政发送 订餐人员名单;<br>let dinner &#x3D; express.Router();<br>dinner.get(‘&#x2F;list’,function(){</p>
<p>})</p>
<p>dinner.post(‘&#x2F;set’,function(){</p>
<p>})</p>
<p>dinner.post(‘&#x2F;delete’,function(){})</p>
<p>app.use(‘&#x2F;dinner’,dinner)</p>
<p>表结构：<br>主键：是用户id ，用工号代替；姓名；部门；订饭状态；<br>用户进入前端页面，post提交工号，然后将该同学的订饭状态改成订餐状态；</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>1.观察者模式 和 订阅发布模式的区别</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5262488-291da39f66dbc28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。</span></span><br><span class="line"><span class="comment">// 观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，会造成代码的冗余。而发布订阅模式则统一由调度中心处理，</span></span><br><span class="line"><span class="comment">// 消除了发布者和订阅者之间的依赖。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="程序执行题"><a href="#程序执行题" class="headerlink" title="程序执行题"></a>程序执行题</h1><p>1.代码执行结果（boss直聘）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;boss&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">age</span>);<span class="comment">//3</span></span><br><span class="line"><span class="title function_">observe</span>(data);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">age</span>);<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">data.<span class="property">age</span> = <span class="number">5</span>; <span class="comment">//val = 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">age</span>)<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(data,key,data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data,key,val</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data,key,&#123;</span><br><span class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> val +<span class="number">1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">            val = newVal+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.代码执行结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span>  res = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">value</span>  =&gt;</span>value%<span class="number">2</span>).<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span>item*item).<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">//35</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">pop</span>());<span class="comment">//6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.程序输出结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="params">_</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i])</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出6个undefined</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#node</p>
<p>1.express的设计思想？<br>路由控制<br>中间件<br>静态文件服务<br>模板解析</p>
<p>let app &#x3D; express();<br>app.get(‘’,(req,res,next)&#x3D;&gt;{</p>
<p>},(req,res,next)&#x3D;&gt;{}).post(‘’,(req,res.next)&#x3D;&gt;{</p>
<p>})</p>
<p>app.use(‘’,(req,res,next)&#x3D;&gt;{</p>
<p>})</p>
<p>let user &#x3D;  express.Router();<br>user.use(‘&#x2F;login’,(req,res,next)&#x3D;&gt;{</p>
<p>})</p>
<p>user.get(‘’,(req,res)&#x3D;&gt;{</p>
<p>})<br>app.use(‘&#x2F;user’,user)</p>
<p>设计思想<br>1.路由：二维数组的二维数据形式<br>[[cb,cb,cb],[cb,cb,cb],[cb,cb,cb],[usecb,usecb,usecb]]<br>最外层是Router，[cb,cb,cb] 表示的route，cb指的是每个route中的回调；[usecb,usecb,usecb]表示中间件的回调；</p>
<p>2.路由服务<br>express.router()，创建路由，在利用app.use中间件，形成父子级别中间路由；<br>express.router返回的一个router函数，router函数复用了app的一些方法,<br>也同样具备handler&#x2F;post&#x2F;get&#x2F;use等方法；这样就利用方法复用，实现了一层一层的套用；</p>
<p>3.静态资源服务，调用node原生利用 http服务起的服务；</p>
<p>2.express和koa的区别？（阿里）</p>
<p>express 自带路由控制，express-router ;koa 需要单独引入<br>express 基于回调函数，koa是基于generator思想的；koa是不会出现回调地狱的；</p>
<p>3.node 思想？</p>
<p>特点：<br>线程是单线程异步。通过callback实现异步。<br>非阻塞、异步I&#x2F;o，能用异步 绝不同步<br>event-driven事件驱动-发布订阅模式</p>
<p>思想：基于事件驱动，异步io，通过callback实现异步<br>     commonjs模块化，一个js就是一个模块；</p>
<p>自由回答题：<br>在一个异世界里，老虎可以吃羊，也可以吃草，并且羊比草好吃。但是吃了羊就会变成羊。假设现在有100只老虎和1只羊，且所有老虎都非常理性，那么最终会剩下多少老虎和多少羊？（头条）</p>
]]></content>
  </entry>
  <entry>
    <title>Mac安装Redis5.0.8</title>
    <url>/2020/05/16/Mac%E5%AE%89%E8%A3%85Redis5-0-8/</url>
    <content><![CDATA[<p>在用SpeingBoot做邮箱验证的时候，需要用到<code>Redis</code>，所以在Mac和CentOs中都安装了<code>redis5.0.8</code>：</p>
<span id="more"></span>

<h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h4><p>redis<a href="https://redis.io/">下载地址</a>，选择download，然后可以看到5.0.8的安装包：</p>
<p><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020-05-16-045020.png" alt="Screen Shot 2020-05-16 at 12.49.14"></p>
<p>或者，可以通过wget安装<code>wget http://download.redis.io/releases/redis-5.0.8.tar.gz</code></p>
<h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h4><ul>
<li><p>解压到安装目录<code>tar zxvf redis-5.0.8.tar.gz /usr/local</code></p>
<blockquote>
<p>注意，如果没有权限请加上sudo</p>
</blockquote>
</li>
<li><p>切换到解压好的目录<code>cd /usr/local/redis-5.0.8</code>，执行make命令，大概两分钟后安装完成</p>
</li>
<li><p>执行<code>make install</code>，作用是在<code>/usr/local/bi</code>n里产生一些文件(命令)，比如<code>redis-server</code>、<code>redis-cli</code>等，如果不执行make install，那么键入启动服务命令redis-server时会提示“该命令不存在”，redis服务就无法启动。我们查看一下：</p>
<p><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020-05-16-045716.png" alt="image-20200516125715391"></p>
</li>
</ul>
<h4 id="3-修改配置文件redis-conf"><a href="#3-修改配置文件redis-conf" class="headerlink" title="3. 修改配置文件redis.conf"></a>3. 修改配置文件redis.conf</h4><p>修改redis.conf，将GENERAL里的no改成yes（默认redis.conf里守护进程没有被开启）</p>
<p>(注：这个配置文件可能在 &#x2F;usr&#x2F;redis&#x2F;redis-5.0.8&#x2F;redis.conf，或者&#x2F;etc&#x2F;redis.conf)</p>
<p><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020-05-16-045936.png" alt="image-20200516125936103"></p>
<h4 id="4-启动服务"><a href="#4-启动服务" class="headerlink" title="4. 启动服务"></a>4. 启动服务</h4><p>执行<code>to redis-server /usr/local/redis-5.0.8/redis.conf</code>加载配置文件，可以在bash配置文件里重命名一下，<code>alias redis=&#39;redis-server /usr/local/redis-5.0.8/redis.conf&#39;</code>，查看结果：配置文件已经加载；</p>
<p><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020-05-16-050301.png" alt="image-20200516130301891"></p>
<p>加载配置文件后，启动客户端<code>redis-cli</code> </p>
<p>退出的话先执行shutdown再exit即可</p>
<h4 id="5-uer-local权限问题"><a href="#5-uer-local权限问题" class="headerlink" title="5. &#x2F;uer&#x2F;local权限问题"></a>5. &#x2F;uer&#x2F;local权限问题</h4><p>默认安装以后，在Mac系统中就算是sudo用户也没有访问redis权限，退出的时候提示没有权限保存<code>saving: Permission denied</code>，手动修改一下文件夹权限<code>sudo chown -R $(whoami) /usr/local/redis-5.0.8</code>，👌</p>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu16.04.4安装与优化</title>
    <url>/2020/02/15/Ubuntu16-04-4%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>由于我的 <strong>acer</strong> 不争气，好不容易装好的系统，关机以后自检找不到系统了，所以这篇文章暂时搁置，等我有了一台能顺利跑Ubuntu的电脑再来填坑。</p>
<span id="more"></span>
<h3 id="没错，这篇文章就是被搁置了。-2020-02-16"><a href="#没错，这篇文章就是被搁置了。-2020-02-16" class="headerlink" title="没错，这篇文章就是被搁置了。   2020-02-16"></a>没错，这篇文章就是被搁置了。   2020-02-16</h3><p>随手放一些效果图，很Mac有没有？<br><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020-02-16%2F%E6%A1%8C%E9%9D%A2%E6%95%88%E6%9E%9C.png"></p>
<center>桌面效果图</center>

<p>下载主题包，链接:<a href="https://pan.baidu.com/s/1Y9DMaPc5JQ47TzVue7RvIQ">https://pan.baidu.com/s/1Y9DMaPc5JQ47TzVue7RvIQ</a>  密码:a9ne,根据文档内容放入对应文件夹</p>
<blockquote>
<p>安装gnome-tweak-tool,然后打开tweak工具，  </p>
</blockquote>
<p><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020-02-16%2F%E4%B8%BB%E9%A2%98.jpg"></p>
<p>在安装Ubuntu的过程中，发现我的老电脑不堪重负，崩了。。。。<br>打算组装一台itx主机来装Linux</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/05/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上常用的软件&amp;插件</title>
    <url>/2019/09/24/mac%E8%BD%AF%E4%BB%B6%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>前几天忍不住升级了Catalina beat 10.15版，后来ruby环境崩溃，Final cut pro、iMovie也用不了，苦不堪言，最终在没有备份的前提下降级到Mojave……正好从头折腾一下Mac电脑，顺便整理一下这几年常用的软件和插件。</p>
<span id="more"></span>
<ol>
<li><p>Alfred<br><img src="http://gray.oss-cn-beijing.aliyuncs.com/2019-09-25%2F1569418838.png"><center>我的一些工作流</center><br>很有名气的一款软件，实现很多workflow功能，在刚开始使用Mac时候就装上了，用的最多的还是双击<code>option</code>查单词，方便快捷，最近找到了开源的阿里云oss图床<a href="https://github.com/CQHui/oss_upload">oss_upload</a>,在码字时候一键上传图片生成markdown连接，所见即所得。另外，还有调用istats查看电脑cpu温度和风扇速度：<img src="http://gray.oss-cn-beijing.aliyuncs.com/2019-09-25%2F1569419344.png"><center>查看cpu温度</center></p>
</li>
<li><p>Keybord Maestro<br>Mac上窗口管理的软件非常多，例如非常有名的Magent，但是，这些软件都只有窗口管理一个功能，而且不如KM灵活。下面是我自己的配置，分别是居中、全屏、左上、右上、左下、右下几个位置，对应的快捷键可以自己设置，比如我的“居中”就是<strong>Command+Control+H</strong>：<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ntkgz4dtj318u0u0jwh.jpg" alt="我的配置" title="配置">简单几步配置，就会爱不释手。<br>另外，它还提供一个我非常喜欢的功能，用同一个快捷键呼出&#x2F;隐藏一个窗口，具体操作也很简单，新建一个Macro，动作选择第一个activate a specific Application,然后简单配置一下就ok。<img src="http://gray.oss-cn-beijing.aliyuncs.com/2019-09-25%2F1569419642.png"></p>
</li>
<li><p>qlimagesize<br>这也是一个开源项目，<a href="https://github.com/Nyx0uf/qlImageSize">qlimagesize</a>,强化mac一指弹——空格键查看时候显示图片分辨率、大小等信息；<img src="http://gray.oss-cn-beijing.aliyuncs.com/2019/09/25/15694199196130.jpg?image/auto-orient,1/resize,p_89/quality,q_90"><br>10月11日更新：升级Catalina10.15后，由于签名(行话叫做 Notarize)失效，quicklook插件都不能正常使用了。尝试在GitHub上找到答案，看<a href="https://github.com/whomwah/qlstephen/issues/81">这里</a>，截止目前，仍然没有明确的解决办法。</p>
</li>
<li><p>iterm2<br>  这绝对是我的最爱了，一款terminal软件，记得打开快捷键，一键呼出，一键隐藏！</p>
</li>
</ol>
<p>  <a href="https://blog.csdn.net/qq_39123009/article/details/107405179">Iterm2美化教程</a></p>
<ol>
<li><p>sublime text3<br>  感觉是mac断看代码最舒服的软件了，插件多多，慢慢跟新。</p>
</li>
<li><p>MWeb<br>  现在正用这款软件码字呢……</p>
</li>
<li><p>redder4<br>  rss阅读器，全iOS平台，mac上大屏超爽！</p>
</li>
<li><p>chrome<br>  emmm……这个不必多说，已经离不开了。</p>
</li>
<li><p>Evernote<br>  以前淘宝买了很多年的会员，全平台，第二大脑，就是不常去复习……</p>
</li>
<li><p>bartender3<br>  状态栏管理软件，当你看到左上角乱糟糟的状态栏的时候，自然而然就会想到它啦！</p>
</li>
<li><p>Mos<br><a href="https://github.com/Caldis/Mos">Mos</a>,开源，一个用于在MacOS上平滑你的鼠标滚动效果的小工具, 让你的滚轮爽如触控板，mac连接屏幕用到鼠标的时候就知道它有多棒啦😂</p>
</li>
<li><p>LyricsX<br>开源，上架mac AppStore，动态显示iTunes歌词，亲测支持Catalina……</p>
</li>
<li><p>ToothFairy<br>一款快速连接，断开蓝牙的状态栏小工具，搭配AirPods使用，效果杠杠的。</p>
</li>
</ol>
<p>暂且整理这几个，慢慢填坑。</p>
<hr>
<h5 id="10-7更新："><a href="#10-7更新：" class="headerlink" title="10-7更新："></a>10-7更新：</h5><ol>
<li><a href="https://github.com/alin23/Lunar">Lunar</a>：连接上外接显示器后，调节显示器亮度。开源。</li>
</ol>
<hr>
<h5 id="2019-2-11更新："><a href="#2019-2-11更新：" class="headerlink" title="2019-2-11更新："></a>2019-2-11更新：</h5><ol>
<li><a href="https://www.clipber.com/#download_app">快贴</a> 打通Mac和Windows的剪贴板壁垒，全平台。</li>
</ol>
<hr>
<h5 id="2020-10-17-更新"><a href="#2020-10-17-更新" class="headerlink" title="2020-10-17 更新"></a>2020-10-17 更新</h5><p>换了新的电脑，正好再次整理一波！</p>
<ol>
<li>调整Launchpad</li>
</ol>
<p>图标大小，这样看起来更加好看,在Terminal下执行一下命令：</p>
<ul>
<li><p>每一列现实图标个数：<code>defaults write com.apple.dock springboard-columns -int 10</code></p>
</li>
<li><p>每一行显示图标个数：<code>defaults write com.apple.dock springboard-rows -int 8</code></p>
</li>
<li><p>重制Launchpad：<code>defaults write com.apple.dock ResetLaunchPad -bool TRUE</code></p>
</li>
<li><p>重启Dock<code>killall Dock</code></p>
</li>
</ul>
<p><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020-10/2020-10-18-%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94%E5%9B%BE2.png" alt="前后对比图2"></p>
<p>恢复默认设置</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-rows Default</span><br><span class="line"></span><br><span class="line">defaults write com.apple.dock springboard-columns Default</span><br><span class="line"></span><br><span class="line">defaults write com.apple.dock ResetLaunchPad -bool TRUE</span><br><span class="line"></span><br><span class="line">killall Dock</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>打开Finder路径显示</li>
</ol>
<blockquote>
<p>显示当前路径，方便复制路径。</p>
</blockquote>
<p><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020-10/2020-10-18-%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt="前后对比图"></p>
<ol start="3">
<li>其他</li>
</ol>
]]></content>
      <tags>
        <tag>Macos</tag>
      </tags>
  </entry>
  <entry>
    <title>小米路由器青春版刷Padavan固件</title>
    <url>/2019/01/26/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E9%9D%92%E6%98%A5%E7%89%88%E5%88%B7Padavan%E5%9B%BA%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>刷机是一种乐趣，大学宿舍晚上断电，正好手上有一个<strong>小米路由器青春版</strong>，USB充电宝供电，巴掌大小，放在宿舍简直合适不过了。最最最厉害的是可以刷潘多拉固件，简直不要太好！<br>（这篇文章是以前Wordpress上写的，后来荒废了，但是这篇文章留在了MWeb的文件夹里，<strong>感谢MarkDown！</strong>）</p>
</blockquote>
<span id="more"></span>


<h2 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h2><ul>
<li>小米路由器青春版 *1</li>
<li>网线 *1</li>
<li>电脑(Mac 或 Windows) *1</li>
<li>刷机所需的固件，软件（Putty和WINSCP自行百度下载）</li>
</ul>
<hr>
<h2 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h2><blockquote>
<ol>
<li>首先确保路由器ROM版本为2.0，如果不是，降级到2.0或刷入开发版miwifi_r1cl_all_59371_2.1.26.bin版本(<a href="http://bigota.miwifi.com/xiaoqiang/rom/r1cl/miwifi_r1cl_all_59371_2.1.26.bin">点击下载</a>这个开发版）</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>修改网页地址的方式来篡改web管理密码和root密码</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>使用telnet命令进去备份各个分区(非必须)</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>刷入breed</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>刷入固件（潘多拉或梅林）</li>
</ol>
</blockquote>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><ol>
<li><p>小米路由器青春版是没有官方通道开启ssh的，其它版本路由器可以在<a href="http://www1.miwifi.com/miwifi_open.html">miwifi开放平台</a>查看。<br>在网友的帖子里，我们可以直接修改路由器的请求地址的特定参数，改变系统参数，从而开启ssh。</p>
<blockquote>
<p>首先确保路由器ROM版本为2.0，如果不是，降级到2.0或刷入开发版miwifi_r1cl_all_59371_2.1.26.bin版本(<a href="http://bigota.miwifi.com/xiaoqiang/rom/r1cl/miwifi_r1cl_all_59371_2.1.26.bin">点击下载</a>这个开发版）<br>降级方法：由官方的路由管理界面，上传本ROM包，自动升级即可</p>
</blockquote>
</li>
<li><p>在浏览器地址栏输入192.168.31.1，输入管理员密码（如果忘记了的话按住路由器的reset键10s以上重置系统，设置账户密码再做上面的操作），地址栏会多出一部分参数，比如我的是：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.31.1/cgi-bin/luci/;stok=6bb3936a88b4df625ded00d17be3911a/web/home#router</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>更改管理员密码和root密码<br>将上面的地址中的 <strong>&#x2F;web&#x2F;home#router</strong> 改为 <strong>&#x2F;api&#x2F;xqsystem&#x2F;set_name_password?oldPwd&#x3D;旧密码&amp;newPwd&#x3D;新密码</strong>  ，然后确定，看网页的返回值，如果是**{“code”:0}**就表示修改成功，可以接着下一步。</p>
</li>
<li><p>把 <strong>&#x2F;web&#x2F;home#router</strong> 改为 <strong>&#x2F;api&#x2F;xqnetwork&#x2F;set_wifi_ap?ssid&#x3D;xiaomi&amp;encryption&#x3D;NONE&amp;enctype&#x3D;NONE&amp;channel&#x3D;1%3B%2Fusr%2Fsbin%2Ftelnetd</strong> ，然后查看返回的JSON数据 <strong>{“msg”:”未能连接到指定WiFi(Probe timeout)”,”code”:1616}</strong> ，就可以用telnet方式登录路由器。</p>
</li>
<li><p>用telnet方式登录路由器<br>下载一个Putty 。然后打开选填以下参数，连接类型：telnet;主机名称：192.168.31.1.点击连接。可以看到看到login，账户输入root，密码则为以上第二步中修改的新密码。然后依次执行下面的三条指令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &quot;:x;N;s/if \[.*\; then\n.*return 0\n.*fi/#tb/;b x&quot; /etc/init.d/dropbear </span><br><span class="line">   /etc/init.d/dropbear start </span><br><span class="line">   nvram set ssh_en=1; nvram commit  </span><br></pre></td></tr></table></figure>
<p>此时我们已经开放ssh，可以用ssh方式登录路由器了。</p>
<ol start="6">
<li>刷入breed<br>WINSCP 选择SCP协议 复制breed.bin 到&#x2F;tmp<br>输入以下命令刷入，刷入后，机器会自动重启：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mtd -r write /tmp/breed.bin Bootloader</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><p>进入breed控制台<br>先给路由器断电，再按住路由器reset键，再给路由器送电，等到路由器灯闪的时候，松开reset键，用一根网线将路由器的WAN口和电脑相连，在电脑上在浏览器中输入192.168.1.1，进入breed控制台了。</p>
</li>
<li><p>刷入固件<br>可供选择的固件还是很多的，在这里我找了一个<a href="http://www.right.com.cn/forum/thread-161324-1-1.html">padavan</a>,这固件是从Padavan固件源码搬运源码汉化后编译出来的。选择<a href="http://opt.cn2qq.com/padavan/">MI-NANO_3.4.3.9-099.trx</a>这个版本，青春版专供直接在控制台选择上固件，然后点击更新，等待路由器自动重启，万事大吉！</p>
</li>
<li><p>修改灯光颜色<br>开机灯颜色蓝色橙色混合<br>使用下面的命令关闭橙色灯变成纯正蓝色</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mtk_gpio -d 44 0</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>管理路由器<br>刷入成功后，默认创建了名字为PCDN的无线网络，默认的密码为1234567890<br>后台网址为192.168.123.1，账号密码都为admin。（登录后可自行修改）<br>另外，可以配置ss，开启广告屏蔽插件等操做。</li>
</ol>
<p>参考文章：<br><a href="https://blog.csdn.net/qq_29109181/article/details/77727328">小米路由器青春版刷Padavan固件</a><br><a href="https://blog.csdn.net/qq_19666821/article/details/69948930">小米路由器青春版刷潘多拉、华硕固件</a><br><a href="https://www.b612.me/code/80.html">小米路由器青春版开启SSH刷入Padavan固件</a><br><a href="http://right.com.cn/forum/thread-196864-1-1.html">小米路由器青春版刷Padavan以及修改灯光颜色</a></p>
]]></content>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode教程</title>
    <url>/2020/02/13/VsCode%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/5e440fd4e51d4527271e8b79">https://juejin.im/post/5e440fd4e51d4527271e8b79</a></p>
<p>##VsCode安装</p>
<ol>
<li>进入<a href="https://code.visualstudio.com/">官网</a></li>
<li>点击首页的蓝色按钮下载对应系统安装包并安装</li>
</ol>
<p>##相关设置</p>
<ol>
<li>可以点击上部菜单栏中的文件 —&gt; 首选项 —-&gt; 设置  设置一些软件的自带功能比如   自动保存  折行方式 等等</li>
<li>自动保存 在设置的第一个就是选择 onFocusChange</li>
<li>折行方式直接搜索 折行即可 选择 on</li>
<li>切换颜色主题，点击文件—-首选项—-颜色主题  就可以选择不同的颜色主题了</li>
<li>一般我们是把我们的大的文件夹放到 vscode 内当作工作区，方便管理</li>
</ol>
<p>##插件</p>
<ol>
<li>打开软件，看到的是欢迎页，找到页面右侧的蓝色 sublime 点击安装 sublime快捷键，会弹出两个窗口选择 yes 和 ok</li>
<li>页面全是英文的安装插件，点击软件最左侧的第五个菜单，在搜索栏搜索 chinese 选择简体中文点击 install 安装即可，会提示你重启软件重启之后软件就汉化了。</li>
<li>.安装在浏览器中打开插件，插件搜索栏搜索 open in browser，安装即可</li>
<li>.安装路径自动补齐插件，插件搜索栏搜索 path，安装即可，使用方式先加引号然后使用 .&#x2F;    .&#x2F;代表当前</li>
<li>安装 小图标插件，插件搜索栏搜索 vscode-icons，安装即可，会弹出一个小窗口让你选择图标主题选择刚才安装好的即可</li>
</ol>
<p>setting sync <a href="https://www.cnblogs.com/zzhaolei/p/12028241.html">插件的使用</a></p>
]]></content>
  </entry>
  <entry>
    <title>对【计算机】的新理解</title>
    <url>/2021/01/17/%E5%AF%B9%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%91%E7%9A%84%E6%96%B0%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>开端</p>
</blockquote>
<p>工作有一段时间了，前几天去了产线，对计算机与工业的结合有了新的感悟。</p>
 <span id="more"></span>

<p>​	当我看到自己参与写的代码跑在服务器上，帮助产线上的工作人员协同生产的时候，那种震撼，是难以忘怀的。</p>
<p>这种刺激比书本上什么“解放生产力、科技革命”之流的文字描述真实太多了。现在，突然有了一种豁然开朗的感觉，原来，这就是计算机与工业的结合。</p>
<p>也就先写这么几句吧吗，突然发现我变得不太会说话了呢😪</p>
]]></content>
  </entry>
  <entry>
    <title>用Mweb发布Hexo博客</title>
    <url>/2019/04/10/test/</url>
    <content><![CDATA[<h2 id="测试一下七牛云图床功能"><a href="#测试一下七牛云图床功能" class="headerlink" title="测试一下七牛云图床功能"></a>测试一下七牛云图床功能</h2><p><img src="http://grayblog.cn.qiniudns.com/mweb/gray.png" alt="gray"></p>
<h2 id="测试阿里云图床功能"><a href="#测试阿里云图床功能" class="headerlink" title="测试阿里云图床功能"></a>测试阿里云图床功能</h2><p><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020/07/18/15950596523920.jpg?image/auto-orient,1/resize,p_89/quality,q_90"><br>能够正常上传图片</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Mac中Terminal无法访问github</title>
    <url>/2020/07/18/%E8%A7%A3%E5%86%B3Mac%E4%B8%ADTerminal%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEgithub/</url>
    <content><![CDATA[<p> 在Terminal中，<code>git clone</code> 和 <code>git push</code>无法使用，ping了一下github，发现连接不通，但是Chrome中却能打开，在此记录一下解决的办法。<br> <span id="more"></span></p>
<h3 id="通过ping命令查看当前的github的ip地址"><a href="#通过ping命令查看当前的github的ip地址" class="headerlink" title="通过ping命令查看当前的github的ip地址"></a>通过ping命令查看当前的github的ip地址</h3><p> <img src="http://gray.oss-cn-beijing.aliyuncs.com/2020/07/18/15950551780422.jpg?image/auto-orient,1/resize,p_89/quality,q_90"></p>
<p> 如图： 可以看到地址为13.250.177.223，这是ping不通的</p>
<h3 id="查看自己的hosts文件"><a href="#查看自己的hosts文件" class="headerlink" title="查看自己的hosts文件"></a>查看自己的hosts文件</h3><p>通过<code>cat /etc/hosts</code>命令查看host文件，查找是否有github相关的映射，比如我的映射关系就是13.250.177.223，如果没有，看下一步。</p>
<h3 id="获取github的ip地址"><a href="#获取github的ip地址" class="headerlink" title="获取github的ip地址"></a>获取github的ip地址</h3><p>在<a href="https://www.ipaddress.com/">IPAdress</a>网站上，输入github.com查询ip地址，可以看到，当前最新的ip地址是140.82.113.4，记录这个ip地址。<br><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020/07/18/15950555144253.jpg?image/auto-orient,1/resize,p_89/quality,q_90"></p>
<h3 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h3><p>terminal打开命令：<code>sudo vi /etc/hosts</code>，输入密码，选择“e(edit anyway)”,然后添加记录：（此处涉及到vi编辑器的用法，不会用的自行百度or谷歌）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line"> 140.82.113.4 www.github.com</span><br></pre></td></tr></table></figure>
<p>最后保存并退出，修改hosts文件保存后我自动刷新DNS，再ping就没问题啦！<br><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020/07/18/15950558068128.jpg?image/auto-orient,1/resize,p_89/quality,q_90"><br>可以看到连接不怎么稳定，此时就需要小飞机来帮忙了。</p>
<h3 id="配置代理提高速度"><a href="#配置代理提高速度" class="headerlink" title="配置代理提高速度"></a>配置代理提高速度</h3><p>因为如果挂了全局代理，这样如果需要克隆coding之类的国内仓库，会奇慢无比所以我建议使用这条命令，只对github进行代理，对国内的仓库不影响</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy https://127.0.0.1:1080</span><br><span class="line">git config --global https.https://github.com.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<p>同时，如果在输入这条命令之前，已经输入全局代理的话，可以输入进行取消</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<p>其中端口在小飞机的设置里查看，比如当前我的代理端口就是1087<br><img src="http://gray.oss-cn-beijing.aliyuncs.com/2020/07/18/15950560453819.jpg?image/auto-orient,1/resize,p_89/quality,q_90"><br>注意：这歌方法仅限于https协议下载，对于SSH协议是无效的。</p>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派+HomeBridge实现HomeKit控制智能家居</title>
    <url>/2019/09/25/%E6%A0%91%E8%8E%93%E6%B4%BE+HomeBridge%E5%AE%9E%E7%8E%B0HomeKit%E6%8E%A7%E5%88%B6%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/</url>
    <content><![CDATA[<p>米家app发展的很快，短短几年，已经日趋完善，得益于其高性价比，用户也越来越多，反观HomeKit在国内的表现，也仅仅是同“<strong>电视.app</strong>“一样，躺在每个ios用户的手机里。后来，在GitHub上开源了一个<a href="https://github.com/nfarina/homebridge">HomeBridge</a>项目，通过树莓派做桥接，实现Siri控制米家智能设备。</p>
<span id="more"></span>
<p>##一、需要准备的东西</p>
<ul>
<li><p>支持 iOS10 的苹果设备（ iPhone 5 以上、 iPad mini 2 以上、 iPod 第六代以上）</p>
</li>
<li><p>小米多功能网关<strong>二代</strong>（ 注意：一定要二代！）</p>
</li>
<li><p>任意一个或多个支持 HomeKit 的设备：小米智能插座 ZigBee 版、小米人体传感器、小米门窗传感器、小米温湿度传感器、Yeelight智能灯泡、 Aqara墙壁开关等</p>
</li>
<li><p>树莓派 Raspberry Pi 3B+ （包含读卡器 &amp; 8 Gb 以上 TF 内存卡一张）</p>
</li>
<li><p>Mac Book一台（当然，win也可以） <br><br><img src="http://gray.oss-cn-beijing.aliyuncs.com/2019/09/25/4518047ab0da64eede17368.gif?image/auto-orient,1/resize,p_89/quality,q_90" alt="树莓派"><center>树莓派3B+</center></p>
</li>
</ul>
<p>##二、GitHub项目地址</p>
<ul>
<li><a href="https://github.com/nfarina/homebridge">HomeBridge</a></li>
<li><a href="https://github.com/YinHangCode/homebridge-mi-aqara">homebridge-mi-aqara</a></li>
</ul>
<p>##三、开始吧</p>
<ol>
<li>关于树莓派的安装和打开ssh可以先移步<a href="https://blog.csdn.net/u012313335/article/details/53405734">系统烧录</a>和<a href="https://blog.csdn.net/u012313335/article/details/73920256">打开ssh</a>；</li>
<li>跟新gcc（可以使用pi用户也可以使用root用户，使用pi用户涉及权限问题请加sudo）<br><br><code>sudo apt-get install gcc</code></li>
<li>接下来依次安装，如果你发现速度很慢，你可能需要更改中国软件源，参考文章：Raspbian <a href="http://shumeipai.nxez.com/2013/08/31/raspbian-chinese-software-source.html">中国软件源</a>,阿里云各个地方速度都不错。</li>
</ol>
<p><br><strong>a. 安装nodejs：</strong><br><br><code>sudo apt-get update</code><br><code>curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -</code><br><code>sudo apt-get install -y nodejs</code><br><code>sudo apt-get install -y build-essential</code><br><br><strong>b. 安装avahi：</strong><br><br><code>sudo apt-get install libavahi-compat-libdnssd-dev</code><br><br><strong>c. 安装HomeBridge：</strong><br><br><code>sudo npm install -g --unsafe-perm homebridge</code><br><br><strong>d. 安装homebridge-aqara：</strong><br><br><code>sudo npm install -g homebridge-aqara</code><br><br>安装部分完成！</p>
<ol>
<li>新建和配置config.json文件<br>返回主目录→创建” .homebridge “文件夹→进入” config.json “文件）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~ </span><br><span class="line">mkdir .homebridge</span><br><span class="line">vim .homebridge/config.json</span><br></pre></td></tr></table></figure>
<pre><code>&lt;br&gt;复制以下代码稍作修改：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &quot;bridge&quot;: &#123;</span><br><span class="line"></span><br><span class="line">        &quot;name&quot;: &quot;Homebridge&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;username&quot;: &quot;CC:22:3D:E3:CE:30&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;port&quot;: 51826,</span><br><span class="line"></span><br><span class="line">        &quot;pin&quot;: &quot;031-45-154&quot;</span><br><span class="line"></span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">    &quot;platforms&quot;: [&#123;</span><br><span class="line"></span><br><span class="line">        &quot;platform&quot;: &quot;AqaraPlatform&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;sid&quot;: [&quot;【（密码A）网关MAC地址，去掉冒号，全部小写】&quot;],</span><br><span class="line"></span><br><span class="line">        &quot;password&quot;: [&quot;【（密码B）网关局域网密码】&quot;]</span><br><span class="line"></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br>其中 name 是你在 iOS 家庭 App 上可以看到的桥接器的名字，建议就叫 Homebridge，username 需要是类似 MAC 的格式，是可以随意填写，只要符合格式，建议不需要更改了。port 随意，确保不要被占用。pin 随意，为密码，需要是 8 位数字，格式为 xxx-xx-xxx，比如 123-45-678。下面的 platform 也是无所谓修改不修改，关键是<strong>sid</strong>和<strong>password</strong>，这就需要在手机上操作了。<br>在手机上打开米家 App，点击你的网关，右上角三个 ···，并狂按底部空白区域，直到出现局域网通信协议和网管信息为止。<br><img src="http://gray.oss-cn-beijing.aliyuncs.com/2019-09-25%2F1569411561.png"><br>点击局域网通信协议，打开，并刷新一个密码，改为全部小写，（安卓手机刷出来是小写），记录这段文字（密码 A ）。<br><br>点击网关信息，找到 mac: 后的文字，如本截图中的 28:6C:07:85:B3:0E，去掉 : 并全部改为小写，也记录这段文字（密码 B ），如本截图中的文字处理后的结果就是 f0b429cc6168。<br><img src="http://gray.oss-cn-beijing.aliyuncs.com/2019/09/25/15694117001892.jpg?image/auto-orient,1/resize,p_89/quality,q_90"><br>第一个密码 A 就是你的 sid，第二个密码 B 就是 password。如果你有多个网关用逗号链接，比如 cb30a01c1bcc4b3c, dc41b12d2cdd5c4d, password 同理。在刚刚树莓派编辑的 config.json 输入上面获得的密码，保存退出。（vim的使用自行Google）</p>
<ol>
<li>运行homebridge<br>直接在命令行输入<code>homebridge</code>就能运行；有时出现错误会自动关闭，错误原因有很多，一般就是端口占用，或者mac地址和密码填写错误，仔细检查，如果不行的话，清除缓存，删除连接信息重新运行homebridge：<br><strong>操作方法</strong><br>a. 结束HomeBridge进程，如下：<br><code>pkill -9 homebridge</code><br>b. 进入config.json所在的文件夹，例如：<br><code>cd /root/.homebridge</code><br>c. 删除文件夹下persist文件夹，例如：<br><code>rm -rf persist</code><br>d. 重启Homebridge进程，例如：<br><code>homebridge</code><br>掏出iPhone，打开家庭app，点击添加配件，扫描二维码或者手动输入你设置的八位密码就可以配对成功，操作完成。</li>
<li>最后的最后，你会发现，HomeBridge 停止运行了。我们不可能在电脑上挂着终端使树莓派一直运行这个服务，因此还有最后一步，把 HomeBridge 服务加入到树莓派的系统服务里。事实上, 树莓派文档 Scheduling tasks with Cron 给出的方法是最简单并且方便以后配置别的程序。<br>先安装 cron<br><code>sudo apt-get install gnome-schedule</code><br>然后配置 cron.<br><code>crontab -e</code><br>在最下方添加<code>@reboot homebridge &amp;</code>即可完成开机启动 homebridge 的配置。<br>现在，你可以重启一下树莓派，运行<code>ps -ef | grep homebridge</code>看看 HomeBridge 服务是否正常运行.</li>
</ol>
<p>最后来感叹一下apple的生态系统，当我成功配置后，我能够在iPhone、ipad、mac、甚至是Apple Watch上控制小米家居，实在激动。</p>
<p><strong>注意</strong>：树莓派必须通过网线连接，不能通过Wi-Fi连接！</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.jianshu.com/p/ec79b2711bd5">树莓派进阶（一）：借助树莓派与 HomeBridge，从米家到 HomeKit</a><br><a href="https://sspai.com/post/38358">从米家到 HomeKit，你只需要一个树莓派</a><br><a href="https://homekit.loli.ren/docs/show/3">HomeBridge教程 </a></p>
]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>提问的智慧</title>
    <url>/2020/03/03/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    <content><![CDATA[<h1 id="提问的智慧"><a href="#提问的智慧" class="headerlink" title="提问的智慧"></a>提问的智慧</h1><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/pulls"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=flat-square" alt="PRs Welcome"></a></p>
<p><strong>How To Ask Questions The Smart Way</strong></p>
<p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p>
<p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p>
<p>原文网址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html">http://www.catb.org/~esr&#x2F;faqs&#x2F;smart-questions.html</a></p>
<p>Copyleft 2001 by D.H.Grand(nOBODY&#x2F;Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p>
<p>本中文指南是基于原文 3.10 版以及 2010 年由 <a href="https://github.com/gasolin">Gasolin</a> 所翻译版本的最新翻译；</p>
<p>协助指出翻译问题，<strong>请<a href="https://github.com/ryanhanwu/smartquestions/issues/new">发 Issue</a>，或直接<a href="https://github.com/ryanhanwu/smartquestions/compare/">发 Pull Request</a> 给我。</strong></p>
<p>本文另有<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README.md">繁體中文版</a>。</p>
<span id="more"></span>
<h2 id="原文版本历史"><a href="#原文版本历史" class="headerlink" title="原文版本历史"></a><a href="https://github.com/ryanhanwu/smartquestions/blob/master/history.md">原文版本历史</a></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">在提问之前</a></li>
<li><a href="#%E5%BD%93%E4%BD%A0%E6%8F%90%E9%97%AE%E6%97%B6">当你提问时</a><ul>
<li><a href="#%E6%85%8E%E9%80%89%E6%8F%90%E9%97%AE%E7%9A%84%E8%AE%BA%E5%9D%9B">慎选提问的论坛</a></li>
<li><a href="#stack-overflow">Stack Overflow</a></li>
<li><a href="#%E7%BD%91%E7%AB%99%E5%92%8C-irc-%E8%AE%BA%E5%9D%9B">网站和 IRC 论坛</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E9%A1%B9%E7%9B%AE%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8">第二步，使用项目邮件列表</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E4%B8%94%E6%8F%8F%E8%BF%B0%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%87%E9%A2%98">使用有意义且描述明确的标题</a></li>
<li><a href="#%E4%BD%BF%E9%97%AE%E9%A2%98%E5%AE%B9%E6%98%93%E5%9B%9E%E5%A4%8D">使问题容易回复</a></li>
<li><a href="#%E7%94%A8%E6%B8%85%E6%99%B0%E6%AD%A3%E7%A1%AE%E7%B2%BE%E5%87%86%E5%B9%B6%E5%90%88%E6%B3%95%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AF%AD%E5%8F%A5">用清晰、正确、精准并合法语法的语句</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%98%93%E4%BA%8E%E8%AF%BB%E5%8F%96%E4%B8%94%E6%A0%87%E5%87%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98">使用易于读取且标准的文件格式发送问题</a></li>
<li><a href="#%E7%B2%BE%E7%A1%AE%E5%9C%B0%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E5%B9%B6%E8%A8%80%E4%B9%8B%E6%9C%89%E7%89%A9">精确地描述问题并言之有物</a></li>
<li><a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a></li>
<li><a href="#%E5%88%AB%E5%8A%A8%E8%BE%84%E5%A3%B0%E7%A7%B0%E6%89%BE%E5%88%B0-bug">别动辄声称找到 Bug</a></li>
<li><a href="#%E4%BD%8E%E5%A3%B0%E4%B8%8B%E6%B0%94%E4%B8%8D%E8%83%BD%E4%BB%A3%E6%9B%BF%E4%BD%A0%E7%9A%84%E5%8A%9F%E8%AF%BE">低声下气不能代替你的功课</a></li>
<li><a href="#%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6%E8%80%8C%E9%9D%9E%E4%BD%A0%E7%9A%84%E7%8C%9C%E6%B5%8B">描述问题症状而非你的猜测</a></li>
<li><a href="#%E6%8C%89%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4%E5%85%88%E5%90%8E%E5%88%97%E5%87%BA%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6">按发生时间先后列出问题症状</a></li>
<li><a href="#%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BF%87%E7%A8%8B">描述目标而不是过程</a></li>
<li><a href="#%E5%88%AB%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8%E7%A7%81%E4%BA%BA%E7%94%B5%E9%82%AE%E5%9B%9E%E5%A4%8D">别要求使用私人电邮回复</a></li>
<li><a href="#%E6%B8%85%E6%A5%9A%E6%98%8E%E7%A1%AE%E7%9A%84%E8%A1%A8%E8%BE%BE%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E9%9C%80%E6%B1%82">清楚明确的表达你的问题以及需求</a></li>
<li><a href="#%E8%AF%A2%E9%97%AE%E6%9C%89%E5%85%B3%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%97%B6">询问有关代码的问题时</a></li>
<li><a href="#%E5%88%AB%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A%E7%9A%84%E9%97%AE%E9%A2%98%E8%B4%B4%E4%B8%8A%E6%9D%A5">别把自己家庭作业的问题贴上来</a></li>
<li><a href="#%E5%8E%BB%E6%8E%89%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E6%8F%90%E9%97%AE%E5%8F%A5">去掉无意义的提问句</a></li>
<li><a href="#%E5%8D%B3%E4%BD%BF%E4%BD%A0%E5%BE%88%E6%80%A5%E4%B9%9F%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%A0%87%E9%A2%98%E5%86%99%E7%B4%A7%E6%80%A5">即使你很急也不要在标题写紧急</a></li>
<li><a href="#%E7%A4%BC%E5%A4%9A%E4%BA%BA%E4%B8%8D%E6%80%AA%E8%80%8C%E4%B8%94%E6%9C%89%E6%97%B6%E8%BF%98%E5%BE%88%E6%9C%89%E5%B8%AE%E5%8A%A9">礼多人不怪，而且有时还很有帮助</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%8E%E5%8A%A0%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">问题解决后，加个简短的补充说明</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E7%AD%94%E6%A1%88">如何解读答案</a><ul>
<li><a href="#rtfm-%E5%92%8C-stfw%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%BD%A0%E5%B7%B2%E5%AE%8C%E5%85%A8%E6%90%9E%E7%A0%B8%E4%BA%86">RTFM 和 STFW：如何知道你已完全搞砸了</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E8%BF%98%E6%98%AF%E6%90%9E%E4%B8%8D%E6%87%82">如果还是搞不懂</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%A4%BC%E7%9A%84%E5%9B%9E%E5%BA%94">处理无礼的回应</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%89%AE%E6%BC%94%E5%A4%B1%E8%B4%A5%E8%80%85">如何避免扮演失败者</a></li>
<li><a href="#%E4%B8%8D%E8%AF%A5%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98">不该问的问题</a></li>
<li><a href="#%E5%A5%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A0%A2%E9%97%AE%E9%A2%98">好问题与蠢问题</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E5%BE%97%E4%B8%8D%E5%88%B0%E5%9B%9E%E7%AD%94">如果得不到回答</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98">如何更好地回答问题</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90">相关资源</a></li>
<li><a href="#%E9%B8%A3%E8%B0%A2">鸣谢</a></li>
</ul>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>许多项目在他们的使用协助&#x2F;说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明：</p>
<p><strong>本指南不提供此项目的实际支持服务！</strong></p>
<p>我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。</p>
<p>如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。</p>
<p>不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件<strong>好事</strong>；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。</p>
<p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。</p>
<p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p>
<p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p>
<p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。</p>
<p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答<code>赢家（winner）</code>的问题。</p>
<p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p>
<p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p>
<p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p>
<p>（欢迎对本指南提出改进意见。你可以 email 你的建议至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p>
<h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p>
<ol>
<li>尝试在你准备提问的论坛的旧文章中搜索答案。</li>
<li>尝试上网搜索以找到答案。</li>
<li>尝试阅读手册以找到答案。</li>
<li>尝试阅读常见问题文件（FAQ）以找到答案。</li>
<li>尝试自己检查或试验以找到答案。</li>
<li>向你身边的强者朋友打听以找到答案。</li>
<li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li>
</ol>
<p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p>
<p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 <a href="http://groups.google.com/">Google 论坛</a>，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p>
<p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p>
<p>准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p>
<p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p>
<p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。</p>
<p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p>
<h2 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h2><h3 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p>
<ul>
<li>在与主题不合的论坛上贴出你的问题。</li>
<li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li>
<li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li>
<li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li>
</ul>
<p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p>
<p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p>
<p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。</p>
<p>在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p>
<p>别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p>
<p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p>
<p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p>
<p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。</p>
<h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>搜索，<strong>然后</strong> 在 Stack Exchange 问。</p>
<p>近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p>
<p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p>
<p>Stack Exchange 已经成长到<a href="http://stackexchange.com/sites">超过一百个网站</a>，以下是最常用的几个站：</p>
<ul>
<li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li>
<li>Stack Overflow 是问写程序有关的问题。</li>
<li>Server Fault 是问服务器和网管相关的问题。</li>
</ul>
<h3 id="网站和-IRC-论坛"><a href="#网站和-IRC-论坛" class="headerlink" title="网站和 IRC 论坛"></a>网站和 IRC 论坛</h3><p>本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p>
<p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用<strong>我们的</strong>版本”。</p>
<p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p>
<p>通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p>
<p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p>
<h3 id="第二步，使用项目邮件列表"><a href="#第二步，使用项目邮件列表" class="headerlink" title="第二步，使用项目邮件列表"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p>
<ul>
<li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。</li>
<li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li>
<li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li>
<li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li>
</ul>
<p>如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p>
<p>然而，如果你<strong>确信</strong>你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p>
<p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p>
<h3 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p>
<p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p>
<blockquote>
<p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p>
</blockquote>
<blockquote>
<p>聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。</p>
</blockquote>
<blockquote>
<p>更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p>
</blockquote>
<p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p>
<p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p>
<p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p>
<p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p>
<p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p>
<p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p>
<h3 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p>
<p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p>
<h3 id="用清晰、正确、精准并语法正确的语句"><a href="#用清晰、正确、精准并语法正确的语句" class="headerlink" title="用清晰、正确、精准并语法正确的语句"></a>用清晰、正确、精准并语法正确的语句</h3><p>我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p>
<p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p>
<p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox">Alan Cox</a> 也许可以这样做，但你不行）。</p>
<p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p>
<p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p>
<p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p>
<blockquote>
<p>English is not my native language; please excuse typing errors.</p>
</blockquote>
<ul>
<li>英文不是我的母语，请原谅我的错字或语法。</li>
</ul>
<blockquote>
<p>If you speak $LANGUAGE, please email&#x2F;PM me;<br>I may need assistance translating my question.</p>
</blockquote>
<ul>
<li>如果你说<strong>某语言</strong>，请寄信&#x2F;私讯给我；我需要有人协助我翻译我的问题。</li>
</ul>
<blockquote>
<p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p>
</blockquote>
<ul>
<li>我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。</li>
</ul>
<blockquote>
<p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p>
</blockquote>
<ul>
<li>我把我的问题用<strong>某语言</strong>和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。</li>
</ul>
<h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p>
<ul>
<li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li>
<li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li>
<li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li>
<li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li>
<li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li>
<li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li>
<li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li>
<li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li>
</ul>
<p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p>
<h3 id="精确地描述问题并言之有物"><a href="#精确地描述问题并言之有物" class="headerlink" title="精确地描述问题并言之有物"></a>精确地描述问题并言之有物</h3><ul>
<li>仔细、清楚地描述你的问题或 Bug 的症状。</li>
<li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li>
<li>描述在提问前你是怎样去研究和理解这个问题的。</li>
<li>描述在提问前为确定问题而采取的诊断步骤。</li>
<li>描述最近做过什么可能相关的硬件或软件变更。</li>
<li>尽可能的提供一个可以<code>重现这个问题的可控环境</code>的方法。</li>
</ul>
<p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。</p>
<p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p>
<p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p>
<h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p>
<p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p>
<h3 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p>
<p>请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p>
<p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p>
<p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p>
<h3 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p>
<p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p>
<p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p>
<h3 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p>
<p><strong>蠢问题</strong></p>
<blockquote>
<p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p>
</blockquote>
<p><strong>聪明问题</strong></p>
<blockquote>
<p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6&#x2F;233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…。</p>
</blockquote>
<p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！</p>
<h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p>
<p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p>
<p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p>
<h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p>
<p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p>
<p><strong>蠢问题</strong></p>
<blockquote>
<p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？</p>
</blockquote>
<p><strong>聪明问题</strong></p>
<blockquote>
<p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。</p>
</blockquote>
<p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p>
<h3 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p>
<p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。</p>
<p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p>
<h3 id="清楚明确的表达你的问题以及需求"><a href="#清楚明确的表达你的问题以及需求" class="headerlink" title="清楚明确的表达你的问题以及需求"></a>清楚明确的表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p>
<p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p>
<p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p>
<p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好的理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p>
<h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p>
<p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译&#x2F;直译&#x2F;被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p>
<p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p>
<p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p>
<h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p>
<p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的<strong>使用者</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的使用者也许仍会给你一些提示。</p>
<h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p>
<p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p>
<p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p>
<p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p>
<h3 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p>
<p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p>
<p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛绒绒的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。</p>
<p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p>
<h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p>
<p>坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p>
<p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p>
<p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p>
<h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p>
<p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>的有趣），因此可以利用此时间去解决其它问题。</p>
<p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p>
<p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p>
<p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表&#x2F;新闻群组&#x2F;论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p>
<p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p>
<p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p>
<p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p>
<h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><p><a id="RTFM"></a></p>
<h3 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM （Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p>
<p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 <strong><a href="http://lmgtfy.com/">Google 是你的朋友</a></strong>！）</p>
<p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p>
<p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为</p>
<ul>
<li><strong>你需要的信息非常容易获得</strong>；</li>
<li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li>
</ul>
<p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p>
<h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p>
<p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p>
<h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p>
<p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p>
<p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p>
<p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。</p>
<p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p>
<p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p>
<h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p>
<p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：</p>
<p>熬过去，这很正常。事实上，它是有益健康且合理的。</p>
<p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p>
<p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p>
<p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p>
<p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p>
<p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p>
<p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p>
<p>也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p>
<h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p>
<p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p>
<p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p>
<p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p>
<p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</a></p>
<p>问题：<a href="#q5">我的程序&#x2F;设定&#x2F;SQL 语句没有用</a></p>
<p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p>
<p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p>
<p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p>
<p>问题：<a href="#q9">我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？</a></p>
<hr>
<p><a id="q1"></a></p>
<blockquote>
<p>问题：我能在哪找到 X 程序或 X 资源？</p>
</blockquote>
<p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="http://www.google.com/">Google</a> 吗？</p>
<p><a id="q2"></a></p>
<blockquote>
<p>问题：我怎样用 X 做 Y？</p>
</blockquote>
<p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p>
<p><a id="q3"></a></p>
<blockquote>
<p>问题：如何设定我的 shell 提示？？</p>
</blockquote>
<p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p>
<p><a id="q4"></a></p>
<blockquote>
<p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？</p>
</blockquote>
<p>回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。</p>
<p><a id="q5"></a></p>
<blockquote>
<p>问题：我的{程序&#x2F;设定&#x2F;SQL 语句}不工作</p>
</blockquote>
<p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p>
<ul>
<li>你还有什么要补充的吗？</li>
<li>真糟糕，希望你能搞定。</li>
<li>这关我有什么屁事？</li>
</ul>
<p><a id="q6"></a></p>
<blockquote>
<p>问题：我的 Windows 电脑有问题，你能帮我吗？</p>
</blockquote>
<p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p>
<p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p>
<p><a id="q7"></a></p>
<blockquote>
<p>问题：我的程序不会动了，我认为系统工具 X 有问题</p>
</blockquote>
<p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p>
<p><a id="q8"></a></p>
<blockquote>
<p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p>
</blockquote>
<p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到使用者群组的清单）。</p>
<p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p>
<p><a id="q9"></a></p>
<blockquote>
<p>问题：我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？</p>
</blockquote>
<p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p>
<h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p>
<p><strong>蠢问题</strong>：</p>
<blockquote>
<p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p>
</blockquote>
<p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p>
<p><strong>聪明问题</strong>：</p>
<blockquote>
<p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p>
</blockquote>
<p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p>
<p><strong>蠢问题</strong>：</p>
<blockquote>
<p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p>
</blockquote>
<p>他觉得都是别人的错，这个傲慢自大的提问者。</p>
<p><strong>聪明问题</strong>：</p>
<blockquote>
<p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p>
</blockquote>
<p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p>
<p><strong>蠢问题</strong>：</p>
<blockquote>
<p>我的主机板有问题了，谁来帮我？</p>
</blockquote>
<p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p>
<p><strong>聪明问题</strong>：</p>
<blockquote>
<p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p>
</blockquote>
<p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p>
<p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p>
<p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p>
<p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p>
<p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p>
<p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p>
<h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p>
<p>总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p>
<p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p>
<p>有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p>
<p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p>
<p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p>
<h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p><strong>态度和善一点</strong>。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p>
<p><strong>对初犯者私下回复</strong>。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p>
<p><strong>如果你不确定，一定要说出来</strong>！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p>
<p><strong>如果帮不了忙，也别妨碍他</strong>。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p>
<p><strong>试探性的反问以引出更多的细节</strong>。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p>
<p>尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。</p>
<p><strong>如果你决定回答，就请给出好的答案</strong>。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。</p>
<p><strong>正面的回答问题</strong>！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p>
<p><strong>帮助你的社区从问题中学习</strong>。当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p>
<p>如果你是在研究一番后才做出的回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p>
<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix 系统和网络基本原理</a>。</p>
<p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">软件发布实践</a>操作。</p>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>
<p>远程软件（输入浏览器直接下载） Win版本:  <a href="https://j.yeziapp.com/tv.exe">https://j.yeziapp.com/tv.exe</a>  Mac版本:  <a href="https://j.yeziapp.com/tv.dmg">https://j.yeziapp.com/tv.dmg</a>  使用说明：选择自己需要的系统版本下载，下载好打开把界面上ID密码发我即可远程。</p>
]]></content>
  </entry>
  <entry>
    <title>那些句子</title>
    <url>/2019/09/26/%E9%82%A3%E4%BA%9B%E5%8F%A5%E5%AD%90/</url>
    <content><![CDATA[<ol>
<li>七岁的那年，抓住那只蝉，以为能抓住了夏天。  –<a href="https://music.apple.com/cn/album/%E4%BD%A0%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%BF%AB%E4%B9%90/1098553403?i=1098553466">《如烟》</a></li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>全球IPv4地址耗尽，正式迈入IPv6时代！</title>
    <url>/2019/11/26/%E5%85%A8%E7%90%83IPv4%E5%9C%B0%E5%9D%80%E8%80%97%E5%B0%BD%EF%BC%8C%E6%AD%A3%E5%BC%8F%E8%BF%88%E5%85%A5IPv6%E6%97%B6%E4%BB%A3%EF%BC%81/</url>
    <content><![CDATA[<p>2019年11月25日 22:35分，是值得互联网纪念的一个时刻，全球IPv4地址已经全部耗尽！</p>
<span id="more"></span>
<p>IPv4中规定IP地址长度为32位二进制，最多能有2^32 个，大约42.9亿个，而IPv6采用128位地址长度，能达到2^128 个，这可是一个天文数字了，可以保证地球上每平方米分配1000多个地址。</p>
]]></content>
  </entry>
  <entry>
    <title>通过Hexo + Github 搭建博客</title>
    <url>/2019/05/25/%E9%80%9A%E8%BF%87Hexo-Github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>最近学习压力很大，想起了这个被搁置一年的博客计划，正好看到了Hexo搭建的<a href="http://frankorz.com/archives/">萤火之森</a>页面，真的很漂亮，于是决定动手自己搭建一个。这篇文章正好记录一下搭建过程中遇到的问题，方便以后学习。</p>
</blockquote>
<span id="more"></span>
<h2 id="hexo-基础命令"><a href="#hexo-基础命令" class="headerlink" title="hexo 基础命令"></a>hexo 基础命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g == hexo generate  生成</span><br><span class="line">hexo d == hexo deploy 部署</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo n == hexo new</span><br></pre></td></tr></table></figure>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="1-Github密匙只读"><a href="#1-Github密匙只读" class="headerlink" title="1. Github密匙只读"></a>1. Github密匙只读</h3><h3 id="2-hexo-s-显示4000端口不能用"><a href="#2-hexo-s-显示4000端口不能用" class="headerlink" title="2. hexo s 显示4000端口不能用"></a>2. hexo s 显示4000端口不能用</h3><p>解决方法：在Blog的根目录下，修改_config.ynl文件，在最后加上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: <span class="number">4001</span>  #注意port前有Tab键 冒号后有空格</span><br><span class="line">    compress: <span class="literal">true</span></span><br><span class="line">    header: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="花费的时间"><a href="#花费的时间" class="headerlink" title="花费的时间"></a>花费的时间</h2><p>总的算下来，总共花了我四个小时左右的时间来搭建这个博客，当然，这仅仅是搭建了基础的框架，后期还需要大量的时间来美化，不过鉴于最近考试太忙，估计得延期一段时间了。</p>
<h2 id="为什么要需要这个博客？"><a href="#为什么要需要这个博客？" class="headerlink" title="为什么要需要这个博客？"></a>为什么要需要这个博客？</h2><p>一年前，我用阿里云镜像一键搭建了基于Wordpress的个人博客，但是由于拖更，导致兴趣越来越少，最后也就不了了之了。从这段历程中，我感受到了，不是自己努力来的结果自己真是不懂得珍惜，这一个花费我一晚上心血建立的Blog，我可要好好监督自己，不要荒废了。<br>其实，挺羡慕那些能在各种论坛分享自己知识的人，帮助别人的同时也能留下自己的足迹，最重要的是，在这个过程中，能找到归属感与成就感，这就是分享的意义吧。<br>很大一部分人，写的都是技术博客，但是我知道自己现在能力有限，输出不了太多的干货，所以，现在这个阶段，更多的是记录一些学习笔记，当然，我也想穿插一些自己的心里话，写一下每个阶段的感悟。</p>
<h2 id="搭建过程让我学到了什么"><a href="#搭建过程让我学到了什么" class="headerlink" title="搭建过程让我学到了什么"></a>搭建过程让我学到了什么</h2><p>搭建过程虽然烦琐，但我确乐在其中，兴趣是最好的老师，在搭建过程中，我看到了很多感兴趣的技术，比如GitHub的代码托管（很早以前我就注册了GitHub账号，但是一直没有项目来练习），比如Node.js，看到漂亮的网页，不眠不免对前端心生向往，再比如最近一直在学习的Linux命令行，现我已经迫不及待想要用shell自己写一个一键部署脚本了。</p>
<h2 id="给自己立下Flag"><a href="#给自己立下Flag" class="headerlink" title="给自己立下Flag"></a>给自己立下Flag</h2><p>我的脑海里会迸发出很多新计划，但是最后很多都是不了了之，因为没有去实现，所以，在这里，我要给自己定几个目标：</p>
<ol>
<li>每个月至少来更新一篇博客，不管是什么类型的。</li>
<li>尽快掌握MarkDown与法，写出排版漂亮的文章。</li>
<li>将我的小站好好维护下去，做一些优化。</li>
<li>开始GitHub的学习</li>
</ol>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我觉得我很有想法，但是想到和做到之间，有一块透明的玻璃挡在我的面前，它看不见，但是它真实存在，而现在我要做的，就是想办法用行动突破它！<br>在脑海里的话语，写在纸面上就是另外一番模样，说白了，我需要练习自己的写作能力了，多年后，看到这青涩的文字，嘴角应该会有一丝微笑吧。</p>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云OSS乌龙</title>
    <url>/2019/09/27/%E9%98%BF%E9%87%8C%E4%BA%91OSS%E4%B9%8C%E9%BE%99/</url>
    <content><![CDATA[<p>昨天，突然接到阿里云的短信，我前天才开的阿里云oss欠费停机了？？？<img src="http://gray.oss-cn-beijing.aliyuncs.com/2019/09/27/imgeab4a9a03e8d1.jpeg?image/auto-orient,1/resize,p_89/quality,q_90" alt="IMG_EAB4A9A03E8D-1"></p>
<center>停机短信</center>
excuse me？ 我才开通一天啊喂！后来我迅速查看了使用详情，![使用明细](http://gray.oss-cn-beijing.aliyuncs.com/2019/09/27/shi-yong-ming-xi.png?image/auto-orient,1/resize,p_89/quality,q_90)
看到了**云服务器ECS-快照**的字样，我立马想到自己的ECS，是不是设置了自动快照？？因为前面的流量情况是一样的，是不是它自己一直在自动备份？？可是我查看了自己所有的服务器，并没有开快照啊。![服务器没有开通快照](http://gray.oss-cn-beijing.aliyuncs.com/2019/09/27/fu-wu-qi-mei-you-kai-tong-kuai-zhao.png?image/auto-orient,1/resize,p_89/quality,q_90)
无奈之下，我只能联系客服（不得不说阿里爸爸服务是真棒！）晚上十一点多还有在线客服也是感动了一把。最终在与客服耐心的沟通后，仍然没有找到问题所在。直到最后，我忽然想起新建bucket时候的两个条件：![](http://gray.oss-cn-beijing.aliyuncs.com/2019/09/27/15695594696934.jpg?image/auto-orient,1/resize,p_89/quality,q_90)
**存储包**和**流量包**！！！我购买的是存储包而欠费的原因竟然是流量包……这一发现让我哭笑不得，原来问题它就不出在那40G的存储包上面，而所谓的快照原来就是我已经使用的空间，最终，当我交上欠费的¥0.1以后，终于又能打开markdown图片了。

<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>经过这一次的事件，我越发明白了阅读官方文档的重要性，其实这些内容在官方给的QA里一般能找到，但是习惯互联网捷径的我更愿意直接google，这不失为解决方法的一种途径，但是，有时候可能官方给出的文档更加注重问题本身，更加明了，前提是你能够静下心来仔细阅读一下。包括昨天我还没有解决的GitHub密匙问题（当初搭建博客时候，把密匙配置在了graylogo&#x2F;gray.github.io仓库下，导致其他仓库push时候失败了，官方文档提供的ssh连接很详细，但可惜的是全是英文……纵使如此，一些词汇还是相对简单的，加上Google翻译，还是能看懂的。所以，啥也不说了，读文档，解决问题去吧。</p>
]]></content>
  </entry>
  <entry>
    <title>测试文章</title>
    <url>/2026/01/19/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>这是一篇测试文章，用于验证Hexo博客是否正常工作。</p>
<h3 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h3><ol>
<li>这是第一点测试内容</li>
<li>这是第二点测试内容</li>
<li>这是第三点测试内容</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">exho g -d</span><br></pre></td></tr></table></figure>

<h3 id="图片测试"><a href="#图片测试" class="headerlink" title="图片测试"></a>图片测试</h3><p><img src="https://via.placeholder.com/150" alt="测试图片"></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>

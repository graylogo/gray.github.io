<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[提问的智慧]]></title>
    <url>%2F2020%2F03%2F03%2F%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7%2F</url>
    <content type="text"><![CDATA[提问的智慧 How To Ask Questions The Smart Way Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen 本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。 原文网址：http://www.catb.org/~esr/faqs/smart-questions.html Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu 本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译； 协助指出翻译问题，请发 Issue，或直接发 Pull Request 给我。 本文另有繁體中文版。 原文版本历史目录 声明 简介 在提问之前 当你提问时 慎选提问的论坛 Stack Overflow 网站和 IRC 论坛 第二步，使用项目邮件列表 使用有意义且描述明确的标题 使问题容易回复 用清晰、正确、精准并合法语法的语句 使用易于读取且标准的文件格式发送问题 精确地描述问题并言之有物 话不在多而在精 别动辄声称找到 Bug 低声下气不能代替你的功课 描述问题症状而非你的猜测 按发生时间先后列出问题症状 描述目标而不是过程 别要求使用私人电邮回复 清楚明确的表达你的问题以及需求 询问有关代码的问题时 别把自己家庭作业的问题贴上来 去掉无意义的提问句 即使你很急也不要在标题写紧急 礼多人不怪，而且有时还很有帮助 问题解决后，加个简短的补充说明 如何解读答案 RTFM 和 STFW：如何知道你已完全搞砸了 如果还是搞不懂 处理无礼的回应 如何避免扮演失败者 不该问的问题 好问题与蠢问题 如果得不到回答 如何更好地回答问题 相关资源 鸣谢 声明许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明： 本指南不提供此项目的实际支持服务！ 我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。 如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。 简介在黑客的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。 不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件好事；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。 首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。 尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。 我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（撸瑟） （由于历史原因，我们有时把它拼作 lusers）。 我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。 我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。 如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。 所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。 如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。 （欢迎对本指南提出改进意见。你可以 email 你的建议至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。然而请注意，本文并非网络礼节的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。 在提问之前在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情： 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案。 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案。 当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。 运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（既搜索 Google 论坛，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。 别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。 准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。 小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题…， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。 绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。 另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。 当你提问时慎选提问的论坛小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者： 在与主题不合的论坛上贴出你的问题。 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。 在太多的不同新闻群组上重复转贴同样的问题（cross-post）。 向既非熟人也没有义务解决你问题的人发送私人电邮。 黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。 因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括阅读 FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。 向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。 在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。 别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。 搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。 一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。 可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。 Stack Overflow搜索，然后 在 Stack Exchange 问。 近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。 因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。 Stack Exchange 已经成长到超过一百个网站，以下是最常用的几个站： Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。 Stack Overflow 是问写程序有关的问题。 Server Fault 是问服务器和网管相关的问题。 网站和 IRC 论坛本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。 事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用我们的版本”。 在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。 通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。 在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。 第二步，使用项目邮件列表当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法： 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。 然而，如果你确信你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意） 如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。 使用有意义且描述明确的标题在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。 一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。 蠢问题：救命啊！我的笔记本电脑不能正常显示了！ 聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。 更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。 编写目标 —— 差异 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境和你遇到的问题。 总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。 如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 Re: 测试 或者 Re: 新 bug 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。 对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。 仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。 在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你只想在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。 使问题容易回复以请将你的回复发送到……来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。 在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。 用清晰、正确、精准并语法正确的语句我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。 正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很准确，而且有迹象表明你是在思考和关注问题。 正确地拼写、使用标点和大小写，不要将its混淆为it&#39;s，loose搞成lose或者将discrete弄成discreet。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox 也许可以这样做，但你不行）。 更白话的说，如果你写得像是个半文盲[译注：小白]，那多半得不到理睬。也不要使用即时通信中的简写或火星文，如将的简化为d会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。 如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。 如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：[译注：以下附上原文以供使用] English is not my native language; please excuse typing errors. 英文不是我的母语，请原谅我的错字或语法。 If you speak $LANGUAGE, please email/PM me;I may need assistance translating my question. 如果你说某语言，请寄信/私讯给我；我需要有人协助我翻译我的问题。 I am familiar with the technical terms,but some slang expressions and idioms are difficult for me. 我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。 I’ve posted my question in $LANGUAGE and English.I’ll be glad to translate responses, if you only use one or the other. 我把我的问题用某语言和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。 使用易于读取且标准的文件格式发送问题如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以： 使用纯文字而不是 HTML (关闭 HTML 并不难）。 使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。 不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。 但是，对一些特殊的文件不要设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。 在英语论坛中，不要使用Quoted-Printable MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的=20符号既难看也分散注意力，甚至有可能破坏内容的语意。 绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。 如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的智能引号功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉智能引号单选框），以免在你的邮件中到处散布垃圾字符。 在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。 如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。 精确地描述问题并言之有物 仔细、清楚地描述你的问题或 Bug 的症状。 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。 描述在提问前你是怎样去研究和理解这个问题的。 描述在提问前为确定问题而采取的诊断步骤。 描述最近做过什么可能相关的硬件或软件变更。 尽可能的提供一个可以重现这个问题的可控环境的方法。 尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。 以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。 Simon Tatham 写过一篇名为《如何有效的报告 Bug》的出色文章。强力推荐你也读一读。 话不在多而在精你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。 这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；第二，简化问题使你更有可能得到有用的答案；第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。 别动辄声称找到 Bug当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug，你应该能提供相应位置的修正或替代文件。 请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。 编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有Bug时，这尤其严重。 提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。 低声下气不能代替你的功课有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：我知道我只是个可悲的新手，一个撸瑟，但...。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。 别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。 有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。 描述问题症状而非你的猜测告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。 蠢问题 我在编译内核时接连遇到 SIG11 错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。所有内存都换过了，没有效果。相关部分的标准编译记录如下…。 由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！ 按发生时间先后列出问题症状问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。 如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。 如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。 描述目标而不是过程如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。 经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。 蠢问题 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？ 聪明问题 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。 第二种提问法比较聪明，你可能得到像是建议采用另一个更合适的工具的回复。 别要求使用私人电邮回复黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。 当你要求私下回复时，这个过程和奖励都被中止。别这样做，让回复者来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。 这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是向我发电邮，我将为论坛归纳这些回复。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。 清楚明确的表达你的问题以及需求漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。 如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。 要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。 所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问我想更好的理解 X，可否指点一下哪有好一点说明？通常比问你能解释一下 X 吗？更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。 询问有关代码的问题时别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：它不能工作会让你完全被忽略。只贴几十行代码，然后说一句：在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;比较有可能让你得到回应。 最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看话不在多而在精一节）。 一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。 如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。 别把自己家庭作业的问题贴上来黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。 如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的使用者邮件列表或论坛中提问。尽管黑客们会看出来，但一些有经验的使用者也许仍会给你一些提示。 去掉无意义的提问句避免用无意义的话结束提问，例如有人能帮我吗？或者这有答案吗？。 首先：如果你对问题的描述不是很好，这样问更是画蛇添足。 其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你或者不，没答案。 一般来说，避免用 是或否、对或错、有或没有类型的问句，除非你想得到是或否类型的回答。 即使你很急也不要在标题写紧急这是你的问题，不是我们的。宣称紧急极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，紧急这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。 有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。 当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如紧急：帮我救救这个毛绒绒的小海豹！肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。 如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。 礼多人不怪，而且有时还很有帮助彬彬有礼，多用请和谢谢您的关注，或谢谢你的关照。让大家都知道你对他们花时间免费提供帮助心存感激。 坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的） 然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。 （我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得先谢了意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说先谢了，然后事后再对回复者表示感谢，或者换种方式表达感激，譬如用谢谢你的关注或谢谢你的关照。） 问题解决后，加个简短的补充说明问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。 最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X的有趣），因此可以利用此时间去解决其它问题。 补充说明不必很长或是很深入；简单的一句你好，原来是网线出了问题！谢谢大家 – Bill比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。 对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此之后才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。 除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。 至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。 思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。 在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。 如何解读答案 RTFM 和 STFW：如何知道你已完全搞砸了有一个古老而神圣的传统：如果你收到RTFM （Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。 RTFM 有一个年轻的亲戚。如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 Google 是你的朋友！） 在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。 通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为 你需要的信息非常容易获得； 你自己去搜索这些信息比灌给你，能让你学到更多。 你不应该因此不爽；依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见。你应该对他祖母般的慈祥表示感谢。 如果还是搞不懂如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。 比方说，如果我回答你：看来似乎是 zentry 卡住了；你应该先清除它。，然后，这是一个很糟的后续问题回应：zentry 是什么？ 好的问法应该是这样：哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？ 处理无礼的回应很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。 如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。 另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。 （有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会正常交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们喜欢我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。 Jeff Bigler 的观察总结和这个相关也值得一读 (tact filters)。 在下一节，我们会谈到另一个问题，当你行为不当时所会受到的冒犯。 如何避免扮演失败者在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。 这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做： 熬过去，这很正常。事实上，它是有益健康且合理的。 社区的标准不会自行维持，它们是通过参与者积极而公开地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。 也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称如果你不想帮助用户就闭嘴。 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。 夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。 记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。 有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是真的会把问题搞砸。 这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。 也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。 不该问的问题以下是几个经典蠢问题，以及黑客没回答时心中所想的： 问题：我能在哪找到 X 程序或 X 资源？ 问题：我怎样用 X 做 Y？ 问题：如何设定我的 shell 提示？ 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 问题：我的程序/设定/SQL 语句没有用 问题：我的 Windows 电脑有问题，你能帮我吗？ 问题：我的程序不会动了，我认为系统工具 X 有问题 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 问题：我能在哪找到 X 程序或 X 资源？ 回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？ 问题：我怎样用 X 做 Y？ 回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。 问题：如何设定我的 shell 提示？？ 回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 RTFM，然后自己去找出来。 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。 问题：我的{程序/设定/SQL 语句}不工作 回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种 你还有什么要补充的吗？ 真糟糕，希望你能搞定。 这关我有什么屁事？ 问题：我的 Windows 电脑有问题，你能帮我吗？ 回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。 注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你可以问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。 问题：我的程序不会动了，我认为系统工具 X 有问题 回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到使用者群组的清单）。 注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 Linux 和所有被怀疑的硬件作关键词仔细搜索。 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！ 好问题与蠢问题最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。 蠢问题： 我可以在哪儿找到关于 Foonly Flurbamatic 的资料？ 这种问法无非想得到 STFW 这样的回答。 聪明问题： 我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？ 这个问题已经 STFW 过了，看起来他真的遇到了麻烦。 蠢问题： 我从 foo 项目找来的源码没法编译。它怎么这么烂？ 他觉得都是别人的错，这个傲慢自大的提问者。 聪明问题： foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？ 提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。 蠢问题： 我的主机板有问题了，谁来帮我？ 某黑客对这类问题的回答通常是：好的，还要帮你拍拍背和换尿布吗？，然后按下删除键。 聪明问题： 我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？ 这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 在最后一个问题中，注意告诉我答案和给我启示，指出我还应该做什么诊断工作之间微妙而又重要的区别。 事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。 通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。 事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的名人，而是因为我用了正确的方式来提问。 黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我像个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。 如果得不到回答如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。 总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。 你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。 有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。 另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。 对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。 如何更好地回答问题态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。 对初犯者私下回复。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。 如果你不确定，一定要说出来！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。 如果帮不了忙，也别妨碍他。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。 试探性的反问以引出更多的细节。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。 尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。 如果你决定回答，就请给出好的答案。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。 正面的回答问题！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。 帮助你的社区从问题中学习。当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。 如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。 相关资源如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 Unix 系统和网络基本原理。 当你发布软件或补丁时，试着按软件发布实践操作。 鸣谢Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。 远程软件（输入浏览器直接下载） Win版本: https://j.yeziapp.com/tv.exe Mac版本: https://j.yeziapp.com/tv.dmg 使用说明：选择自己需要的系统版本下载，下载好打开把界面上ID密码发我即可远程。]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019前端面试题总汇]]></title>
    <url>%2F2020%2F02%2F25%2F2019%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E6%B1%87%2F</url>
    <content type="text"><![CDATA[#前端面试题 2019各个公司前端面试题总汇 http相关1.https与http区别(百度) 1234567891011121314151617181920http是基于tcp协议的，https是基于ssl协议的，ssl协议在tcp协议的基础上的做了一层加密认证。https比http传输数据更安全，http是明文传递数据，不安全；而https传输数据经过加密。https需要证书来验证身份，证书需要购买，http不需要。https默认端口号是443，http默认是80。https不能向http发出请求。&lt;!-- more --&gt;了解https通讯过程：（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。（5）Web服务器利用自己的私钥解密出会话密钥。（6）Web服务器利用会话密钥加密与客户端之间的通信 2.http请求过程及拿到响应后的渲染过程？（苏宁） 12345678910111213141516171819202122232425262728http请求过程：1.浏览器检查当前请求的url是否存在强缓存？命中强缓存，则缓存中读取。2.dns解析： a.浏览器缓存的dns解析，是否存在。 b.操作系统DNS缓存中搜索 c.本地host进行dns解析。 d.向dns服务器发起请求进行dns解析3.建立tcp链接，三次握手。4.浏览器发出http请求5.服务器分析路由，处理请求，返回响应。6.浏览器接受响应，渲染页面，构建dom7。关闭tcp链接（4次挥手） 渲染过程：1.解析html文件，浏览器按照文档流顺序，构建dom树。（深度遍历，当所有子节点都构建好后，才会去构建当前节点的下一个兄弟节点）2.浏览器解析css形成css规则树。3.根据dom树和css规则树，构造出渲染树。 渲染树：浏览器可以知道网页中有那些节点，各个节点的css以及他们从属关系 4.遍历渲染树，计算每个节点位置大小信息，然后进行绘制。扩展：重绘 和 回流重绘：dom的一部分进行重画，不影响整体布局。触发：css背景色...回流：重新计算渲染树，重新遍历渲染树，重新渲染，浪费性能；触发：宽高、字体、resize等。优化：利用文档碎片document.createDocumentFragment并不是真正的dom，操作dom； 3.http缓存机制。(百度、滴滴都有问) 点击查看详细浏览器缓存技术，面试难不倒123456789101112131415161718192021222324252627282930强缓存： 响应报文头： catch-control：max-age=212121； 最长生效时常。 expires:服务器绝对时间 客户端发请求前，会用当前客户端时间与 （上次请求时间+max-age）进行比较，命中则走缓存。 expires是一个绝对时间，采用的是服务器的。客户端发送请求前，用客户端时间与这个时间进行比较，命中则走缓存。 max-age优先级比expires高，并且更加靠谱； 弱缓存（协商缓存）: 响应报文头: last-modified：最后一次修改时间 Etag：当前请求的资源生成的一个唯一标识，只要资源不一样这个串就不一样 请求报文头： if-modified-since:缓存中文件的最后修改时间 if-None-Match:缓存中文件的etag 客户端发出请求，携带if-modified-since，if-None-Match字段，服务器收到请求 与当前文件的最后修改时间和 重新生成etag进行比较，命中则返回304； 如果命中if-none-match，返回304的响应头中，会携带服务器最新生成的etag; 如果命中if-modified-since则304响应头中不会携带last-modified，因为最后修改时间没有改变。 注意：etag优先级比 last-modified要高。但是各有优缺点； 分布式系统里多台机器文件的last-modified必须保持一致，要不负载均衡到不同机器导致对比失败。 分布式系统计量关闭掉etag，因为每台服务器生成的etag都不一样。 使用：协商缓存需要配合强缓存使用， 4.http get和post区别？（马蜂窝） 1234567891011121314151617181920212223GET在浏览器回退时是无害的，而POST会再次提交请求。GET产生的URL地址可以被Bookmark，而POST不可以。GET请求会被浏览器主动cache，而POST不会，除非手动设置。GET请求只能进行url编码，而POST支持多种编码方式。GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。GET请求在URL中传送的参数是有长度限制的，而POST么有。get传送的数据量较小，不能大于2KB。post传送的数据量较大对参数的数据类型，GET只接受ASCII字符，而POST没有限制。GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。GET产生一个TCP数据包；POST产生两个TCP数据包对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 5.http状态码（百度，水滴筹，今日头条）123456789200 成功5** 服务器304 缓存301 永久重定向302 临时重定向400 Bad Request，通用的客户端错误状态，当其他4XX响应代码不适用时，就采用400401 权限不够访问该资源。404 not found 当客户端所请求的URI不对应于任何资源时，发送此响应代码，找不到资源。403 Forbidden 服务器拒绝访问 6.列举你所知道的请求头中的字段和响应头中的字段（美团，小米）123456789101112131415161718192021222324252627282930313233请求头Accept: application/json, text/javascript, */*; q=0.01 //告诉服务器,客户端支持的数据类型Content-Type: application/x-www-form-urlencoded; charset=UTF-8 //告诉服务器,发送的数据类型Origin: http://dev-mrytuan.chuchujie.com //源Referer: http://dev-mrytuan.chuchujie.com/ //源页面User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36// 浏览器信息cookie:&apos;&apos;, //cookie信息if-modified-since:xxxxx //上次请求响应头返回的最后修改时间if-none-match:xxx //上次请求响应头返回的etag信息options请求 Access-Control-Request-Method：，用来列出浏览器的CORS请求会用到哪些HTTP方法 Access-Control-Request-Headers：浏览器CORS请求会额外发送的头信息字段响应头：Access-Contronl-Allow-origin:* ，//允许源访问access-control-allow-methods：get ,post //允许请求方式access-control-allow-headers：&apos;name&apos; //允许携带的请求头access-control-expose-headers：&apos;name&apos; //允许浏览器读取的头信息access-control-allow-credentials:true //表示服务器允许浏览器携带cookie发送content-type: application/json 响应数据格式date: Tue, 02 Apr 2019 16:30:02 GMT //服务器时间catch-control:max-age=36000 //强缓存最强生效时长expires:xx-xx-xx //服务器失效绝对时间last-modified：xxx-xxx-xx //服务器最后修改时间etag：xxxxxx //服务器资源唯一标示符 options Access-Control-Max-Age：秒, 本次预检请求的有效期 7.复杂请求的与简单请求的区别 阮一峰详解 复杂请求 会比 简单请求多一个options请求（预检查请求）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849cors请求分两种:简单请求 和非简单请求==============================================简单请求： 浏览器请求头中会默认增加origin字段，表示来自哪个源 服务器接收请求后，根据指定的源作出回应。 响应头中：Access-Control-Allow-Origin:* || domain Access-Control-Allow-Credentials:true， //表示是否允许跨域携带cookie。（后续进行讲解） Access-Control-Expose-Headers：xxx //指定浏览器可以获取到的 自定义响应头============================================= 非简单请求： 出现条件：请求方法是PUT或DELETE， Content-Type字段的类型是application/json 增加额外的header字段； 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;options请求（preflight） 浏览器发出options请求头： origin:源 Access-Control-Request-Method：，用来列出浏览器的CORS请求会用到哪些HTTP方法 Access-Control-Request-Headers：浏览器CORS请求会额外发送的头信息字段 服务器返回options响应头： Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT 服务器支持的所有跨域请求的方法 Access-Control-Allow-Headers: X-Custom-Header 表示服务器支持的所有头信息字段 Access-Control-Max-Age：秒, 本次预检请求的有效期 服务器如果否定了options请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。浏览器就 会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。 ==================================== withCredentials属性 cors请求不发送cooki，如果要发送cookie到服务器，一方面要服务器同意。 Access-Control-Allow-Origin：不能设置*号，必须指定和明确的、与请求网页一致的域名 Access-Control-Allow-credentials：true；//这个只能设为true；如果不需要cookie，则删除该字段即可。 另一方面，浏览器ajax需要打开 withCredentials var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 特点：Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传， 且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 a.com 请求b.com ，设置了此属性，携带的cookie也只能是b.com 这个域下的cookie； 8.http2 和http1.1的区别 123456789[区别详解](https://juejin.im/post/5a4dfb2ef265da43305ee2d0)1.首部压缩，使报头更紧凑，更快速传输2.多路复用，在HTTP1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制。超过限制数目的请求会被阻塞http2中，只使用一个链接即可并行发送多个请求和响应，而且互不影响3.支持服务器推送如果一个请求是由你的主页发送的，服务器可能会响应主页内容、logo以及样式表，因为他知道客户端会用到这些东西。这样不但减轻了数据传送冗余步骤，也加快了页面响应的速度，提高了用户体验。 js基础相关1.js继承？原型链查找原理。（蚂蚁金服）12345678function inheritPrototype(subType, superType)&#123; // 继承父类的原型 var prototype = Object.create(superType.prototype); // 重写被污染的construct prototype.constructor = subType; // 重写子类的原型 subType.prototype = Object.assign(prototype, subType.prototype); &#125; 2.es6 class继承如何实现？（蚂蚁金服） 3.var let const 区别 （基本每个公司都问） 4.promise的特点，使用及原理。（基本每个公司都问） 手写promise123456789101112131415161718192021222324特点：then链式调用 catch捕获 all方法 race方法 promise对象三种状态 pendding,fulfilled,rejected; 状态改变，只能改一次； promise对象已经是成功状态或是失败状态时，都可以继续通过then传入函数，会通过当前的状态，来决定执行成功还失败，并且把结果或是错误传给相应的函数。 原理：状态机 + then方法返回新的promise2对象实现链式调用；使用new promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; resolve(&apos;成功&apos;) &#125;)&#125;).then(()=&gt;&#123;&#125;,()=&gt;&#123;&#125;).catch(e=&gt;&#123;&#125;)Promise.all([promise1,promise2]).then();Promise.race([promise1,promise2]).then();Promise.resolve(1)Promise.reject(1)Promise.deferred(); 5.generator函数的使用及原理 （蚂蚁金服） generator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273generator 函数可以控制函数的执行，类似将函数分割成多个小函数，依次执行；用 * 表示一个generator 函数，用 yield 控制函数执行，并且产出；generator是有两部分组成；* 表示 的函数 是生成器，函数执行的返回结果是迭代器；迭代器.next();会将yield的值 返回，&#123;value:&apos;返回值&apos;，done：&apos;是否迭代完成&apos;&#125;使用：function *read()&#123; console.log(1); var content1 = yield &apos;qs&apos;; console.log(content1); var content2 = yield &apos;9&apos;;![图片描述][1] console.log(content2); return content2;&#125;var it = read();var a = it.next() //输出 1 a:&#123;value:&apos;qs&apos;,done:false&#125;var b = it.next(&apos;hello&apos;)//输出hello b:&#123;value:&apos;9&apos;,done:false&#125;var c = it.next(&apos;generator&apos;)//输出generator c:&#123;value:&apos;generator&apos;,done:true&#125;var d = it.next(&apos;123&apos;)//输出generator c:&#123;value:undefined,done:true&#125;console.log(a,b,c,d)使用：一般和promise结合使用；function *g()&#123; let result1 = yield ajax(&apos;1&apos;); let result2 = yield ajax(result1); return result2;&#125;let ite = g();ite.next().value.then(res=&gt;&#123; ite.next(res).value.then(res=&gt;&#123; let result = ite.next(res).value; console.log(result) &#125;)&#125;)//为了更好的结合promise使用，出现了co库；//把一个生成器函数的迭代器，迭代完成后，统一执行一个成功回调；let co = require(&apos;co&apos;);function *g()&#123; let result1 = yield ajax(&apos;1&apos;); let result2 = yield ajax(result1); return result2;&#125;co(g).then(res=&gt;&#123;console.log(res)&#125;);//co库的原理：利用next产出值的done的状态，去判断是否需要再次递归执行next方法。function co(g)&#123; let ite = g(); return new Promise((resolve,reject)=&gt;&#123; function next(data)&#123; let &#123;value,done&#125; = item.next(data) if(!done)&#123; value.then(res=&gt;&#123; next(res) &#125;,reject) &#125;else&#123; resolve(value) &#125; &#125; next(); &#125;)&#125; 6.es6 解构赋值和数组的操作方法 7.讲一下js循环事件池event loop，微任务和宏任务 （boss直聘、小米，苏宁） 浏览器event loop 和node event-loop 浏览器的event loop1234567891011121314151617js执行会存在一个执行栈，当前执行的同步代码都会放到执行栈中执行(宏任务)；同步代码执行过程中，如果遇到异步代码（settIimeout、promise等）,会将他们挂起，继续执行同步代码；同步代码执行完毕后，执行栈清空，会去查看微任务队列是否有可执行函数，然后拿到执行栈执行；当微任务队列执行完成后， 会去宏任务取一个任务放到执行栈执行，执行完成后再去查看微任务是不是有可执行函数，有的话取到执行栈执行；如此循环下去，就是event loop；挂起的异步代码，可执行后，会放到异步任务队列；异步任务队列分为两种队列，一种是微任务(promise,process.nextTick)一种是宏任务（setTimeout等）；微任务包括 process.nextTick ，promise ，MutationObserver。宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。过程：执行完主执行线程中的任务。取出Microtask Queue中任务执行直到清空。取出Macrotask Queue中一个任务执行。取出Microtask Queue中任务执行直到清空。重复3和4。 node环境 event loop 是区分阶段的； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152按照我们的循环的6个阶段依次执行，每次拿出当前阶段中的全部任务执行，清空NextTick Queue，清空Microtask Queue。再执行下一阶段，全部6个阶段执行完毕后，进入下轮循环。即：清空当前循环内的Timers Queue，清空NextTick Queue，清空Microtask Queue。清空当前循环内的I/O Queue，清空NextTick Queue，清空Microtask Queue。清空当前循环内的Check Queu，清空NextTick Queue，清空Microtask Queue。清空当前循环内的Close Queu，清空NextTick Queue，清空Microtask Queue。进入下轮循环。*注意：如果在timers阶段执行时创建了setImmediate则会在此轮循环的check阶段执行，如果在timers阶段创建了setTimeout，由于timers已取出完毕，则会进入下轮循环，check阶段创建timers任务同理。console.log(&apos;1&apos;);setTimeout(function() &#123; console.log(&apos;2&apos;); new Promise(function(resolve) &#123; console.log(&apos;4&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;5&apos;); setTimeout(function()&#123;console.log(11)&#125;) &#125;) process.nextTick(function () &#123; console.log(10) &#125;) setImmediate(function () &#123; console.log(12) &#125;)&#125;,500);setTimeout(function() &#123; console.log(&apos;6&apos;); new Promise(function(resolve) &#123; console.log(&apos;7&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;8&apos;) &#125;) process.nextTick(function () &#123; console.log(9) &#125;)&#125;,500)// 第一次事件环//timer 阶段 1，2，4，6，7，; nexttick:10,9;//微任务队列 5，8//io 阶段 无//check 阶段 12//close 阶段 无//第二次事件环//timer 阶段 11;//io 阶段 无//check 阶段//close 阶段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455两种环境对比：console.log(&apos;1&apos;);setTimeout(function() &#123; console.log(&apos;2&apos;); new Promise(function(resolve) &#123; console.log(&apos;4&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;5&apos;); setTimeout(function()&#123;console.log(100)&#125;) &#125;)&#125;,500) setTimeout(function() &#123; console.log(&apos;6&apos;); new Promise(function(resolve) &#123; console.log(&apos;7&apos;); resolve(); &#125;).then(function() &#123; console.log(&apos;8&apos;) &#125;)&#125;,500)浏览器执行：1，2，4，5，6，7，8 100node1，2，4，6，7，5，8，100；console.log(1);setTimeout(()=&gt;&#123; console.log(2)&#125;)process.nextTick(()=&gt;&#123; console.log(3)&#125;)setImmediate(()=&gt;&#123; console.log(4)&#125;)new Promise((resolve,reject)=&gt;&#123; console.log(5); resolve(); console.log(6)&#125;).then(()=&gt;&#123; console.log(7)&#125;)//代码从上往下往下执行：// 1,5,6 同步执行；然后查看nextTick,输出3；然后查看微任务列表，输出7；输出7//然后timmer 阶段：输出2，无nextTick 无微任务// 然后io阶段，无//然后check阶段：Immediate执行输出 4；// 然后close阶段，无 8.js的垃圾回收处理机制的原理？（马蜂窝，美团） (垃圾处理机制)[https://www.cnblogs.com/guoyongfeng/p/3907994.html]12345678910111213141516171819202122232425不再用到的内存（一个不用到的值）没有及时释放，就叫做内存泄漏（memory leak）。垃圾回收机制：引用计数最常使用的方法叫做&quot;引用计数&quot;（reference counting）：语言引擎有一张&quot;引用表&quot;，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了var arr = [1,2,3,4]数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存;就会造成内存泄漏arr = null;如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。垃圾回收机制:标记清除：js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为&quot;进入环境&quot;，从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为&quot;离开环境&quot; 9.localstorage、sessionStorage 、cookie区别？（水滴） 二级域名是否可以取到一级域名的数据？cookie是可以的 ，只要在一个主域即可localstorage不可以，他是跨站点的，只要域名变了就取不到了。 10.什么是闭包，说下项目中应用场景？（水滴）123456789101112131415161718192021222324252627282930313233343536373839闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 场景： 1.可以实现公有变量，函数外或在其他函数中访问某一函数内部的参数 function add() &#123; var num = 0; function demo()&#123; num++; console.log(num); &#125; return demo; &#125; var test = add(); test();//1 test();//2 2.为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点3.计数器 function checkCount(target)&#123; let count = 0; let callbacks = []; return function(fn)&#123; count++; if(count == target)&#123; callbacks.forEach(fn=&gt;fn()) &#125;else&#123; callbacks.push(fn) &#125; &#125; &#125; let d = checkCount(3); d(fn); d(fn); d(n) 4.函数节流和防抖 11.ajax工作原理？ 12345678910111213141516171819202122232425262728var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;,&apos;/api&apos;,true);//true表示异步xhr.onreadystatechange = function() &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText) &#125;&#125;xhr.send();步骤：1.创建xhr请求对象 2.创建http请求 3.监听状态变化 4.根据状态码处理结果, ⑴未初始化状态。在创建完XMLHttpRequest对象时，该对象处于未初始化状态，此时XMLHttpRequest对象的readyState属性值为0。 ⑵初始化状态。在创建完XMLHttpRequest对象后使用open()方法创建了HTTP请求时，该对象处于初始化状态。此时XMLHttpRequest对象的readyState属性值为1。 ⑶发送数据状态。在初始化XMLHttpRequest对象后，使用send()方法发送数据时，该对象处于发送数据状态，此时XMLHttpRequest对象的readyState属性值为2。 ⑷接收数据状态。Web服务器接收完数据并进行处理完毕之后，向客户端传送返回的结果。此时，XMLHttpRequest对象处于接收数据状态，XMLHttpRequest对象的readyState属性值为3。 ⑸完成状态。XMLHttpRequest对象接收数据完毕后，进入完成状态，此时XMLHttpRequest对象的readyState属性值为4。此时接收完毕后的数据存入在客户端计算机的内存中，可以使用responseText属性或responseXml属性来获取数据。 只有在XMLHttpRequest对象完成了以上5个步骤之后，才可以获取从服务器端返回的数据。因此，如果要获得从服务器端返回的数据，就必须要先判断XMLHttpRequest对象的状态 5.发送请求 12.js事件代理？（传智播客，58，瓜子二手车）1234567891011121314151617181920212223242526事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。jquery:$(&quot;#nav&quot;).on(&apos;click&apos;,function(e)&#123; $(e.target) =&gt;是每个点击的项目 $(this) =&gt;nav&#125;)$(&apos;#nav&apos;).on(&apos;click&apos;,&apos;li&apos;,function()&#123; $(this) =&gt;点击的每一项&#125;);扩展 jsdom事件流阶段： 捕获阶段-&gt;目标阶段-&gt;冒泡阶段 外内 -&gt; 当前 -&gt;冒泡 如何执行冒泡 在捕获？ 在捕获阶段的函数暂缓执行，等冒泡执行完后在执行捕获函数。 13.js中this是如何工作的（基本都问） 14.怎么判断引用数据类型？（为什么能用Object.prototype.toString.call()去判断？）（水滴） 1234567891011121314151617181920212223242526271.instanceof 判断不准确var a = [];a instanceof Array truea instanceof Object true 2.Object.prototype.toString.call([]) &apos;[object Array]&apos; Object.prototype.toString.call(&#123;&#125;) &quot;[object Object]&quot; 3.isPrototypeOfArray.prototype.isPrototypeOf([]) trueObject.prototype.isPrototypeOf([]) true isPrototypeOf 与instanceOf一样 都是查找原型链上是否存在。4.[].constructor == Array.prototype.constructor扩展：Array.toString == Function.prototype.toString true，根据原型链查找，查到Function.prototype.toString就停了。不会查到Object.prototype[].toString == Array.prototype.toString true.根据原型链查找，查到Array.prototype.toString就停了。不会查到Object.prototypeArray,Function 都在各自的原型上重新定义了toString方法，阻断了查找。 15.js变量提升和作用域查找？1234567891011121314151617181920212223242526console.log(type a) //undefined 变量提升console.log(type b) //err:b is not defined ,后续代码不执行console.log(type c) var a = function()&#123;return true&#125;; //变量提升window.b = function()&#123; //给window创建属性，不存在变量提升 return true;&#125;console.log(a() &amp;&amp; b() &amp;&amp; c())function c()&#123;return c&#125;var o = &#123; a:1, f()&#123; return this.a; &#125;&#125;console.log(o.f()); //1var o1 = o;console.log(o1.f());//1var o2 = o.f;console.log(o2()); //undefined =&gt;this是window，window.a undefined;o.a= 5;console.log(o1.f());//5 堆内存 和 栈内存var o3 = &#123;a:5&#125;; console.log(o.f.call(o3)) //5 16.call apply bind 区别？如何实现？（基本都问） 17.实现跨域的方法？说一下JSOP的原理？（水滴）（nginx服务器反向代理)[https://segmentfault.com/a/1190000012859206](postMessage + iframe实现页面跨域)[http://www.cnblogs.com/zhouzme/p/5758386.html]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566jsonp; 利用script标签src属性不受同源策略影响，可实现跨域； 通过与api方，对接好 回调参数字段～ cb=fn,fn在前端是一个全局的方法。后端返回script代码&quot;fn(&#123;name:1&#125;)&quot;,浏览器会执行； 前端代码： function b(data) &#123; console.log(data) &#125; let script = document.createElement(&apos;script&apos;) script.src = &quot;http://localhost:3002/jsonp?cb=b&quot;; document.body.appendChild(script) node模拟后端： http.createServer((req, res) =&gt; &#123; let &#123;pathname, query&#125; = url.parse(req.url, true); if (pathname == &apos;/jsonp&apos;) &#123; let school = JSON.stringify(&#123;name:&apos;zfpx&apos;&#125;); // res.end(`var a = $&#123;school&#125;`) //在全局就可以获取到 变量a // res.end(`b($&#123;school&#125;)`) res.end(`$&#123;query.cb&#125;($&#123;school&#125;)`) return ; &#125; &#125;).listen(port, () =&gt; &#123; console.log(`$&#123;port&#125; 服务器启动`) &#125;);CORS 服务端响应： res.setHeader(&apos;Access-Control-Allow-Origin&apos;,&quot;*&quot;);//设置允许访问的源 res.setHeader(&apos;Access-Control-Allow-Methods&apos;,&apos;GET,POST,PUT,DELETE,OPTIONS&apos;) res.setHeader(&apos;Access-Control-Allow-headers&apos;,&apos;name&apos;)nginx服务器反向代理 //前端a.com 请求 后端api b.com/login 会出现跨域， //在a.com所在服务器启动一个nginx代理服务器，监听a.com 的80端口； //配置代理规则 ^/apis/ =&gt; b.com/ , //这让我们在请求a.com/apis/login 的时候，被nginx拦截，代理到 b.com/login 处理页面之间的跨域window.name+iframe 需要目标服务器响应window.name。window.location.hash+iframe 同样需要目标服务器作处理。html5的 postMessage+ifrme 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。a.com/index.html &lt;iframe src=&quot;b.com/index.html&quot; id=&quot;a&quot;&gt; var data= &#123;name:1&#125; document.getElementById(&quot;a&quot;).contentWindow.postMessage(data, &apos;*&apos;); window.addEventListener(&apos;message&apos;,function(data)&#123; &#125;) b.com/index.html注册监听消息事件：window.addEventListener(&apos;message&apos;,function(data)&#123; &#125;) //向父页面post消息window.parent.postMessage(&#123; &#125;, &apos;*&apos;); 18.正则相关（小米,boss，头条）1234a.正则捕获规则b.如果是嵌套捕获，得到的顺序是什么样的。c.正则捕获的引用和反向引用是什么d.正则的匹配默认是贪婪匹配么 19.[].toString()为啥会返回逗号隔开的字符串 20.数据proxy劫持与defineProperty对比。defineProperty 和 proxy 对比123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109es5defineProperty:修改或者定义一个对象的新属性， 返回这个对象1.不能监听数组变化 push, pop, shift, unshift,splice, sort, reverse，这些能修改原数组的方法成为变异方法；vue的做法是把这些方法重写来实现数组的劫持；2.必须遍历对象的每个属性，单独设置；Object.keys(obj).forEach(key =&gt; &#123; Object.defineProperty(obj, key, &#123; // ... &#125;)&#125;)3.必须深层遍历嵌套对象vue的深度劫持；知识：基础描述符configrable:false,默认false,表示该属性是否可以修改 描述符配置；enumerable:false,默认false，表示该属性是否可以枚举设置和获取描述符set(newval)&#123;&#125;get()&#123;&#125;赋值描述符value:&apos;&apos;,writable:false,表示值是否可被修改，默认false设置和获取描述符和赋值描述符，只能有一个出现，基础描述符可以一直存在。============================es6proxy 代理，将一个对象进行包装，从而可以代理 操作对象的一些行为；1.针对对象:针对整个对象,而不是对象的某个属性; 不用 遍历属性；let obj = &#123; name: &apos;Eason&apos;, age: 30&#125;let handler = &#123; get (target, key, receiver) &#123; console.log(&apos;get&apos;, key) return Reflect.get(target, key, receiver) &#125;, set (target, key, value, receiver) &#123; console.log(&apos;set&apos;, key, value) return Reflect.set(target, key, value, receiver) &#125;&#125;let proxy = new Proxy(obj, handler)proxy.name = &apos;Zoe&apos; // set name Zoeproxy.age = 18 // set age 18// Reflect.get 和 Reflect.set 可以理解为类继承里的 super，即调用原来的方法Reflect.get():获取对象身上某个属性的值，类似于 target[name]。Reflect.set():将值分配给属性的函数,返回一个Boolean，如果更新成功，则返回true。2.支持数组:不需要对数组的方法进行重载，省去了众多 hacklet arr = [1,2,3]let proxy = new Proxy(arr, &#123; get (target, key, receiver) &#123; console.log(&apos;get&apos;, key) return Reflect.get(target, key, receiver) &#125;, set (target, key, value, receiver) &#123; console.log(&apos;set&apos;, key, value) return Reflect.set(target, key, value, receiver) &#125;&#125;)proxy.push(4)// 能够打印出很多内容// get push (寻找 proxy.push 方法)// get length (获取当前的 length)// set 3 4 (设置 proxy[3] = 4)// set length 4 (设置 proxy.length = 4)3.嵌套支持: get 里面递归调用 Proxy 并返回let obj = &#123; info: &#123; name: &apos;eason&apos;, blogs: [&apos;webpack&apos;, &apos;babel&apos;, &apos;cache&apos;] &#125;&#125;let handler = &#123; get (target, key, receiver) &#123; console.log(&apos;get&apos;, key) // 递归创建并返回 if (typeof target[key] === &apos;object&apos; &amp;&amp; target[key] !== null) &#123; return new Proxy(target[key], handler) &#125; return Reflect.get(target, key, receiver) &#125;, set (target, key, value, receiver) &#123; console.log(&apos;set&apos;, key, value) return Reflect.set(target, key, value, receiver) &#125;&#125;let proxy = new Proxy(obj, handler)// 以下两句都能够进入 setproxy.info.name = &apos;Zoe&apos;proxy.info.blogs.push(&apos;proxy&apos;) 21.js为什么要有protoType？如果没有会怎么样？(阿里) 22.generator函数？跟async有什么区别？（阿里） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374generator函数？跟async有什么区别？ async函数实际上是通过gnnerator函数实现的,实际上就是将一个generator函数自动执行的结果； generator 需要配合 co这样的库，才方便调用； async 是结合了co和generator的思想，实现的 ； async function fn()&#123; let content1 = await ajax(&apos;1&apos;); let content2 = await ajax(&apos;2&apos;); return content2; &#125; fn().then(res=&gt;&#123; //可以获取到content2 &#125;) 实际上实现的原理： function co(g)&#123; let ite = g(); return new Promise((resolve,reject)=&gt;&#123; function next(data)&#123; let &#123;value,done&#125; = ite.next(data); if(!done)&#123; if(value instanceOf Promise)&#123; value.then(res=&gt;&#123; next(res); &#125;,reject) &#125;else&#123; next(value) &#125; &#125;else&#123; resolve(value) &#125; &#125; next() &#125;) &#125; function fn()&#123; return co( function *()&#123; let content1 = yield ajax(&apos;1&apos;); let content2 = yield ajax(&apos;2&apos;); return content2; &#125;) &#125; ` 23.mouseover和mouseenter的区别```$javascriptmouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseoutmouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave 阮一峰es6要点总结——Proxy HTML+CSS相关1.meta标签常用有哪些，列举？viewport属性有哪些分别代表什么（水滴）1234567891011121314151617181920忽略页面中数字识别为电话 忽略email识别&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;关键字&lt;meta name=&quot;keywords&quot; content=&quot;楚楚推，楚楚推平台&quot;&gt;网页描述&lt;meta name=&quot;description&quot; content=&quot;楚楚推，分享生活，分享爱。&quot;&gt;允许加载哪个域的资源，防止xss攻击&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; viewport虚拟窗口 width：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。 height：和 width 相对应，指定高度。 initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。 maximum-scale：允许用户缩放到的最大比例。 minimum-scale：允许用户缩放到的最小比例。 user-scalable：用户是否可以手动缩放&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; 2.清除浮动方法？（水滴） 12345678910111213a.添加空div，增加clear：both属性 b.给父元素定义overflow：hidden，氟元素必须设置width c:给父元素增加伪元素 .clearfix:after &#123; clear: both; content: &apos;&apos;; font-size: 0; display: block; visibility: hidden; height: 0; &#125; 3.口述css盒子模型（水滴） 1234content-box: 可以使设置的宽度和高度值应用到元素的内容框，盒子的width只包含内容。即总宽度=margin+border+padding+widthborder-box: 设置的width值其实是除margin外的border+padding+element的总宽度，盒子的width包含border+padding+内容；即总宽度=margin+width 4.实现左右固定宽度中间自适应布局有哪几种？（水滴） a. 最外层元素 {padding:0 200px}; 所有子元素都向左浮动 第一个子元素：width：100%；float：left 第二个子元素：width：200px;float:left;margin-left:-100%;position:relative;left:-200px; 第三个子元素：width：200px;float:left;margin-left:-200px;position:relative;left:200px; b. 前两个子元素浮动，第三个子元素通过margin来控制宽度； c. flex布局； 5.position属性有哪几种，区别？（水滴） static、relative、absolute、fixed。 6.左侧固定宽度，右侧自适应？ 多种。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162a.左侧设置固定宽并且左浮动，右侧加个margin-left;.box1&#123; background: red; width: 200px; float: left;&#125;.box2&#123; background: darkcyan; margin-left: 200px;&#125;b.calc 计算右侧宽度,右浮动.box1&#123; background:red; width:200px; float:left;&#125;.box2&#123; background:green; width:cacl(100% - 200px) float:right;&#125;c.flex布局.outer&#123; display:flex; flex-direction:row; &#125;.box1&#123; width:200px; background:red&#125;.box2&#123; flex:1; background:green;&#125;d.左侧设置固定宽并且左浮动，右侧加overflow：hidden； .box1&#123; background:red; width:200px; float:left; &#125; .box2&#123; background:green; overflow:hidden; &#125; e.absolute+margin 左侧设置固定宽并且绝对定位，右侧加margin-left； .box1&#123; background:red; width:200px; position:absolute; left:0; &#125; .box2&#123; background:green; margin-left:200px; &#125; 7.用css实现一个三角形，为什么？123456.triangle &#123; width : 0; height: 0; border : 100px solid transparent; border-top : 100px solid blue; /*这里可以设置border的top、bottom、left、right四个方向的三角*/&#125; 8.div垂直水平居中，多种方式（宽高不限） 1234567891011121314151617181920212223242526272829.box1&#123; position: absolute; top: 50%; left: 50%; margin-left: -100px; margin-top: -100px; &#125; .box1&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); &#125; .box1&#123; position: absolute; top:0; left: 0; right: 0; bottom: 0; margin: auto; &#125; .parent&#123; display: flex; justify-content: center; align-items: center; height: 100%; &#125; 9.img i iframe video canvas q ol nav form em dl dt dd br hr audio abbr spanstrong sub textarea 那些是块？ 10.块元素 和行内元素有哪些?12345678910111213141516常用的 div ul li p h1 span i img input a em textarea快元素：独占一行；自上至下；可设置狂傲行内元素：不独占一行；自左至右；设置宽高无效；设置margin padding，上下方向无效可继承：font相关 font-size family weight font-style line-height text-align text-indent 文本缩进 color 字体颜色 word-spacing字间隔 11.css高度宽度分别为视窗的20%的盒子12第一种:width:20%;padding-bottom:20%;第二种：width:20vw;height:20vw 前端框架相关1.什么是mvvm？mvvm实现原理？ 12345678910111213双向数据绑定M 数据层V 视图层VM View-Modle层，主要用于数据和视图的通讯利用Object.definedProperty 对data属性的get 和set 进行拦截和监听，并对每个data属性创建一个订阅池。在编译dom阶段，对dom进行解析，&quot;v-**&quot; &quot;&#123;&#123;&#125;&#125;&quot;，每编译到一处， 完成首次渲染，而且注册一个监听者，添加到data属性的订阅池中。数据影响视图：当数据改变，则通知该属性对应订阅池中所有的watcher，进行更新。视图影响数据(v-model): 通过绑定事件，然后改变data属性值，data属性值发生改变，通知所有watcher更新视图。设计思想：发布订阅模式，es6 definedProperty拦截。某一个属性，具备多个watcher，存入到一个dep中。当属性变化，才会去执行dep中的watcher。是由被监听属性（目标属性所触发），所以属于观察者模式。 2.vue兄弟组件传递数据？1234567891011父传子：通过给子组件绑定属性传值，:data=&quot;&quot;。子组件接收通过props设置接收的属性。子传父：通过事件传值，给子组件绑定事件，@事件名=&quot;父组件方法&quot;,子组件改变了数据，通过this.$emit(事件名,data)通知父组件。兄弟组件传值:中间件1.创建一个单独的vm实例。通过vm.$on(&apos;事件名&apos;,方法)绑定事件通过vm.$emit(事件名，data)通知兄弟组件修改数据。2.合并到同一个父组件下，通过父组件进行传值。3.vuex 3.vuex的使用场景？如何使用？原理？（阿里）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121应用场景:非父子关系的组件通信及共享数据，例如兄弟组件、祖孙组件。当你打算开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态 1.组件销毁，仍想保留数据，再进渲染组件直接获取数据。 举例：form表单弹窗组件，用户填写信息后，关闭弹窗。可在组件destroyed 时将用户填写信息保存到state中。在created时，读取state中数据进行渲染 2.有些组件构建和加载是依赖异步数据。v-if=&quot;&#123;&#123;store.userInfo.vip&#125;&#125;&quot; 举例：有几个组件是与用户等级挂钩的，用户等级不同，展示的组件不同，并且这些组件 都在不同的父组件中。 可以将异步请求数据的方法和请求回来的数据保存到state中，集中管理调用。 这样异步请求结束，所有的组件就都能得到状态，从而进行渲染。 3.多处共用数据，多处可更改数据，互相影响。举例：购物车，详情页添加、删除，购物车页面添加删除 消息列表消息数量 订单相关跳转路由，订单列表跳转订单详情，订单详情跳转订单评价， 不同路由之间订单数据共享。 ============================================如何使用：============================================原理:1.全局注入store：vuex 利用插件机制调用install进行安装vuex，install过程中利用mixin混入，全局注册混入对象，将会影响所有之后创建的Vue实例。混入 beforeCreate 钩子，每个实例生成都会先调用混入的beforeCreate钩子（vuexInit），vueInit检查当前options中是否有store对象，如果没有则会去父组件中查找。a. Vue.use(Vuex) =&gt;安装Vuex插件,调用Vuex的install方法。b. Vuex.install = function()&#123; Vue.mixin(&#123; beforeCreate: vuexInit &#125;);&#125;store注入 vue的实例组件的方式，是通过vue的 mixin机制，借助vue组件的生命周期钩子beforeCreate 完成的。即 每个vue组件实例化过程中，会在 beforeCreate 钩子前调用 vuexInit 方法。c.vuexInit核心代码如下：this.$store = typeof options.store === &apos;function&apos; ? options.store() : options.store this的指向，得益于mixin机制，this将指向 vue组件实例！最终，我们可以再vue组件实例上获得vuex的store 对象的引用 $store！源码：function applyMixin (Vue) &#123; var version = Number(Vue.version.split(&apos;.&apos;)[0]); if (version &gt;= 2) &#123; Vue.mixin(&#123; beforeCreate: vuexInit &#125;); &#125; else &#123; var _init = Vue.prototype._init; Vue.prototype._init = function (options) &#123; if ( options === void 0 ) options = &#123;&#125;; options.init = options.init ? [vuexInit].concat(options.init) : vuexInit; _init.call(this, options); &#125;; &#125; function vuexInit () &#123; var options = this.$options; if (options.store) &#123; this.$store = typeof options.store === &apos;function&apos; ? options.store() : options.store; &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; this.$store = options.parent.$store; &#125; &#125;&#125;2.数据响应式，state 和 getter数据更新如何映射到各个组件实例中自动更新，并update组件。某一组件store更新时，如何通知其他组件进行数据更新，和UI更新！通过简单分析可知，问题的根本就是组件通信的问题！原理：vuex的state是借助vue的响应式data实现的，getter是借助vue的computed属性实现的。在 new Vuex.Store(&#123;state,getters&#125;)实例过程中，Store的构造函数执行了这样一个函数 resetStoreVM(this, state); this-&gt;store实例，就是我们用到的this.$store作用: 初始化了一个vue实例_vm。 将state注入到该实例中，由于vue的data是响应式的，所以$$state 是响应式的。当我们在更改this.$store.state.xxx时，基于vue的data的响应式机制，所有相关的state.xxx的值都会自动更新，ui自动更新。 将store.getters作为computed属性注入到_vm上，然后将store.getter映射出一个新的对象，定义get拦截去获取_vm.xxx; 实际应用中,我们修改this.$store.state.xxx =&gt; this.$store._vm.data.$$state =&gt; store._vm.$$stateget state () &#123; return this._vm._data.$$state &#125;实际应用中，我们获取getter属性， this.$store.getters.xxx ,实际上取得的 this.$store._vm.xxx 取得是_vm的计算属性 源码: function resetStoreVM (store, state, hot) &#123; //处理getter store.getters = &#123;&#125;; var wrappedGetters = store._wrappedGetters; var computed = &#123;&#125;; forEachValue(wrappedGetters, function (fn, key) &#123; computed[key] = function () &#123; return fn(store); &#125;; Object.defineProperty(store.getters, key, &#123; get: function () &#123; return store._vm[key]; &#125;, enumerable: true // for local getters &#125;); &#125;); //创建vue实例，响应数据 store._vm = new Vue(&#123; data: &#123; $$state: state &#125;, computed: computed &#125;); &#125; &#125; 4.用vue-router实现导航切换 类似tab栏的那种；（一个tab有三个页，下面展示的内容怎么组件实现） 5.vue和react区别 区别 6.vue 的watch中可以使用箭头函数吗 12不能使用,箭头函数在声明时就确定了this指向，指向的是父级作用域上下文。当函数执行时，里面的this并不是vue实例。 7.vue自定义组件的双向绑定怎么实现？ 12345678910111213141516171819一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件;&lt;search-input v-model=&quot;text&quot;&quot;&gt;&lt;/search-input &gt;等价于&lt;search-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot;&gt;&lt;/search-input &gt; 所以 在组件内部的input标签上，就不能用v-model了为了让它正常工作，这个组件内的 &lt;input&gt; 必须：将其 value 特性绑定到一个名叫 value 的 prop 上在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出Vue.component(&apos;custom-input&apos;, &#123; props: [&apos;value&apos;], template: ` &lt;input v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; `&#125;) 8.mvc和mvvm的区别，手画一个原理流程图，类似view model viewmodel的一个流程交互图 9.v-if 和 v-show的区别12v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏,首次渲染消耗大，适合频繁切换v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果，。具备懒惰性，不适合频繁切换，首次消耗小。 10.v-if跟 v-else，如果太多了你可以怎么优化，可以用什么设计模式 11.的作用是什么?12345678910&lt;keep-alive&gt;&lt;/keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用&lt;keep-alive&gt;&lt;/keep-alive&gt;进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染.使用了 keep-alive组件的两种状态 actived 组件被激活时调用，deactived 组件被移除时调用 12.mixin 全局混入 vue官方混入12345678910111213141516171819202122232425262728混入规则： 混入内容值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 混入的是钩子函数时 created...等，同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 特点：mixin中的this指的 当前vue实例。 全局混入： 每个vue实例都混入该对象，包括组件的实例。 Vue.mixin(&#123; created:function()&#123; this.$options.xxx &#125; &#125;) new Vue(&#123; el:xxx &#125;) 局部混入:只在当前实例混入 var mixin = &#123; data()&#123; return &#123; name:1 &#125; &#125; &#125; new Vue(&#123; mixins:[mixin] &#125;) 13.vue插件 12345678910111213141516171819202122232425262728293031323334353637383940414243插件通常会为 Vue 添加全局功能。插件的范围没有限制——一般有下面几种：添加全局方法或者属性，如: vue-custom-element添加全局资源：指令/过滤器/过渡等，如 vue-touch通过全局 mixin 方法添加一些组件选项，如: vue-router添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。开发:let myplugin = &#123;&#125; myplugin.install= （Vue,optiosn）=&gt;&#123; //增加全局方法或者属性，Vue类调用的 Vue.globalMethod = ()=&gt;&#123; &#125; // // 2. 添加全局资源，全局指令 全局过滤器等 Vue.directive(&apos;my-directive&apos;, &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件，混入对象等，比如vue-router vuex Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125;, conponents:&#123;&#125; ... &#125;) //4.添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125; //&#125;使用：Vue.use(myplugin);use方法会自动调用myPlugin.install并且传入Vue这个类 14.Vue.extend 和 Vue.component区别 1234567891011121314151617181920212223242526272829303132Vue.component// 注册组件，传入一个扩展过的构造器Vue.component(&apos;my-component&apos;, Vue.extend(&#123; /* ... */ &#125;))// 注册组件，传入一个选项对象 (自动调用 Vue.extend)Vue.component(&apos;my-component&apos;, &#123; /* ... */ &#125;)// 获取注册的组件 (始终返回构造器)var MyComponent = Vue.component(&apos;my-component&apos;)注册组件，不管是Vue.component() 或者 局部components&#123;&#125;,都可 传入组件选项或者组件构造器；=============================================Vue.extend //使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。// 是需要new的，或者通过 Vue.component注册组件，或者 注册局部组件 components:&#123;构造器&#125;var Profile = Vue.extend(&#123; template: &apos;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&apos;, data: function () &#123; return &#123; firstName: &apos;Walter&apos;, lastName: &apos;White&apos;, alias: &apos;Heisenberg&apos; &#125; &#125;&#125;)// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount(&apos;#mount-point&apos;)new Profile(&#123;el:&apos;#mount-point&apos;&#125;) 15.vue插件机制 封装组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556只用于渲染页面的组件使用：Vue.use(search)全局就会可以用 &lt;search-input&gt;&lt;/search-input&gt;import _search from &apos;./search.vue&apos;search.install = function(Vue,options)&#123; let searchPlugin = Vue.extend(_search) //1.通过注册全局组件的方式 Vue.component(&apos;search-input&apos;,searchPlugin) Vue.component(&apos;search-input&apos;,_search) //2.通过Vue.mixin 全局混入的方式 Vue.mixin(&#123; components:&#123; &apos;search-input&apos;:_search &#125; &#125;) Vue.mixin(&#123; components:&#123; &apos;search-input&apos;:searchPlugin &#125; &#125;)&#125;；可报漏api 可受控制的组件使用：Vue.use(toast) 调用this.$toast.show()import _toast from &apos;./toast.vue&apos;let $vmtoast.install = function(Vue,options)&#123; if(!$vm)&#123; let searchPlugin = Vue.extend(_toast) let $vm = new searchPlugin(&#123; el:document.createElement(&quot;div&quot;); &#125;) document.body.appendChild($vm.$el) &#125; 1.toast内部method提供两个方法show 和hide； 2.在此处扩展 $vm.show = function()&#123; &#125; $vm.hide = function()&#123; &#125; $vm.changePropsData = function(title)&#123; //title 为组件内部生声明的props $vm.title = title; &#125; Vue.mixin(&#123; created:funtion()&#123; this.$vm = $vm; &#125; &#125;)&#125;； 16.vue 在计算属性的时候，computed和用method里的方法计算有什么区别 123456789computed 计算属性会依赖于他使用的data中的属性，只要是依赖的属性值有改变，则自动重新调用一下计算属性；如果他所依赖的这些属性值没有发生改变，那么计算属性的值是从缓存中来的，而不是重新编译，那么性能要高一些，所以vue中尽可能使用computed替代watch。method 是实时调用，实时计算；没有缓存watch 是监听属性，当属性变化就会执行响应的回调函数； 17.vue中render，nextTick介绍一下？ 18.component中data:function(){} 和data:{}区别？ 12345678910类比与引用数据类型。如果不用function return 每个组件的data都是内存的同一个地址，那一个数据改变其他也改变了，这当然就不是我们想要的。用function return 其实就相当于申明了新的变量，相互独立，自然就不会有这样的问题；js在赋值object对象时，是直接一个相同的内存地址。所以为了每个组件的data独立，采用了这种方式。如果不是组件的话，正常data的写法可以直接写一个对象，比如data：&#123; msg ： &apos; 下载 &apos; &#125;，但由于组件是会在多个地方引用的，JS中直接共享对象会造成引用传递，也就是说修改了msg后所有按钮的msg都会跟着修改，所以这里用function来每次返回一个对象实例。如果组件用 data:&#123;&#125;，那么多个调用组件的地方，将公用一个data，会互相影响。为什么会公用一个data？import 引入的模块，es module导入导出的都是内存地址，导出值导入互相影响 19.vue生命周期钩子？beforeCreate 实例创建之前created 实例创建完成beforeMount 挂载前mounted 挂载后beforeUpdate 更新前updated 更新后beforeDestory 销毁前destoryed 销毁后 20.vue-routers的实现 12345678910111213141516171819202122232425262728293031323334a.hash /#/ + onhashChange 事件改变hash，浏览器的请求不包括hash部分，不会刷新页面；通过hashchange事件监听路由变化b.history操作 history.back() history.go() history.forward()，这些前进后退的操作会触发popstate事件； window.addEventListener(&apos;popstate&apos;，fn） pushState，replaceState 并不会触发popstate事件，这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。 只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求，也就不会刷新； 但是这两个方法不会触发popstate事件，需要我们手动去修改pushstate方法，增加消息通知； //1.对方法进行加工,并且发布消息; function apo(type)&#123; var source = window.history[type]; return function()&#123; var event = new Event(type); event.arguments = arguments; window.disptchEvent(event); return source.apply(this,arguments); &#125; &#125; window.history.pushState = aop(&apos;pushState&apos;); window.history.replaceState = aop(&apos;replaceState&apos;); window.addEventListener(&apos;pushState&apos;,function()&#123;console.log(1)&#125;) window.addEventListener(&apos;replaceState&apos;,function()&#123;console.log(2)&#125;) 2.发布订阅模式，创建event bus来实现；拦截pushState 和replaceState ,发布消息； 前端工程化相关1.webpack基本配置有哪些？(都问) 12345678910entry outputmodule(loader)pluginresolve(alias extentions)webpack.dllPlugin();webpack.dllReferencePlugin();webpack.commonChunkPlugin(); 2.vue-cli3脚手架的基本配置？ vue-cli3 支持全局注册基础化组件 3.webpack作用？ 12341、合并js文件，压缩代码；处理图片资源等静态资源，减少http请求；2、css预处理，编译less/sass等浏览器不能直接识别的语言；3、对文件进行hash，可以防止浏览器缓存。4、一切皆模块，让模块更容易服用，避免重复加载或者加载不必要的模块，并且能够防止全局变量冲突。 4.你对脚手架有研究过么?（小米） 5.项目打包部署你都是怎么弄的？（小米）1jekins部署，具体环境是运维来搭建的。 应用场景开发相关1.简述微信公众号授权过程？（每日优鲜） 2.客户端与前端的交互的原理 ，怎么交互？（瓜子二手车） 安卓:webview1.js全局调用客户端方法：java向前端注入了全局对象ccjBridgeInstance，这个对象上面有一些客户端提供的方法 供前端调用； url传参，native拦截； 协议拦截，与客户端定义协议，通过动态向html插入 iframe，请求协议地址传带参数；native进行拦截 shareFriends://com.culiu.JiuKuaiJiu###分享标题###分享地址 2.客户端调用js:window上声明响应的回调地址，window.方法名_callback，提供给客户端调用； ios:UIwebview wkwebviewUIwebview:1.js全局调用客户端方法：java向前端注入了全局对象ccjBridgeInstance，这个对象上面有一些客户端提供的方法 供前端调用； url传参，native拦截 2.客户端调用js:window上声明响应的回调地址，window.方法名_callback，提供给客户端调用； WKwebview:js调用客户端：window.webkit.messageHandlers[方法名].possmessage(data)；去调用 url传参，native拦截客户端调用js:window上声明响应的回调地址，window.方法名_callback，提供给客户端调用； 回调方法遇到的问题：连续调用相同的bridge，native只调用一次回调；而且当时我们的回调地址都是直接赋给window的一个属性了，导致我们的回调一次次覆盖，只保留了最后一次；解决方案：将回调收拢，每个bridge方法，对应一个回调函数池，提供给native的方法就是遍历这个回调函数池中的回调，依次执行； 调用brigde时，就是向回调函数池中添加 函数； #场景算法题 1.将aabbcccda 字符传替换成abcda？（将连续重复的字符去重）123456789101112131415161718将连续重复的字符去重,这种会有重复项，aabbcccdc=&gt;字符传替换成abcdcreduce拼接，function switchStr(str) &#123; let arr = str.split(&apos;&apos;); return arr.reduce((prev,next,index,origin)=&gt;&#123; if(prev.slice(prev.length-1) == next)&#123; return prev; &#125;else&#123; return prev + next; &#125; &#125;,&apos;&apos;)&#125;function switchStr(str)&#123; return str.replace(/(.)(/1)+/,function(...args)&#123; retrun args[1] &#125;)&#125; 2.js实现字符串trim方法12345678910原生：var a = &apos; 123 &apos;a.trim();js实现：String.prototype.trim = function()&#123; return this.replace(/(^\s+|\s+$)/g,function()&#123; return &quot;&quot; &#125;)&#125; 2.原生js实现字符串split方法？ 12 3.函数节流？防抖？有何区别？ 防抖,节流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 函数节流function throttle(fn,delay) &#123; let flag = true; return function() &#123; if(!flag)&#123; return; &#125; flag = false; setTimeout(()=&gt;&#123; fn.call(this,arguments); flag = true; &#125;,delay) &#125;&#125;function throttle(fn,delay) &#123; let flag = true; return function(...args) &#123; if(!flag)&#123; return; &#125; flag = false; setTimeout(()=&gt;&#123; fn.call(this,args); flag = true; &#125;,500) &#125; &#125;//防抖function debounce(fn) &#123; let timer = null; return function() &#123; clearTimeout(timer); timer = setTimeout(()=&gt;&#123; fn.call(this,arguments) &#125;,1000) &#125; function debounce(fn) &#123; let timer = null; return function(...args) &#123; if(timer)&#123; clearTimeout(timer); timer = null; &#125; timer = setTimeout(()=&gt;&#123; fn.call(this,args) &#125;,300) &#125; &#125; //区分： 节流在一定时间内调用多次，总是执行第一次调用的，执行完成后，才能再次调用。 // 防抖在一定时间内调用多次，后续的调用会覆盖前面的调用，执行的永远是最后一次调用的。 &#125; 4.[a,b,c],写个方法将数组全排列 ，变成[abc,acb,bac,bca,cab,cba] （百度）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556思路:每次都取出一个，然后将除去这一个的其他数进行全排列。然后在将取出的那个数拼接到开头距离：取出a，然后b和c的全排列有两种：bc，cb； 这样就可以算出abc，acb； 取出b，然后a和c的全排列有两种：ac，ca； 这样就可以算出bac，bca； 取出c，然后a和b的全排列有两种：ab，ba； 这样就可以算出cab，cba； 递归千万条，出口第一条：出口就是当数组为两项时，就可以自己写出 全排列。// [a,b,c]=&gt;[abc,acb,bac,bca,cab,cba]function permute(ary)&#123; if(ary.length &lt;= 2)&#123; if(ary.length == 2)&#123; return [ary.join(&apos;&apos;),ary.reverse().join(&quot;&quot;)] &#125;else&#123; return [ary[0]] &#125; &#125; let result = []; ary.forEach((item,index)=&gt;&#123; let all = permute(ary.slice(0,index).concat(ary.slice(index+1))); all = all.map(val=&gt;&#123; return item+val+&apos;&apos;; &#125;) result = result.concat(all); &#125;) return result&#125;console.log(permute([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]));字符串全排列 abc =&gt;[abc,acb,bac,bca,cab,cba]const anagrams = str =&gt; &#123; if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str]; return str.split(&apos;&apos;).reduce((acc, letter, i) =&gt; acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val =&gt; letter + val)), []);&#125;;console.log(anagrams(&apos;1234&apos;));数组全排列 [a,b,c]=&gt;[[a,b,c],[a,c,b]...] function permute(arr) &#123; if(arr.length &lt;= 2)&#123; if(arr.length == 2)&#123; return [arr,[arr[1],arr[0]]]; &#125;else&#123; return [arr]; &#125; &#125; return arr.reduce((prev,next,i)=&gt;&#123; let pool= permute(arr.slice(0,i).concat(arr.slice(i+1))); pool = pool.map(item=&gt;&#123; item.unshift(next); return item; &#125;); return prev.concat(pool) &#125;,[]) &#125; console.log(permute([ 1, 2, 3])); 5.数组对象去重(vipkid) 123456789101112131415161718192021222324252627282930313233//key 和 value都对比；//[&#123;a:11,b:12&#125;,&#123;c:21,d:22&#125;,&#123;a:12,b:11&#125;,&#123;c:21,d:22&#125;,&#123;a:1,e:&#123;name:&apos;1&apos;&#125;&#125;,&#123;a:1,e:&#123;name:&apos;1&apos;&#125;&#125;]function fn(ary)&#123; let obj = &#123;&#125;; for(let i = 0 ;i &lt; ary.length;i++)&#123; let key = JSON.stringify(ary[i]); obj[key] = true; &#125; return Object.keys(obj).map(item=&gt;&#123; return JSON.parse(item) &#125;)&#125;//[&#123;a:11,b:12&#125;,&#123;c:21,d:22&#125;],[&#123;a:12,b:11&#125;,&#123;c:21,d:22&#125;]//找出两个数组对象中 key和value都相同的对象。找出&#123;c:21:d:22&#125;function fn(a1,a2)&#123; let o1 = &#123;&#125;; let result = [] for(let i = 0 ;i&lt;a1.length;i++)&#123; let key = JSON.stringify(a1[i]); o1[key] = true; &#125; for(let i = 0 ;i&lt;a2.length;i++)&#123; let key = JSON.stringify(a2[i]) if(o1[key])&#123; result.push(a2[i]) &#125; &#125; return result;&#125; 6.你所用到的排序方法 7.实现一个方法，能够把多重数组变成一个一维数组,flat方法。[1,[1,2],[3,4,5]]转换为[1,1,2,3,4,5] （vipkid）123456789101112function flat(arr) &#123; let result = []; for (let i=0;i&lt;arr.length;i++)&#123; if(Object.prototype.toString.call(arr[i]) == '[object Array]')&#123; result = result.concat(flat(arr[i])) &#125;else&#123; result.push(arr[i]) &#125; &#125; return result; &#125; 8.12345数组混排 (水滴) 123456789101112131415161718192021222324利用随机数function switchAry(ary)&#123; let result = []; let len = ary.length; for(let i = 0 ;i&lt;len;i++)&#123; let j = Math.floor(Math.random()*ary.length); let cur = ary.splice(j,1)[0]; result.push(cur); &#125; return result;&#125;function sort(ary)&#123; return ary.sort(function()&#123; return Math.random() - 0.5 &#125;)&#125; // Math.floor(Math.random()*5) 0-4， // Math.ceil(Math.random()*5) 1-5 // Math.round(Math.random()*5) 0-5 9.将字符串中重复出现的字符，去重；123456789101112131415161.转成数组，去重，然后拼接； function uqinue(str)&#123; let ary = str.split(&quot;&quot;); return Array.from(new Set(ary)).join(&quot;&quot;) &#125;2.遍历 function uqinue(str)&#123; let result = &quot;&quot;; for(let i = 0;i&lt;str.length;i++)&#123; if(result.indexOf(str[i])==-1)&#123; result = result + str[i] &#125; &#125; return result; &#125; 10.abcaaaaaabcabcabcabbbabc 获取abc的重复次数 和索引 12345678910111213141516171819202122232425262728293031323334353637383940// 方案1，利用abc进行拆分成数组，数组长度-1为出现次数，；然后计算索引function get(str,t) &#123; let ary = str.split('abc'); let n = ary.length - 1; let iAry = []; ary.reduce((prev,next,i,)=&gt;&#123; if(i ==0)&#123; iAry.push(prev+next.length); return prev + next.length; &#125; if(i == ary.length-1)&#123; return; &#125; iAry.push( prev+t.length+next.length); return prev+t.length+next.length; &#125;,0) return &#123;n,iAry&#125;&#125;var a = 'abcaaaaaabcabcabcabbbabcb'console.log(get(a, 'abc'));//方案二：replace方法匹配，参数：[匹配到的整个串，分组，分组...，匹配到整个串的开始索引]function get(str,t) &#123; let reg = new RegExp(t,'g'); let i = 0; let iAry = []; str.replace(reg,function (...args) &#123; i++; iAry.push(args[1]) &#125;)return &#123;i,iAry&#125;&#125;var a = 'abcaaaaaabcabcabcabbbabcb'console.log(get(a, 'abc')); 11.Function instanceof Object （阿里，头条） Object instanceof Function123456789 Function instanceof Object 返回true。 原理：Function 是一个类同时也是一个函数，是Function类的一个实例; Function instanceof Function 是true。 Function.__proto__ == Function.prototype； 而Function.prototype.__proto__ 是Object.prototype； Object instanceof Function 返回true；原理：Object是一个类也是一个函数，所以是Function的一个实例。 12.用二分查找递归方法，插入一个值并返回索引；有序数组[1,2,3,5,7,8],插入4，返回索引3；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 //非递归,遍历找到第一个出现大于他的值，然后记住索引，向他前面插入进去。如果没找到，则直接push进去 function insert(ary,n) &#123; let index; for(var i = 0 ;i&lt;ary.length;i++)&#123; if(ary[i]&gt;n)&#123; index = i; break; &#125; &#125; if(i&gt;=ary.length)&#123; ary.push(n) return i; &#125;else&#123; ary.splice(index,0,n) return index; &#125; &#125; console.log(insert([1, 2, 4], 3)); function insert(arr,n) &#123; var l = []; var r = []; for(let i = 0 ; i&lt;arr.length;i++)&#123; if(arr[i]&lt;n)&#123; l.push(arr[i]) &#125;else&#123; r.push(arr[i]) &#125; &#125; return &#123; index:l.length, ary:l.concat([n]).concat(r) &#125; &#125;//二分插入，递归。//思路：二分，用左侧最后一项进行比较，如果比插值大，说明应该插入到左侧数组中；// 递归,继续二分记性比较。//递归出口：当数组中只有一项时，就可以进行比较，就知道插入到哪了。 function insert(ary,num) &#123; if(ary.length == 1)&#123; if(ary[0]&gt;num)&#123; ary.unshift(num); &#125;else&#123; ary.push(num); &#125; return ary; &#125; let m = Math.floor(ary.length/2); let l = ary.slice(0,m); let r = ary.slice(m); if(l[l.length-1]&gt;num)&#123; return insert(l,num).concat(r) &#125;else&#123; return l.concat(insert(r,num)) &#125;&#125;console.log(insert([1, 2, 34,48,68], 34)); 13.计算出数组的最大差值 12,5,11,7,33,912345678910111213141516171819202122232425262728function adjective(arr) &#123; let max = Math.max(...arr); let min = Math.min(...arr); return max - min &#125;//假设法function adjective(arr) &#123; let min = arr[0]; let max = arr[0]; for(let i = 1; i&lt;arr.length;i++)&#123; if(arr[i]&lt;=min)&#123; min = arr[i]; &#125; if(arr[i]&gt;=max)&#123; max = arr[i] &#125; &#125; return max - min ;&#125;//先排序function fn(arr) &#123; arr.sort((a,b)=&gt;a-b) return arr[arr.length-1] - arr[0];&#125; 14.请写出检查元素是否在屏幕可视区域的关键代码；123456789101112131415161718图片懒加载的原理：方案一：1.获取图片 距离 滑动内容盒子 顶部的offsetTop （需要给滑动内容盒子增加position:relative属性，使他成为父级参照物） offsetParent:父级参照物 第一个具有position属性且非static的父级，没有的话，最终是body 一般情况下页面中所有元素的父级参照物都是body; document.body.offsetParent =&gt;null//body 的父级参照物是null） 2.获取滚动窗口的scrollTop值。 3.获取滚动窗口的clientHeight值。 监听滚动事件：当clientHeight+scrollTop &gt;=offsetTop时，则进入了窗口。 方案二:dom.getBoundingClientRect()是获取某个元素相对于视窗的位置集合; &#123;top,left,right,bottom&#125;，四个值都是距离左边或者顶部的距离。 1.通过getBoundingclientRect().top,获取当前原理距离视窗顶部的距离 2.获取可视窗的高度document.body.clientHeight。 3.当元素距离视窗顶部距离 &lt; 视窗高度，则出现在视窗内 15.将片段1 用正则表达式替换成片段2 （boss直聘） 123456789101112片段1 &lt;h1 class=&quot;h4&quot;&gt;&lt;span class=&quot;label&quot;&gt;boss直聘&lt;/span&gt;&lt;h1&gt;片段2 &lt;h1 class=\&quot;h4\&quot;&gt;&lt;span class=\&quot;label\&quot;&gt;boss直聘&lt;/span&gt;&lt;h1&gt; function replaceStr(str) &#123; let result = str.replace(/&quot;/g,function(...args) &#123; return &quot;/&quot;+args[0] &#125;) return result; &#125; 16.计算”abcadadacvabc”中出现最多的字符？ 1234567891011121314151617181920//预设一个最大次数，利用对象存储次数 key是字符，value是次数；每次遍历都与最大次数进行比较；function fn(str)&#123; let max; let maxNum = 0 ; let obj = &#123;&#125;; let ary = str.split(&apos;&apos;); for(let i = 0 ; i&lt;ary.length;i++)&#123; if(obj[ary[i]])&#123; obj[ary[i]] = obj[ary[i]] +1; &#125;else&#123; obj[ary[i]] = 1; &#125; if( obj[ary[i]] &gt; maxNum)&#123; maxNum = obj[ary[i]]; max = ary[i] &#125; &#125; return `次数$&#123;maxNum&#125; 字符$&#123;max&#125;`&#125; 17.输入a=2 b=3 ,输出a=3,b=2 123456789101112131415161718192021222324252627function fn(a,b)&#123; var temp = a; a = b; b = temp; return &#123; a, b &#125;&#125;function fn(a,b)&#123; a = a+b; b = a-b; a = a-b; console.log(a,b)&#125;function fn(a,b)&#123; a = a -b; b = a+b; a = b-a; return &#123;a,b&#125;&#125;function fn(a,b)&#123; [b,a] = [a,b] return &#123;a,b&#125;&#125; 18.找出整形数组中乘积最大的三位数 [-10,7,29,30,5,-10,-70] 思路：先排序由大到小排序，取前三位的乘机 和 末尾两位 * 首位的乘机进行比较。 末尾两位可能是 负负得正，所以才要和前三位进行比较 12345678910111213141516function get1(ary)&#123; ary.sort((a,b)=&gt;b-a); let sum = 1; for(let i = 0;i&lt;3;i++)&#123; sum = sum * ary[i]; &#125; let sum2 = 1; if(ary.length&gt;3)&#123; sum2 = ary[ary.length-2]*ary[ary.length-1]*ary[0] &#125; if(sum&gt;sum2)&#123; return ary.slice(0,3) &#125;else&#123; return ary.slice(0,1).concat(ary.slice(ary.length-2)) &#125;&#125; 19.假设有n级台阶，每次最多允许跨m步（m&lt;=n）,那么有多少种跨越方式？该题解析 1234567891011121314151617181920212223242526272829303132333435363738394041424344思路：采用自顶向下的思考方式f(n,m) = f(n-1,m)+f(n-2,m)+...+f(n-m,m)当m=2时，这就是一个斐波那契数列。同时，对于n阶变态跳，即n=m时，用公式有以下特点：f(n) = f(n-1)+f(n-2)+...+f(1);//①f(n-1) = f(n-2)+f(n-3)+...+f(1);//②①-② 即f(n) = 2f(n-1)，可以看出n阶变态跳的结果，实际是一个等比数列，也就是f(n) = 2^(n-1)function fn(n,m)&#123; var count = 0; if(n&lt;=0)&#123; return 1; &#125; if(n&gt;=m)&#123; for(let i =1 ;i&lt;=m;i++)&#123; count += fn(n-i,m) &#125; &#125;else&#123; count +=fn(n,n) &#125; return count; &#125;//首先根据规律，存储前m项结果，当n&lt;m时，有f(n,m)=f(n,n)=f(n)=2^(n-1)//接下来我们依次计算n=m+1时的结果并存入数组//根据思路提示，第n项结果等于数组逆序前m项的和，我们截取数组迭代求和//最后返回顶层的数据，即是f(n,m)function f(n,m) &#123; var arr = [1]; for (var i=1; i&lt;m;i++) &#123; arr.push(Math.pow(2,i)); &#125; for (var j=m+1; j&lt;=n; j++) &#123; arr.push(arr.slice(-m).reduce((a,b) =&gt; a+b)) &#125; return arr.pop();&#125;//简单递归function fn(n)&#123; if(n==1)return 1; return fn(n-1) * 2&#125; 20.写一个函数 输入：{ a:{ b:{ c:{ d:’h’, j:’l’, o:{ p:’q’, r:”s” } t:’u’ } }, v:{ w:{ x:{ y:’z’ } } } } e:{ f:{ i:k }, m:’n’ }} 输出结果，按照层数，把同一层的属性放在同一个子数组内；[[a,e],[b,v,f,m],[c,w,i],[d,j,o,t,x],[p,r,y]] 12345678910111213141516思路:每递归一遍，脱一层。function setAry(obj,result) &#123; let keys = Object.keys(obj); if(keys.length == 0 )&#123; return result; &#125; result.push(keys); let next = &#123;&#125;; for(let key in obj)&#123; if(typeof obj[key] == &apos;object&apos;)&#123; Object.assign(next,obj[key]) &#125; &#125; return setAry(next,result) &#125; 21.有两个链表，如何判断两个链表有交叉？ DOM相关1.如何判断一个dom是否在视窗中 123456789101112131415161718图片懒加载的原理：方案一：1.获取图片 距离 滑动内容盒子 顶部的offsetTop （需要给滑动内容盒子增加position:relative属性，使他成为父级参照物） offsetParent:父级参照物 第一个具有position属性且非static的父级，没有的话，最终是body 一般情况下页面中所有元素的父级参照物都是body; document.body.offsetParent =&gt;null//body 的父级参照物是null） 2.获取滚动窗口的scrollTop值。 3.获取滚动窗口的clientHeight值。 监听滚动事件：当clientHeight+scrollTop &gt;=offsetTop时，则进入了窗口。 方案二:dom.getBoundingClientRect()是获取某个元素相对于视窗的位置集合; &#123;top,left,right,bottom&#125;，四个值都是距离左边或者顶部的距离。 1.通过getBoundingclientRect().top,获取当前原理距离视窗顶部的距离 2.获取可视窗的高度document.body.clientHeight。 3.当元素距离视窗顶部距离 &lt; 视窗高度，则出现在视窗内 2.dom事件中 DOMContentLoaded和window.onload的触发实际是什么 ？图片加载完成后是一个什么情况？（苏宁） 123456789101112131415161718192021222324252627//DOMContentLoaded 事件是DOM元素全部加载完成之后就会触发，图片等其他信息加载之前调用// 在Dom节点创建完成后执行，如果有多个定义，则触发后会依次执行。// jquery:$(function() &#123; //do something&#125;)$(document).ready(function() &#123; //do something&#125;)$().ready(function() &#123; //do something //jquery默认参数是document $()&#125;)// 以上三种方式都是jq提供的dom加载完成事件，都是基于DOMContentLoaded dom2级事件的。document.addEventListener('DOMContentLoaded', function() &#123; // 此方法为原生js DOM加载完成执行的事件&#125;)//windown.onload// 加载完所有页面内容才会触发，包括所有内容,包括图片，flash等所有文件.如果页面的这些内容很多会让用户等待很 长时间.//只能定义一个，如果有多个定义则只执行最后一个// 举例// 比如：页面中只有一个img标签，当img节点创建完后就会执行$(function()&#123;&#125;)中的代码，// 当img的src指定的图片完全加载完后才会触发window.onload事件。 3.原生js实现jq的after方法 123思路：获取当前元素的氟元素节点 parentNode 获取当前元素的下一个元素节点nextElementsibling（或者nextSilbling &amp; nodeType==1，递归找出） parentNode.inserBefore(被插入元素,nextElementsibling) 性能优化相关？1.列举你能想到的前端性能问题和安全问题 123456789101112131415161718192021222324252627282930 安全问题： a.xss攻击,就是攻击者想尽一切办法将可以执行的代码注入到网页中。 评论功能，写入脚本内容，入库了。 get参数后面拼接了key=脚本； 这种很被容易写进页面； 防御： 转义字符：对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义 利用js-xss 将内容进行过滤，转义； csp:建立白名单，配置规则，高速浏览器哪些外部资源可以加载； 通常可以通过两种方式来开启 CSP： 设置 HTTP Header 中的 Content-Security-Policy 设置 meta 标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; 只允许加载本站资源 Content-Security-Policy: default-src ‘self’ 只允许加载 HTTPS 协议图片 Content-Security-Policy: img-src https://* 允许加载任何来源框架 Content-Security-Policy: child-src &apos;none&apos; b. CSRF攻击？跨站点请求伪造如何防范 原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话， 后端就以为是用户在操作，从而进行相应的逻辑。 防御：请求时post附带验证信息，比如验证码或者 Token； get请求不对数据进行修改 服务端验证referer c.点击劫持，攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击 防御：当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697前端性能优化：（都问） 前端代码的压缩 合并，减少http请求，和文件大小 图片处理设置最大边界，base64；雪碧图； 少操作dom减少dom回流，或者创建文档碎片； 缓存dom节点，减少查找次数； 应用节流和防抖处理函数；比如说滚动发出请求； preload资源预加载属性； 图片懒加载； 静态资源放到cdn上； 离线存储:配置manifest配置应用程序缓存：CACHE MANIFEST，NETWORK，FALLBACK 优点// 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 // 更新缓存 用户清空浏览器缓存 manifest 文件修改，可以配置一个版本号， 由程序来更新应用缓存 // 其他 // 站点离线存储的容量限制是5M 浏览器缓存机制； 楚楚推：图片max-age：24小时； js css文件max-age：15分钟； 协商缓存； webpack性能优化： 有哪些方式可以减少 Webpack 的打包时间？ 1.优化loader，通过exclude和include，优化loader的文件搜索范围； module.exports = &#123; module: &#123; rules: [ &#123; // js 文件才使用 babel test: /\.js$/, loader: &apos;babel-loader&apos;, // 只在 src 文件夹下查找 include: [resolve(&apos;src&apos;)], // 不会去查找的路径 exclude: /node_modules/ &#125; ] &#125; &#125; 2.使用HappyPack插件； 受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。 HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了 module: &#123; loaders: [ &#123; test: /\.js$/, include: [resolve(&apos;src&apos;)], exclude: /node_modules/, // id 后面的内容对应下面 loader: &apos;happypack/loader?id=happybabel&apos; &#125; ] &#125;, plugins: [ new HappyPack(&#123; id: &apos;happybabel&apos;, loaders: [&apos;babel-loader?cacheDirectory&apos;], // 开启 4 个线程 threads: 4 &#125;) ] 3.webpack.DllPlugin + webpack.DllReferencePlugin DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本 才有需要重新打包，并且也实现了 将公共代码抽离成单独文件的优化方案。 4.resolve.extensions：用来表明文件后缀列表，默认查找顺序是 [&apos;.js&apos;, &apos;.json&apos;]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面 5.resolve.alias：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径 有哪些方式可以让 Webpack 打出来的包更小？ 1.按需加载， 原理：当使用时候再去下载对应文件，返回一个promise； 2.代码压缩；uglifyJS-webpack-plugin webpack-parallel-uglify-plyugin 并行压缩js 3.Tree Shaking可以实现删除项目中未被引用的代码， // test.js export const a = 1 export const b = 2 // index.js import &#123; a &#125; from &apos;./test.js&apos; test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中 4 Scope Hoisting Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去 module.exports = &#123; optimization: &#123; concatenateModules: true &#125; Webpack 4 的话，开启生产环境就会自动启动这个优化功能。&#125; 2.项目优化方法 3.错误检测上报日志怎么实现的? //a.通过onerror 捕获代码运行错误，捕获到错误信息后可以向目标服务器img发一个请求，get传递错误信息； window.onerror = function(msg, url, line, col, error){ } //b.页面埋点，监听用户交互和pv/uv，请求服务器进行上报 //c. performance.getEntriesByType(‘navigation’) 针对一些复杂页面，获取页面的性能相关信息，进行上报； 4.fis3 和 webpack的区别是什么？12345678910111213a.入口，webpack是从entry出发，将依赖的文件提取编译打包，通过commonschunkplugin、dll等提取公共代码； fis3 是以file对象为中心构建编译的，所有文件同等对待，都会去分析文件依赖关系，生成一个静态资源表， 资源表记录每个文件的依赖关系； fis3可以针对每个文件做出相应的配置，更加细致； b.fis3的配置文件，fis.match到某些文件，然后对这些文件定义各自的各个阶段的插件处理、发布规则,是针对文件进行匹配的; webpack配置文件，entry、output、plugins、module、resolve;c.fis3能对任何文件使用hash控制，在引用它的任何地方的路径会被自动替换为hash路径。 d.fis3，由于独有的静态资源标记，导致npm生态不太好； 5.请列举最重要的前端优化点(按重要性) 6.：我们为什么一再强调将css放在头部，将js文件放在尾部 浏览器解析123456789在面试的过程中，经常会有人在回答页面的优化中提到将js放到body标签底部，原因是因为浏览器生成Dom树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。 我们再来看一下chrome在页面渲染过程中的，绿色标志线是First Paint的时间。纳尼，为什么会出现firstpaint，页面的paint不是在渲染树生成之后吗？其实现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。 7.vue首屏加载很慢，怎么进行优化？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384a.组件异步加载; 局部注册异步组件(`import` 函数会返回一个 `Promise` 对象。) new Vue(&#123; // ... components: &#123; &apos;my-component&apos;: () =&gt; import(&apos;./my-async-component&apos;) &#125; &#125;) =&gt; new Vue(&#123; // ... components: &#123; &apos;my-component&apos;: Promise.resolve(&#123;...组件定义对象&#125;) &#125; &#125;) 全局注册异步组件 Vue.component(&quot;custom&quot;,() =&gt; import(&apos;./my-async-component&apos;)) =&gt;Vue.component(&quot;custom&quot;,Promise.resolve(&#123;...组件定义对象&#125;)) 或者 Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123; resolve(&#123; template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos; &#125;) &#125;)Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123; // 这个特殊的 `require` 语法将会告诉 webpack // 自动将你的构建代码切割成多个包，这些包 // 会通过 Ajax 请求加载 require([&apos;./my-async-component&apos;], resolve)&#125;) 2.路由懒加载+分组打包； 没有指定webpackChunkName，每个组件打包成一个js文件； 指定了相同的webpackChunkName，会合并打包成一个js文件。 const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &apos;./Foo.vue&apos;) const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &apos;./Bar.vue&apos;) const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &apos;./Baz.vue&apos;) const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo， children:[ &#123;path:&apos;/bar&apos;,component:Bar&#125; &#123;path:&apos;/baz&apos;,component:Baz&#125; ] &#125; ] &#125;) 3.组织复杂页面的代码时，可以考虑对于打开首屏时不需要渲染的子组件，使用v-if控制其只在需要的时候被渲染。 4.cdn加载外部的css js文件，浏览器并发请求加载。 html直接引入外部的js 和css文件，比如vue vuex 利用webpack的externals忽略打包文件；key是导入的键，value是项目中用到的变量 externals: &#123; jquery: &apos;jQuery&apos; , vue:&apos;Vue&apos; //将需要忽略打包的都写在这个里面，但前提是index.html文件里面必须script引入 &#125; 使用：import $ from &apos;jquery&apos;，正常使用 5.开启gzip压缩支持 npm install compression-webpack-plugin —save-dev 将config/index.js 开启压缩 productionGzip: true, productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;], 注：想要线上使用还需还得配置后端。 扩展常用webpak插件 copy-webpack-plugin ：复制文件到目标文件夹。在开发时使用热模替换，（没有生成dist 文件夹，都在内存中），如果想引用某一个js文件，直接写script标签是找不到的，因为服务器内存中没有这个文件。所以复制这个文件，到dist中。 compression-webpack-plugin： 生产环境时可选择让代码压缩gzip. html-webpack-plugin : 生成index.html 并自动注入打包后的js css 等 webpack.DefinePlugin： 可以生成配置常量。编译时就有的常量。 extract-text-webpack-plugin： 提取使用文件的css 组成一个或多个css 文件。 webpack.optimize.CommonsChunkPlugin： 让多个出口文件组成一个文件 webpack-dev-server: 开发时使用，静态服务器，并且有热替换等功能。 uglifyjs-webpack-plugin： 删除警告，压缩代码等 扩展知识？能聊就行～1.简述CI/CD？ 2.多态和重载？ 12345重载：相同函数名，不同参数，则认为是两个不同的函数；js没有函数重载，可以通过参数个数，参数类型，内部模仿重载；多态的实际含义是，对象的多种形态；同一操作，作用在不同的对象上面，可以产生不同的解释和不同的执行结果。javascript的变量类型在运行期是可变的，这就意味着javascript对象的多态性是与生俱来的。 3.了解服务端的反向代理吗？ 4.订餐功能 如何实现的？利用express框架搭建node服务，对前端提供api请求接口；利用express-router + app.use 实现父子路由管理,实现用户订餐的增删改；利用node-schedule 包实现定时任务，每天定时抓取用户订餐状态,生成订餐名单；每天定时清除，所有用户的 订餐状态；利用nodemailer向行政发送 订餐人员名单;let dinner = express.Router();dinner.get(‘/list’,function(){ }) dinner.post(‘/set’,function(){ }) dinner.post(‘/delete’,function(){}) app.use(‘/dinner’,dinner) 表结构：主键：是用户id ，用工号代替；姓名；部门；订饭状态；用户进入前端页面，post提交工号，然后将该同学的订饭状态改成订餐状态； 设计模式1.观察者模式 和 订阅发布模式的区别 123// 观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。// 观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，会造成代码的冗余。而发布订阅模式则统一由调度中心处理，// 消除了发布者和订阅者之间的依赖。 程序执行题1.代码执行结果（boss直聘）12345678910111213141516171819202122232425262728var data = &#123; name:'boss', age:3&#125;console.log(data.age);//3observe(data);console.log(data.age);//4data.age = 5; //val = 6console.log(data.age)//7function observe(data) &#123; Object.keys(data).forEach(function (key) &#123; defineReactive(data,key,data[key]) &#125;)&#125;function defineReactive(data,key,val) &#123; Object.defineProperty(data,key,&#123; enumerable:true, configurable:true, get()&#123; return val +1; &#125;, set(newVal)&#123; val = newVal+1; &#125; &#125;)&#125; 2.代码执行结果12345const arr = [1,2,3,4,5,6];const res = arr.filter(value =&gt;value%2).map(item=&gt;item*item).reduce((a,b)=&gt;a+b);console.log(res);//35console.log(arr.pop());//6console.log(arr);//[1,2,3,4,5] 3.程序输出结果1234567const arr = [1,2,3,4,5,6]for(var i = 0;i&lt;arr.length;i++)&#123; setTimeout(_=&gt;&#123; console.log(arr[i]) &#125;,0)&#125;//输出6个undefined #node 1.express的设计思想？路由控制中间件静态文件服务模板解析 let app = express();app.get(‘’,(req,res,next)=&gt;{ },(req,res,next)=&gt;{}).post(‘’,(req,res.next)=&gt;{ }) app.use(‘’,(req,res,next)=&gt;{ }) let user = express.Router();user.use(‘/login’,(req,res,next)=&gt;{ }) user.get(‘’,(req,res)=&gt;{ })app.use(‘/user’,user) 设计思想1.路由：二维数组的二维数据形式[[cb,cb,cb],[cb,cb,cb],[cb,cb,cb],[usecb,usecb,usecb]]最外层是Router，[cb,cb,cb] 表示的route，cb指的是每个route中的回调；[usecb,usecb,usecb]表示中间件的回调； 2.路由服务express.router()，创建路由，在利用app.use中间件，形成父子级别中间路由；express.router返回的一个router函数，router函数复用了app的一些方法,也同样具备handler/post/get/use等方法；这样就利用方法复用，实现了一层一层的套用； 3.静态资源服务，调用node原生利用 http服务起的服务； 2.express和koa的区别？（阿里） express 自带路由控制，express-router ;koa 需要单独引入express 基于回调函数，koa是基于generator思想的；koa是不会出现回调地狱的； 3.node 思想？ 特点：线程是单线程异步。通过callback实现异步。非阻塞、异步I/o，能用异步 绝不同步event-driven事件驱动-发布订阅模式 思想：基于事件驱动，异步io，通过callback实现异步 commonjs模块化，一个js就是一个模块； 自由回答题：在一个异世界里，老虎可以吃羊，也可以吃草，并且羊比草好吃。但是吃了羊就会变成羊。假设现在有100只老虎和1只羊，且所有老虎都非常理性，那么最终会剩下多少老虎和多少羊？（头条）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04.4安装与优化]]></title>
    <url>%2F2020%2F02%2F15%2FUbuntu16-04-4%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[由于我的 acer 不争气，好不容易装好的系统，关机以后自检找不到系统了，所以这篇文章暂时搁置，等我有了一台能顺利跑Ubuntu的电脑再来填坑。 ###没错，这篇文章就是被搁置了。 2020-02-16 随手放一些效果图，很Mac有没有？ 桌面效果图 下载主题包，链接:https://pan.baidu.com/s/1Y9DMaPc5JQ47TzVue7RvIQ 密码:a9ne,根据文档内容放入对应文件夹 安装gnome-tweak-tool,然后打开tweak工具，]]></content>
  </entry>
  <entry>
    <title><![CDATA[VsCode教程]]></title>
    <url>%2F2020%2F02%2F13%2FVsCode%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[https://juejin.im/post/5e440fd4e51d4527271e8b79 ##VsCode安装 进入官网 点击首页的蓝色按钮下载对应系统安装包并安装 ##相关设置 可以点击上部菜单栏中的文件 —&gt; 首选项 —-&gt; 设置 设置一些软件的自带功能比如 自动保存 折行方式 等等 自动保存 在设置的第一个就是选择 onFocusChange 折行方式直接搜索 折行即可 选择 on 切换颜色主题，点击文件—-首选项—-颜色主题 就可以选择不同的颜色主题了 一般我们是把我们的大的文件夹放到 vscode 内当作工作区，方便管理 ##插件 打开软件，看到的是欢迎页，找到页面右侧的蓝色 sublime 点击安装 sublime快捷键，会弹出两个窗口选择 yes 和 ok 页面全是英文的安装插件，点击软件最左侧的第五个菜单，在搜索栏搜索 chinese 选择简体中文点击 install 安装即可，会提示你重启软件重启之后软件就汉化了。 .安装在浏览器中打开插件，插件搜索栏搜索 open in browser，安装即可 .安装路径自动补齐插件，插件搜索栏搜索 path，安装即可，使用方式先加引号然后使用 ./ ./代表当前 安装 小图标插件，插件搜索栏搜索 vscode-icons，安装即可，会弹出一个小窗口让你选择图标主题选择刚才安装好的即可 setting sync 插件的使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[全球IPv4地址耗尽，正式迈入IPv6时代！]]></title>
    <url>%2F2019%2F11%2F26%2F%E5%85%A8%E7%90%83IPv4%E5%9C%B0%E5%9D%80%E8%80%97%E5%B0%BD%EF%BC%8C%E6%AD%A3%E5%BC%8F%E8%BF%88%E5%85%A5IPv6%E6%97%B6%E4%BB%A3%EF%BC%81%2F</url>
    <content type="text"><![CDATA[2019年11月25日 22:35分，是值得互联网纪念的一个时刻，全球IPv4地址已经全部耗尽！IPv4中规定IP地址长度为32位二进制，最多能有2^32 个，大约42.9亿个，而IPv6采用128位地址长度，能达到2^128 个，这可是一个天文数字了，可以保证地球上每平方米分配1000多个地址。]]></content>
  </entry>
  <entry>
    <title><![CDATA[阿里云OSS乌龙]]></title>
    <url>%2F2019%2F09%2F27%2F%E9%98%BF%E9%87%8C%E4%BA%91OSS%E4%B9%8C%E9%BE%99%2F</url>
    <content type="text"><![CDATA[昨天，突然接到阿里云的短信，我前天才开的阿里云oss欠费停机了？？？ 停机短信excuse me？ 我才开通一天啊喂！后来我迅速查看了使用详情，看到了云服务器ECS-快照的字样，我立马想到自己的ECS，是不是设置了自动快照？？因为前面的流量情况是一样的，是不是它自己一直在自动备份？？可是我查看了自己所有的服务器，并没有开快照啊。无奈之下，我只能联系客服（不得不说阿里爸爸服务是真棒！）晚上十一点多还有在线客服也是感动了一把。最终在与客服耐心的沟通后，仍然没有找到问题所在。直到最后，我忽然想起新建bucket时候的两个条件：存储包和流量包！！！我购买的是存储包而欠费的原因竟然是流量包……这一发现让我哭笑不得，原来问题它就不出在那40G的存储包上面，而所谓的快照原来就是我已经使用的空间，最终，当我交上欠费的¥0.1以后，终于又能打开markdown图片了。 反思经过这一次的事件，我越发明白了阅读官方文档的重要性，其实这些内容在官方给的QA里一般能找到，但是习惯互联网捷径的我更愿意直接google，这不失为解决方法的一种途径，但是，有时候可能官方给出的文档更加注重问题本身，更加明了，前提是你能够静下心来仔细阅读一下。包括昨天我还没有解决的GitHub密匙问题（当初搭建博客时候，把密匙配置在了graylogo/gray.github.io仓库下，导致其他仓库push时候失败了，官方文档提供的ssh连接很详细，但可惜的是全是英文……纵使如此，一些词汇还是相对简单的，加上Google翻译，还是能看懂的。所以，啥也不说了，读文档，解决问题去吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[那些句子]]></title>
    <url>%2F2019%2F09%2F26%2F%E9%82%A3%E4%BA%9B%E5%8F%A5%E5%AD%90%2F</url>
    <content type="text"><![CDATA[七岁的那年，抓住那只蝉，以为能抓住了夏天。 –《如烟》]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派+HomeBridge实现HomeKit控制智能家居]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%A0%91%E8%8E%93%E6%B4%BE%2BHomeBridge%E5%AE%9E%E7%8E%B0HomeKit%E6%8E%A7%E5%88%B6%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%2F</url>
    <content type="text"><![CDATA[米家app发展的很快，短短几年，已经日趋完善，得益于其高性价比，用户也越来越多，反观HomeKit在国内的表现，也仅仅是同“电视.app“一样，躺在每个ios用户的手机里。后来，在GitHub上开源了一个HomeBridge项目，通过树莓派做桥接，实现Siri控制米家智能设备。 ##一、需要准备的东西 支持 iOS10 的苹果设备（ iPhone 5 以上、 iPad mini 2 以上、 iPod 第六代以上） 小米多功能网关二代（ 注意：一定要二代！） 任意一个或多个支持 HomeKit 的设备：小米智能插座 ZigBee 版、小米人体传感器、小米门窗传感器、小米温湿度传感器、Yeelight智能灯泡、 Aqara墙壁开关等 树莓派 Raspberry Pi 3B+ （包含读卡器 &amp; 8 Gb 以上 TF 内存卡一张） Mac Book一台（当然，win也可以） 树莓派3B+ ##二、GitHub项目地址 HomeBridge homebridge-mi-aqara ##三、开始吧 关于树莓派的安装和打开ssh可以先移步系统烧录和打开ssh； 跟新gcc（可以使用pi用户也可以使用root用户，使用pi用户涉及权限问题请加sudo）sudo apt-get install gcc 接下来依次安装，如果你发现速度很慢，你可能需要更改中国软件源，参考文章：Raspbian 中国软件源,阿里云各个地方速度都不错。a. 安装nodejs：sudo apt-get updatecurl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -sudo apt-get install -y nodejssudo apt-get install -y build-essentialb. 安装avahi：sudo apt-get install libavahi-compat-libdnssd-devc. 安装HomeBridge：sudo npm install -g --unsafe-perm homebridged. 安装homebridge-aqara：sudo npm install -g homebridge-aqara安装部分完成！ 新建和配置config.json文件返回主目录→创建” .homebridge “文件夹→进入” config.json “文件） 123cd ~ mkdir .homebridgevim .homebridge/config.json 复制以下代码稍作修改： 123456789101112131415161718192021222324&#123; &quot;bridge&quot;: &#123; &quot;name&quot;: &quot;Homebridge&quot;, &quot;username&quot;: &quot;CC:22:3D:E3:CE:30&quot;, &quot;port&quot;: 51826, &quot;pin&quot;: &quot;031-45-154&quot; &#125;, &quot;platforms&quot;: [&#123; &quot;platform&quot;: &quot;AqaraPlatform&quot;, &quot;sid&quot;: [&quot;【（密码A）网关MAC地址，去掉冒号，全部小写】&quot;], &quot;password&quot;: [&quot;【（密码B）网关局域网密码】&quot;] &#125;]&#125; 其中 name 是你在 iOS 家庭 App 上可以看到的桥接器的名字，建议就叫 Homebridge，username 需要是类似 MAC 的格式，是可以随意填写，只要符合格式，建议不需要更改了。port 随意，确保不要被占用。pin 随意，为密码，需要是 8 位数字，格式为 xxx-xx-xxx，比如 123-45-678。下面的 platform 也是无所谓修改不修改，关键是sid和password，这就需要在手机上操作了。在手机上打开米家 App，点击你的网关，右上角三个 ···，并狂按底部空白区域，直到出现局域网通信协议和网管信息为止。点击局域网通信协议，打开，并刷新一个密码，改为全部小写，（安卓手机刷出来是小写），记录这段文字（密码 A ）。点击网关信息，找到 mac: 后的文字，如本截图中的 28:6C:07:85:B3:0E，去掉 : 并全部改为小写，也记录这段文字（密码 B ），如本截图中的文字处理后的结果就是 f0b429cc6168。第一个密码 A 就是你的 sid，第二个密码 B 就是 password。如果你有多个网关用逗号链接，比如 cb30a01c1bcc4b3c, dc41b12d2cdd5c4d, password 同理。在刚刚树莓派编辑的 config.json 输入上面获得的密码，保存退出。（vim的使用自行Google） 运行homebridge直接在命令行输入homebridge就能运行；有时出现错误会自动关闭，错误原因有很多，一般就是端口占用，或者mac地址和密码填写错误，仔细检查，如果不行的话，清除缓存，删除连接信息重新运行homebridge：操作方法a. 结束HomeBridge进程，如下：pkill -9 homebridgeb. 进入config.json所在的文件夹，例如：cd /root/.homebridgec. 删除文件夹下persist文件夹，例如：rm -rf persistd. 重启Homebridge进程，例如：homebridge掏出iPhone，打开家庭app，点击添加配件，扫描二维码或者手动输入你设置的八位密码就可以配对成功，操作完成。 最后的最后，你会发现，HomeBridge 停止运行了。我们不可能在电脑上挂着终端使树莓派一直运行这个服务，因此还有最后一步，把 HomeBridge 服务加入到树莓派的系统服务里。事实上, 树莓派文档 Scheduling tasks with Cron 给出的方法是最简单并且方便以后配置别的程序。先安装 cronsudo apt-get install gnome-schedule然后配置 cron.crontab -e在最下方添加@reboot homebridge &amp;即可完成开机启动 homebridge 的配置。现在，你可以重启一下树莓派，运行ps -ef | grep homebridge看看 HomeBridge 服务是否正常运行. 最后来感叹一下apple的生态系统，当我成功配置后，我能够在iPhone、ipad、mac、甚至是Apple Watch上控制小米家居，实在激动。 注意：树莓派必须通过网线连接，不能通过Wi-Fi连接！ 参考：树莓派进阶（一）：借助树莓派与 HomeBridge，从米家到 HomeKit从米家到 HomeKit，你只需要一个树莓派HomeBridge教程]]></content>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上常用的软件&插件]]></title>
    <url>%2F2019%2F09%2F24%2Fmac%E8%BD%AF%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前几天忍不住升级了Catalina beat 10.15版，后来ruby环境崩溃，Final cut pro、iMovie也用不了，苦不堪言，最终在没有备份的前提下降级到Mojave……正好从头折腾一下Mac电脑，顺便整理一下这几年常用的软件和插件。 Alfred我的一些工作流很有名气的一款软件，实现很多workflow功能，在刚开始使用Mac时候就装上了，用的最多的还是双击option查单词，方便快捷，最近找到了开源的阿里云oss图床oss_upload,在码字时候一键上传图片生成markdown连接，所见即所得。另外，还有调用istats查看电脑cpu温度和风扇速度：查看cpu温度 Keybord MaestroMac上窗口管理的软件非常多，例如非常有名的Magent，但是，这些软件都只有窗口管理一个功能，而且不如KM灵活。下面是我自己的配置，分别是居中、全屏、左上、右上、左下、右下几个位置，对应的快捷键可以自己设置，比如我的“居中”就是Command+Control+H：简单几步配置，就会爱不释手。另外，它还提供一个我非常喜欢的功能，用同一个快捷键呼出/隐藏一个窗口，具体操作也很简单，新建一个Macro，动作选择第一个activate a specific Application,然后简单配置一下就ok。 qlimagesize这也是一个开源项目，qlimagesize,强化mac一指弹——空格键查看时候显示图片分辨率、大小等信息；10月11日更新：升级Catalina10.15后，由于签名(行话叫做 Notarize)失效，quicklook插件都不能正常使用了。尝试在GitHub上找到答案，看这里，截止目前，仍然没有明确的解决办法。 iterm2这绝对是我的最爱了，一款terminal软件，记得打开快捷键，一键呼出，一键隐藏！ sublime text3感觉是mac断看代码最舒服的软件了，插件多多，慢慢跟新。 MWeb现在正用这款软件码字呢…… redder4rss阅读器，全iOS平台，mac上大屏超爽！ chromeemmm……这个不必多说，已经离不开了。 Evernote以前淘宝买了很多年的会员，全平台，第二大脑，就是不常去复习…… bartender3状态栏管理软件，当你看到左上角乱糟糟的状态栏的时候，自然而然就会想到它啦！ MosMos,开源，一个用于在MacOS上平滑你的鼠标滚动效果的小工具, 让你的滚轮爽如触控板，mac连接屏幕用到鼠标的时候就知道它有多棒啦😂 LyricsX开源，上架mac AppStore，动态显示iTunes歌词，亲测支持Catalina…… ToothFairy一款快速连接，断开蓝牙的状态栏小工具，搭配AirPods使用，效果杠杠的。 暂且整理这几个，慢慢填坑。 ###10-7更新： Lunar：连接上外接显示器后，调节显示器亮度。开源。 ###2019-2-11更新： 快贴 打通Mac和Windows的剪贴板壁垒，全平台。]]></content>
      <tags>
        <tag>Macos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Hexo + Github 搭建博客]]></title>
    <url>%2F2019%2F05%2F25%2F%E9%80%9A%E8%BF%87Hexo-Github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[最近学习压力很大，想起了这个被搁置一年的博客计划，正好看到了Hexo搭建的萤火之森页面，真的很漂亮，于是决定动手自己搭建一个。这篇文章正好记录一下搭建过程中遇到的问题，方便以后学习。 遇到的问题1. Github密匙只读2. hexo s 显示4000端口不能用解决方法：在Blog的根目录下，修改_config.ynl文件，在最后加上：1234server: port: 4001 #注意port前有Tab键 冒号后有空格 compress: true header: true 花费的时间总的算下来，总共花了我四个小时左右的时间来搭建这个博客，当然，这仅仅是搭建了基础的框架，后期还需要大量的时间来美化，不过鉴于最近考试太忙，估计得延期一段时间了。 为什么要需要这个博客？一年前，我用阿里云镜像一键搭建了基于Wordpress的个人博客，但是由于拖更，导致兴趣越来越少，最后也就不了了之了。从这段历程中，我感受到了，不是自己努力来的结果自己真是不懂得珍惜，这一个花费我一晚上心血建立的Blog，我可要好好监督自己，不要荒废了。其实，挺羡慕那些能在各种论坛分享自己知识的人，帮助别人的同时也能留下自己的足迹，最重要的是，在这个过程中，能找到归属感与成就感，这就是分享的意义吧。很大一部分人，写的都是技术博客，但是我知道自己现在能力有限，输出不了太多的干货，所以，现在这个阶段，更多的是记录一些学习笔记，当然，我也想穿插一些自己的心里话，写一下每个阶段的感悟。 搭建过程让我学到了什么搭建过程虽然烦琐，但我确乐在其中，兴趣是最好的老师，在搭建过程中，我看到了很多感兴趣的技术，比如GitHub的代码托管（很早以前我就注册了GitHub账号，但是一直没有项目来练习），比如Node.js，看到漂亮的网页，不眠不免对前端心生向往，再比如最近一直在学习的Linux命令行，现我已经迫不及待想要用shell自己写一个一键部署脚本了。 给自己立下Flag我的脑海里会迸发出很多新计划，但是最后很多都是不了了之，因为没有去实现，所以，在这里，我要给自己定几个目标： 每个月至少来更新一篇博客，不管是什么类型的。 尽快掌握MarkDown与法，写出排版漂亮的文章。 将我的小站好好维护下去，做一些优化。 开始GitHub的学习 关于我我觉得我很有想法，但是想到和做到之间，有一块透明的玻璃挡在我的面前，它看不见，但是它真实存在，而现在我要做的，就是想办法用行动突破它！在脑海里的话语，写在纸面上就是另外一番模样，说白了，我需要练习自己的写作能力了，多年后，看到这青涩的文字，嘴角应该会有一丝微笑吧。]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[用Mweb发布Hexo博客]]></title>
    <url>%2F2019%2F04%2F10%2Ftest%2F</url>
    <content type="text"><![CDATA[测试一下图床功能]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米路由器青春版刷Padavan固件]]></title>
    <url>%2F2019%2F01%2F26%2F%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E9%9D%92%E6%98%A5%E7%89%88%E5%88%B7Padavan%E5%9B%BA%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[刷机是一种乐趣，大学宿舍晚上断电，正好手上有一个小米路由器青春版，USB充电宝供电，巴掌大小，放在宿舍简直合适不过了。最最最厉害的是可以刷潘多拉固件，简直不要太好！（这篇文章是以前Wordpress上写的，后来荒废了，但是这篇文章留在了MWeb的文件夹里，感谢MarkDown！） 准备： 小米路由器青春版 *1 网线 *1 电脑(Mac 或 Windows) *1 刷机所需的固件，软件（Putty和WINSCP自行百度下载） 基本思路： 首先确保路由器ROM版本为2.0，如果不是，降级到2.0或刷入开发版miwifi_r1cl_all_59371_2.1.26.bin版本(点击下载这个开发版） 修改网页地址的方式来篡改web管理密码和root密码 使用telnet命令进去备份各个分区(非必须) 刷入breed 刷入固件（潘多拉或梅林） 步骤： 小米路由器青春版是没有官方通道开启ssh的，其它版本路由器可以在miwifi开放平台查看。在网友的帖子里，我们可以直接修改路由器的请求地址的特定参数，改变系统参数，从而开启ssh。 首先确保路由器ROM版本为2.0，如果不是，降级到2.0或刷入开发版miwifi_r1cl_all_59371_2.1.26.bin版本(点击下载这个开发版）降级方法：由官方的路由管理界面，上传本ROM包，自动升级即可 在浏览器地址栏输入192.168.31.1，输入管理员密码（如果忘记了的话按住路由器的reset键10s以上重置系统，设置账户密码再做上面的操作），地址栏会多出一部分参数，比如我的是： 1http://192.168.31.1/cgi-bin/luci/;stok=6bb3936a88b4df625ded00d17be3911a/web/home#router 更改管理员密码和root密码将上面的地址中的 /web/home#router 改为 /api/xqsystem/set_name_password?oldPwd=旧密码&amp;newPwd=新密码 ，然后确定，看网页的返回值，如果是{“code”:0}就表示修改成功，可以接着下一步。 把 /web/home#router 改为 /api/xqnetwork/set_wifi_ap?ssid=xiaomi&amp;encryption=NONE&amp;enctype=NONE&amp;channel=1%3B%2Fusr%2Fsbin%2Ftelnetd ，然后查看返回的JSON数据 {“msg”:”未能连接到指定WiFi(Probe timeout)”,”code”:1616} ，就可以用telnet方式登录路由器。 用telnet方式登录路由器下载一个Putty 。然后打开选填以下参数，连接类型：telnet;主机名称：192.168.31.1.点击连接。可以看到看到login，账户输入root，密码则为以上第二步中修改的新密码。然后依次执行下面的三条指令： 123sed -i &quot;:x;N;s/if \[.*\; then\n.*return 0\n.*fi/#tb/;b x&quot; /etc/init.d/dropbear /etc/init.d/dropbear start nvram set ssh_en=1; nvram commit 此时我们已经开放ssh，可以用ssh方式登录路由器了。 刷入breedWINSCP 选择SCP协议 复制breed.bin 到/tmp输入以下命令刷入，刷入后，机器会自动重启： 1mtd -r write /tmp/breed.bin Bootloader 进入breed控制台先给路由器断电，再按住路由器reset键，再给路由器送电，等到路由器灯闪的时候，松开reset键，用一根网线将路由器的WAN口和电脑相连，在电脑上在浏览器中输入192.168.1.1，进入breed控制台了。 刷入固件可供选择的固件还是很多的，在这里我找了一个padavan,这固件是从Padavan固件源码搬运源码汉化后编译出来的。选择MI-NANO_3.4.3.9-099.trx这个版本，青春版专供直接在控制台选择上固件，然后点击更新，等待路由器自动重启，万事大吉！ 修改灯光颜色开机灯颜色蓝色橙色混合使用下面的命令关闭橙色灯变成纯正蓝色 1mtk_gpio -d 44 0 管理路由器刷入成功后，默认创建了名字为PCDN的无线网络，默认的密码为1234567890后台网址为192.168.123.1，账号密码都为admin。（登录后可自行修改）另外，可以配置ss，开启广告屏蔽插件等操做。 参考文章：小米路由器青春版刷Padavan固件小米路由器青春版刷潘多拉、华硕固件小米路由器青春版开启SSH刷入Padavan固件小米路由器青春版刷Padavan以及修改灯光颜色]]></content>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
</search>

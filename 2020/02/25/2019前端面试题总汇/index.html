<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="#前端面试题  2019各个公司前端面试题总汇  http相关1.https与http区别(百度) 1234567891011121314151617181920http是基于tcp协议的，https是基于ssl协议的，ssl协议在tcp协议的基础上的做了一层加密认证。https比http传输数据更安全，http是明文传递数据，不安全；而https传输数据经过加密。https需要证书来验证身份，证">
<meta property="og:type" content="article">
<meta property="og:title" content="2019前端面试题总汇">
<meta property="og:url" content="http://yoursite.com/2020/02/25/2019前端面试题总汇/index.html">
<meta property="og:site_name" content="Gray&#39;s Blog">
<meta property="og:description" content="#前端面试题  2019各个公司前端面试题总汇  http相关1.https与http区别(百度) 1234567891011121314151617181920http是基于tcp协议的，https是基于ssl协议的，ssl协议在tcp协议的基础上的做了一层加密认证。https比http传输数据更安全，http是明文传递数据，不安全；而https传输数据经过加密。https需要证书来验证身份，证">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5262488-291da39f66dbc28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">
<meta property="og:updated_time" content="2020-02-25T13:19:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2019前端面试题总汇">
<meta name="twitter:description" content="#前端面试题  2019各个公司前端面试题总汇  http相关1.https与http区别(百度) 1234567891011121314151617181920http是基于tcp协议的，https是基于ssl协议的，ssl协议在tcp协议的基础上的做了一层加密认证。https比http传输数据更安全，http是明文传递数据，不安全；而https传输数据经过加密。https需要证书来验证身份，证">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/5262488-291da39f66dbc28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp">





  
  
  <link rel="canonical" href="http://yoursite.com/2020/02/25/2019前端面试题总汇/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>2019前端面试题总汇 | Gray's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gray's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/2019前端面试题总汇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gray">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gray's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">2019前端面试题总汇

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-25 20:57:56 / 修改时间：21:19:02" itemprop="dateCreated datePublished" datetime="2020-02-25T20:57:56+08:00">2020-02-25</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>#前端面试题</p>
<blockquote>
<p>2019各个公司前端面试题总汇</p>
</blockquote>
<h1 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h1><p>1.https与http区别(百度)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http是基于tcp协议的，https是基于ssl协议的，ssl协议在tcp协议的基础上的做了一层加密认证。</span><br><span class="line">https比http传输数据更安全，http是明文传递数据，不安全；而https传输数据经过加密。</span><br><span class="line">https需要证书来验证身份，证书需要购买，http不需要。</span><br><span class="line">https默认端口号是443，http默认是80。</span><br><span class="line">https不能向http发出请求。</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">了解https通讯过程：</span><br><span class="line"></span><br><span class="line">（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</span><br><span class="line"></span><br><span class="line">（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</span><br><span class="line"></span><br><span class="line">（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</span><br><span class="line"></span><br><span class="line">（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</span><br><span class="line"></span><br><span class="line">（5）Web服务器利用自己的私钥解密出会话密钥。</span><br><span class="line"></span><br><span class="line">（6）Web服务器利用会话密钥加密与客户端之间的通信</span><br></pre></td></tr></table></figure>
<p>2.http请求过程及拿到响应后的渲染过程？（苏宁）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http请求过程：</span><br><span class="line">1.浏览器检查当前请求的url是否存在强缓存？命中强缓存，则缓存中读取。</span><br><span class="line">2.dns解析：</span><br><span class="line">  a.浏览器缓存的dns解析，是否存在。</span><br><span class="line">  b.操作系统DNS缓存中搜索</span><br><span class="line">  c.本地host进行dns解析。</span><br><span class="line">  d.向dns服务器发起请求进行dns解析</span><br><span class="line">3.建立tcp链接，三次握手。</span><br><span class="line">4.浏览器发出http请求</span><br><span class="line">5.服务器分析路由，处理请求，返回响应。</span><br><span class="line">6.浏览器接受响应，渲染页面，构建dom</span><br><span class="line">7。关闭tcp链接（4次挥手）  </span><br><span class="line"></span><br><span class="line">渲染过程：</span><br><span class="line">1.解析html文件，浏览器按照文档流顺序，构建dom树。（深度遍历，当所有子节点都构建好后，才会去构建当前节点的下一个兄弟节点）</span><br><span class="line">2.浏览器解析css形成css规则树。</span><br><span class="line">3.根据dom树和css规则树，构造出渲染树。</span><br><span class="line">   渲染树：浏览器可以知道网页中有那些节点，各个节点的css以及他们从属关系</span><br><span class="line">   </span><br><span class="line">4.遍历渲染树，计算每个节点位置大小信息，然后进行绘制。</span><br><span class="line"></span><br><span class="line">扩展：重绘 和 回流</span><br><span class="line">重绘：dom的一部分进行重画，不影响整体布局。</span><br><span class="line">触发：css背景色...</span><br><span class="line">回流：重新计算渲染树，重新遍历渲染树，重新渲染，浪费性能；</span><br><span class="line">触发：宽高、字体、resize等。</span><br><span class="line">优化：利用文档碎片document.createDocumentFragment并不是真正的dom，操作dom；</span><br></pre></td></tr></table></figure>
<p>3.http缓存机制。(百度、滴滴都有问)</p>
<p><a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57" target="_blank" rel="noopener">点击查看详细浏览器缓存技术，面试难不倒</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">强缓存： </span><br><span class="line">    响应报文头：</span><br><span class="line">    catch-control：max-age=212121； 最长生效时常。</span><br><span class="line">    expires:服务器绝对时间</span><br><span class="line">    </span><br><span class="line">    客户端发请求前，会用当前客户端时间与 （上次请求时间+max-age）进行比较，命中则走缓存。</span><br><span class="line">    expires是一个绝对时间，采用的是服务器的。客户端发送请求前，用客户端时间与这个时间进行比较，命中则走缓存。</span><br><span class="line">    max-age优先级比expires高，并且更加靠谱；</span><br><span class="line">    </span><br><span class="line">弱缓存（协商缓存）:</span><br><span class="line">    响应报文头:</span><br><span class="line">    last-modified：最后一次修改时间</span><br><span class="line">    Etag：当前请求的资源生成的一个唯一标识，只要资源不一样这个串就不一样</span><br><span class="line">    </span><br><span class="line">    请求报文头：</span><br><span class="line">    if-modified-since:缓存中文件的最后修改时间</span><br><span class="line">    if-None-Match:缓存中文件的etag</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    客户端发出请求，携带if-modified-since，if-None-Match字段，服务器收到请求 与当前文件的最后修改时间和</span><br><span class="line">    重新生成etag进行比较，命中则返回304； </span><br><span class="line">    如果命中if-none-match，返回304的响应头中，会携带服务器最新生成的etag;</span><br><span class="line">    如果命中if-modified-since则304响应头中不会携带last-modified，因为最后修改时间没有改变。</span><br><span class="line">    </span><br><span class="line">    注意：etag优先级比 last-modified要高。但是各有优缺点；</span><br><span class="line">        分布式系统里多台机器文件的last-modified必须保持一致，要不负载均衡到不同机器导致对比失败。</span><br><span class="line">        分布式系统计量关闭掉etag，因为每台服务器生成的etag都不一样。</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    使用：协商缓存需要配合强缓存使用，</span><br></pre></td></tr></table></figure></p>
<p>4.http get和post区别？（马蜂窝）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET在浏览器回退时是无害的，而POST会再次提交请求。</span><br><span class="line"></span><br><span class="line">GET产生的URL地址可以被Bookmark，而POST不可以。</span><br><span class="line"></span><br><span class="line">GET请求会被浏览器主动cache，而POST不会，除非手动设置。</span><br><span class="line"></span><br><span class="line">GET请求只能进行url编码，而POST支持多种编码方式。</span><br><span class="line"></span><br><span class="line">GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</span><br><span class="line"></span><br><span class="line">GET请求在URL中传送的参数是有长度限制的，而POST么有。</span><br><span class="line">get传送的数据量较小，不能大于2KB。post传送的数据量较大</span><br><span class="line"></span><br><span class="line">对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</span><br><span class="line"></span><br><span class="line">GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 </span><br><span class="line"></span><br><span class="line">GET参数通过URL传递，POST放在Request body中。</span><br><span class="line"></span><br><span class="line">GET产生一个TCP数据包；POST产生两个TCP数据包</span><br><span class="line">对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</span><br><span class="line">而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</span><br></pre></td></tr></table></figure>
<p>5.http状态码（百度，水滴筹，今日头条）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">200 成功</span><br><span class="line">5** 服务器</span><br><span class="line">304 缓存</span><br><span class="line">301 永久重定向</span><br><span class="line">302 临时重定向</span><br><span class="line">400 Bad Request，通用的客户端错误状态，当其他4XX响应代码不适用时，就采用400</span><br><span class="line">401 权限不够访问该资源。</span><br><span class="line">404 not found 当客户端所请求的URI不对应于任何资源时，发送此响应代码，找不到资源。</span><br><span class="line">403 Forbidden 服务器拒绝访问</span><br></pre></td></tr></table></figure></p>
<p>6.列举你所知道的请求头中的字段和响应头中的字段（美团，小米）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">请求头</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01 //告诉服务器,客户端支持的数据类型</span><br><span class="line">Content-Type: application/x-www-form-urlencoded; charset=UTF-8 //告诉服务器,发送的数据类型</span><br><span class="line">Origin: http://dev-mrytuan.chuchujie.com            //源</span><br><span class="line">Referer: http://dev-mrytuan.chuchujie.com/          //源页面</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36</span><br><span class="line">// 浏览器信息</span><br><span class="line">cookie:&apos;&apos;,                  //cookie信息</span><br><span class="line">if-modified-since:xxxxx          //上次请求响应头返回的最后修改时间</span><br><span class="line">if-none-match:xxx               //上次请求响应头返回的etag信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">options请求</span><br><span class="line"> Access-Control-Request-Method：，用来列出浏览器的CORS请求会用到哪些HTTP方法</span><br><span class="line"> Access-Control-Request-Headers：浏览器CORS请求会额外发送的头信息字段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">响应头：</span><br><span class="line">Access-Contronl-Allow-origin:* ，//允许源访问</span><br><span class="line">access-control-allow-methods：get ,post //允许请求方式</span><br><span class="line">access-control-allow-headers：&apos;name&apos;    //允许携带的请求头</span><br><span class="line">access-control-expose-headers：&apos;name&apos;    //允许浏览器读取的头信息</span><br><span class="line">access-control-allow-credentials:true //表示服务器允许浏览器携带cookie发送</span><br><span class="line">content-type: application/json         响应数据格式</span><br><span class="line">date: Tue, 02 Apr 2019 16:30:02 GMT   //服务器时间</span><br><span class="line">catch-control:max-age=36000             //强缓存最强生效时长</span><br><span class="line">expires:xx-xx-xx                        //服务器失效绝对时间</span><br><span class="line">last-modified：xxx-xxx-xx                //服务器最后修改时间</span><br><span class="line">etag：xxxxxx                             //服务器资源唯一标示符          </span><br><span class="line"></span><br><span class="line">options</span><br><span class="line">  Access-Control-Max-Age：秒,                      本次预检请求的有效期</span><br></pre></td></tr></table></figure></p>
<p>7.复杂请求的与简单请求的区别<br> <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">阮一峰详解</a><br>  复杂请求 会比 简单请求多一个options请求（预检查请求）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">cors请求分两种:简单请求 和非简单请求</span><br><span class="line"></span><br><span class="line">==============================================</span><br><span class="line">简单请求：</span><br><span class="line"> 浏览器请求头中会默认增加origin字段，表示来自哪个源</span><br><span class="line"> 服务器接收请求后，根据指定的源作出回应。</span><br><span class="line"> 响应头中：Access-Control-Allow-Origin:* || domain</span><br><span class="line">        Access-Control-Allow-Credentials:true， //表示是否允许跨域携带cookie。（后续进行讲解）</span><br><span class="line">        Access-Control-Expose-Headers：xxx      //指定浏览器可以获取到的 自定义响应头</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=============================================        </span><br><span class="line">非简单请求：</span><br><span class="line"> 出现条件：请求方法是PUT或DELETE，</span><br><span class="line">         Content-Type字段的类型是application/json</span><br><span class="line">         增加额外的header字段；   </span><br><span class="line"> 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;options请求（preflight）</span><br><span class="line"> </span><br><span class="line"> 浏览器发出options请求头：</span><br><span class="line">   origin:源</span><br><span class="line">   Access-Control-Request-Method：，用来列出浏览器的CORS请求会用到哪些HTTP方法</span><br><span class="line">   Access-Control-Request-Headers：浏览器CORS请求会额外发送的头信息字段</span><br><span class="line">   </span><br><span class="line"> 服务器返回options响应头：</span><br><span class="line">   Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">   Access-Control-Allow-Methods: GET, POST, PUT    服务器支持的所有跨域请求的方法</span><br><span class="line">   Access-Control-Allow-Headers: X-Custom-Header   表示服务器支持的所有头信息字段</span><br><span class="line">   Access-Control-Max-Age：秒,                      本次预检请求的有效期</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"> 服务器如果否定了options请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。浏览器就</span><br><span class="line"> 会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"> ====================================</span><br><span class="line"> </span><br><span class="line"> withCredentials属性</span><br><span class="line"> cors请求不发送cooki，如果要发送cookie到服务器，一方面要服务器同意。</span><br><span class="line"> Access-Control-Allow-Origin：不能设置*号，必须指定和明确的、与请求网页一致的域名</span><br><span class="line"> Access-Control-Allow-credentials：true；//这个只能设为true；如果不需要cookie，则删除该字段即可。</span><br><span class="line"> </span><br><span class="line"> 另一方面，浏览器ajax需要打开 withCredentials      </span><br><span class="line"> var xhr = new XMLHttpRequest();</span><br><span class="line"> xhr.withCredentials = true; </span><br><span class="line"> </span><br><span class="line"> 特点：Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，</span><br><span class="line"> 且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</span><br><span class="line"> </span><br><span class="line"> a.com 请求b.com ，设置了此属性，携带的cookie也只能是b.com 这个域下的cookie；</span><br></pre></td></tr></table></figure></p>
<p>8.http2 和http1.1的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[区别详解](https://juejin.im/post/5a4dfb2ef265da43305ee2d0)</span><br><span class="line">1.首部压缩，使报头更紧凑，更快速传输</span><br><span class="line">2.多路复用，</span><br><span class="line">在HTTP1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制。超过限制数目的请求会被阻塞</span><br><span class="line">http2中，只使用一个链接即可并行发送多个请求和响应，而且互不影响</span><br><span class="line"></span><br><span class="line">3.支持服务器推送</span><br><span class="line">如果一个请求是由你的主页发送的，服务器可能会响应主页内容、logo以及样式表，因为他知道客户端会用到这些东西。</span><br><span class="line">这样不但减轻了数据传送冗余步骤，也加快了页面响应的速度，提高了用户体验。</span><br></pre></td></tr></table></figure>
<h1 id="js基础相关"><a href="#js基础相关" class="headerlink" title="js基础相关"></a>js基础相关</h1><p>1.js继承？原型链查找原理。（蚂蚁金服）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType)&#123; </span><br><span class="line">    // 继承父类的原型</span><br><span class="line">    var prototype = Object.create(superType.prototype);</span><br><span class="line">    // 重写被污染的construct</span><br><span class="line">    prototype.constructor = subType; </span><br><span class="line">    // 重写子类的原型  </span><br><span class="line">    subType.prototype = Object.assign(prototype, subType.prototype); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.es6 class继承如何实现？（蚂蚁金服）</p>
<p>3.var let const 区别 （基本每个公司都问）</p>
<p>4.promise的特点，使用及原理。（基本每个公司都问）</p>
<p><a href="https://segmentfault.com/a/1190000013871753" target="_blank" rel="noopener">手写promise</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">特点：then链式调用</span><br><span class="line">     catch捕获</span><br><span class="line">     all方法</span><br><span class="line">     race方法</span><br><span class="line">     promise对象三种状态 pendding,fulfilled,rejected;</span><br><span class="line">     状态改变，只能改一次；</span><br><span class="line">     promise对象已经是成功状态或是失败状态时，都可以继续通过then传入函数，会通过当前的状态，来决定执行成功还失败，并且把结果或是错误传给相应的函数。</span><br><span class="line">      </span><br><span class="line">原理：状态机 + then方法返回新的promise2对象实现链式调用；</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">new promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        resolve(&apos;成功&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(()=&gt;&#123;&#125;,()=&gt;&#123;&#125;).catch(e=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">Promise.all([promise1,promise2]).then();</span><br><span class="line">Promise.race([promise1,promise2]).then();</span><br><span class="line">Promise.resolve(1)</span><br><span class="line">Promise.reject(1)</span><br><span class="line">Promise.deferred();</span><br></pre></td></tr></table></figure></p>
<p>5.generator函数的使用及原理 （蚂蚁金服）</p>
<p><a href="https://segmentfault.com/a/1190000014028204" target="_blank" rel="noopener">generator</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">generator 函数可以控制函数的执行，类似将函数分割成多个小函数，依次执行；</span><br><span class="line">用 * 表示一个generator 函数，用 yield 控制函数执行，并且产出；</span><br><span class="line">generator是有两部分组成；* 表示 的函数 是生成器，函数执行的返回结果是迭代器；</span><br><span class="line">迭代器.next();会将yield的值 返回，&#123;value:&apos;返回值&apos;，done：&apos;是否迭代完成&apos;&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line"></span><br><span class="line">function *read()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    var content1 = yield &apos;qs&apos;;</span><br><span class="line">    console.log(content1);</span><br><span class="line">    var content2 = yield &apos;9&apos;;![图片描述][1]</span><br><span class="line">    console.log(content2);</span><br><span class="line">    return content2;</span><br><span class="line">&#125;</span><br><span class="line">var it = read();</span><br><span class="line">var a = it.next() //输出 1  a:&#123;value:&apos;qs&apos;,done:false&#125;</span><br><span class="line">var b = it.next(&apos;hello&apos;)//输出hello  b:&#123;value:&apos;9&apos;,done:false&#125;</span><br><span class="line">var c = it.next(&apos;generator&apos;)//输出generator  c:&#123;value:&apos;generator&apos;,done:true&#125;</span><br><span class="line">var d = it.next(&apos;123&apos;)//输出generator  c:&#123;value:undefined,done:true&#125;</span><br><span class="line">console.log(a,b,c,d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用：一般和promise结合使用；</span><br><span class="line"></span><br><span class="line">function *g()&#123;</span><br><span class="line">    let result1 = yield ajax(&apos;1&apos;);</span><br><span class="line">    let result2 = yield ajax(result1);</span><br><span class="line">    return result2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ite = g();</span><br><span class="line">ite.next().value.then(res=&gt;&#123;</span><br><span class="line">    ite.next(res).value.then(res=&gt;&#123;</span><br><span class="line">        let result = ite.next(res).value;</span><br><span class="line">        console.log(result)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//为了更好的结合promise使用，出现了co库；</span><br><span class="line">//把一个生成器函数的迭代器，迭代完成后，统一执行一个成功回调；</span><br><span class="line"></span><br><span class="line">let co = require(&apos;co&apos;);</span><br><span class="line"></span><br><span class="line">function *g()&#123;</span><br><span class="line">    let result1 = yield ajax(&apos;1&apos;);</span><br><span class="line">    let result2 = yield ajax(result1);</span><br><span class="line">    return result2;</span><br><span class="line">&#125;</span><br><span class="line">co(g).then(res=&gt;&#123;console.log(res)&#125;);</span><br><span class="line"></span><br><span class="line">//co库的原理：利用next产出值的done的状态，去判断是否需要再次递归执行next方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function co(g)&#123;</span><br><span class="line">    let ite = g();</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        function next(data)&#123;</span><br><span class="line">            let &#123;value,done&#125; = item.next(data)</span><br><span class="line">            if(!done)&#123;</span><br><span class="line">                value.then(res=&gt;&#123;</span><br><span class="line">                    next(res)</span><br><span class="line">                &#125;,reject)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.es6 解构赋值和数组的操作方法</p>
<p>7.讲一下js循环事件池event loop，微任务和宏任务 （boss直聘、小米，苏宁）</p>
<p><a href="https://juejin.im/post/5aa5dcabf265da239c7afe1e" target="_blank" rel="noopener">浏览器event loop 和node event-loop</a></p>
<p>浏览器的event loop<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">js执行会存在一个执行栈，当前执行的同步代码都会放到执行栈中执行(宏任务)；</span><br><span class="line">同步代码执行过程中，如果遇到异步代码（settIimeout、promise等）,会将他们挂起，继续执行同步代码；</span><br><span class="line">同步代码执行完毕后，执行栈清空，会去查看微任务队列是否有可执行函数，然后拿到执行栈执行；</span><br><span class="line">当微任务队列执行完成后， 会去宏任务取一个任务放到执行栈执行，执行完成后再去查看微任务是不是有可执行函数，</span><br><span class="line">有的话取到执行栈执行；如此循环下去，就是event loop；</span><br><span class="line"></span><br><span class="line">挂起的异步代码，可执行后，会放到异步任务队列；异步任务队列分为两种队列，一种是微任务(promise,process.nextTick)</span><br><span class="line">一种是宏任务（setTimeout等）；</span><br><span class="line">微任务包括 process.nextTick ，promise ，MutationObserver。</span><br><span class="line">宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">执行完主执行线程中的任务。</span><br><span class="line">取出Microtask Queue中任务执行直到清空。</span><br><span class="line">取出Macrotask Queue中一个任务执行。</span><br><span class="line">取出Microtask Queue中任务执行直到清空。</span><br><span class="line">重复3和4。</span><br></pre></td></tr></table></figure></p>
<p>node环境 event loop 是区分阶段的；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">按照我们的循环的6个阶段依次执行，每次拿出当前阶段中的全部任务执行，清空NextTick Queue，清空Microtask Queue。再执行下一阶段，全部6个阶段执行完毕后，进入下轮循环。即：</span><br><span class="line"></span><br><span class="line">清空当前循环内的Timers Queue，清空NextTick Queue，清空Microtask Queue。</span><br><span class="line">清空当前循环内的I/O Queue，清空NextTick Queue，清空Microtask Queue。</span><br><span class="line">清空当前循环内的Check Queu，清空NextTick Queue，清空Microtask Queue。</span><br><span class="line">清空当前循环内的Close Queu，清空NextTick Queue，清空Microtask Queue。</span><br><span class="line">进入下轮循环。</span><br><span class="line"></span><br><span class="line">*注意：如果在timers阶段执行时创建了setImmediate则会在此轮循环的check阶段执行，如果在timers阶段创建了setTimeout，由于timers已取出完毕，则会进入下轮循环，check阶段创建timers任务同理。</span><br><span class="line"></span><br><span class="line">console.log(&apos;1&apos;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;4&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;5&apos;);</span><br><span class="line">        setTimeout(function()&#123;console.log(11)&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    process.nextTick(function () &#123;</span><br><span class="line">        console.log(10)</span><br><span class="line">    &#125;)</span><br><span class="line">    setImmediate(function () &#123;</span><br><span class="line">        console.log(12)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,500);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;7&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;8&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    process.nextTick(function () &#123;</span><br><span class="line">        console.log(9)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,500)</span><br><span class="line">// 第一次事件环</span><br><span class="line">//timer 阶段 1，2，4，6，7，; nexttick:10,9;//微任务队列  5，8</span><br><span class="line">//io 阶段 无</span><br><span class="line">//check 阶段 12</span><br><span class="line">//close 阶段 无</span><br><span class="line"></span><br><span class="line">//第二次事件环</span><br><span class="line">//timer 阶段 11;</span><br><span class="line">//io 阶段 无</span><br><span class="line">//check 阶段</span><br><span class="line">//close 阶段</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">两种环境对比：</span><br><span class="line">console.log(&apos;1&apos;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;4&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;5&apos;); </span><br><span class="line">        setTimeout(function()&#123;console.log(100)&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,500)</span><br><span class="line">   </span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&apos;6&apos;);</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&apos;7&apos;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&apos;8&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,500)</span><br><span class="line"></span><br><span class="line">浏览器执行：</span><br><span class="line">1，2，4，5，6，7，8 100</span><br><span class="line"></span><br><span class="line">node</span><br><span class="line">1，2，4，6，7，5，8，100；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(1);</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(()=&gt;&#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;)</span><br><span class="line">setImmediate(()=&gt;&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">&#125;)</span><br><span class="line">new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">    resolve();</span><br><span class="line">    console.log(6)</span><br><span class="line">&#125;).then(()=&gt;&#123;</span><br><span class="line">    console.log(7)</span><br><span class="line">&#125;)</span><br><span class="line">//代码从上往下往下执行：</span><br><span class="line">// 1,5,6 同步执行；然后查看nextTick,输出3；然后查看微任务列表，输出7；输出7</span><br><span class="line">//然后timmer 阶段：输出2，无nextTick 无微任务</span><br><span class="line">// 然后io阶段，无</span><br><span class="line">//然后check阶段：Immediate执行输出 4；</span><br><span class="line">// 然后close阶段，无</span><br></pre></td></tr></table></figure>
<p>8.js的垃圾回收处理机制的原理？（马蜂窝，美团）</p>
<p>(垃圾处理机制)[<a href="https://www.cnblogs.com/guoyongfeng/p/3907994.html]" target="_blank" rel="noopener">https://www.cnblogs.com/guoyongfeng/p/3907994.html]</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">不再用到的内存（一个不用到的值）没有及时释放，就叫做内存泄漏（memory leak）。</span><br><span class="line"></span><br><span class="line">垃圾回收机制：引用计数</span><br><span class="line">最常使用的方法叫做&quot;引用计数&quot;（reference counting）：语言引擎有一张&quot;引用表&quot;，</span><br><span class="line">保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就</span><br><span class="line">表示这个值不再用到了，因此可以将这块内存释放</span><br><span class="line"></span><br><span class="line">JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，</span><br><span class="line">他就知道不再需要这个对象，可以把它所占用的内存释放掉了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr = [1,2,3,4]</span><br><span class="line">数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数</span><br><span class="line">为1。尽管后面的代码没有用到arr，它还是会持续占用内存;就会造成内存泄漏</span><br><span class="line"></span><br><span class="line">arr = null;</span><br><span class="line">如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">垃圾回收机制:标记清除：</span><br><span class="line">js中最常用的垃圾回收方式就是标记清除。</span><br><span class="line">当变量进入环境时，例如，在一个函数中声明一个变量，就将这个变量标记为&quot;进入环境&quot;，</span><br><span class="line">从逻辑上讲，永远不能释放进入环境变量所占用的内存，因为只要执行流进入相应的环境，</span><br><span class="line">就可能会用到它们。而当变量离开环境时，则将其标记为&quot;离开环境&quot;</span><br></pre></td></tr></table></figure></p>
<p>9.localstorage、sessionStorage 、cookie区别？（水滴）</p>
<p>二级域名是否可以取到一级域名的数据？<br>cookie是可以的 ，只要在一个主域即可<br>localstorage不可以，他是跨站点的，只要域名变了就取不到了。</p>
<p>10.什么是闭包，说下项目中应用场景？（水滴）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放</span><br><span class="line"> 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。</span><br><span class="line"> </span><br><span class="line"> 场景：</span><br><span class="line"> 1.可以实现公有变量，函数外或在其他函数中访问某一函数内部的参数</span><br><span class="line">  function add() &#123;</span><br><span class="line">           var num = 0;</span><br><span class="line">           function demo()&#123;</span><br><span class="line">              num++;</span><br><span class="line">              console.log(num);</span><br><span class="line">              &#125;</span><br><span class="line">              return demo;</span><br><span class="line">         &#125;</span><br><span class="line">  var test = add();</span><br><span class="line">  test();//1</span><br><span class="line">  test();//2</span><br><span class="line"> </span><br><span class="line">2.为节点循环绑定click事件，在事件函数中使用当次循环的值或节点，而不是最后一次循环的值或节点</span><br><span class="line"></span><br><span class="line">3.计数器</span><br><span class="line">  function checkCount(target)&#123;</span><br><span class="line">      let count = 0;</span><br><span class="line">      let callbacks = [];</span><br><span class="line">      return function(fn)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            if(count == target)&#123;</span><br><span class="line">               callbacks.forEach(fn=&gt;fn())</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               callbacks.push(fn)</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  let d = checkCount(3);</span><br><span class="line">  d(fn);</span><br><span class="line">  d(fn);</span><br><span class="line">  d(n)</span><br><span class="line">  </span><br><span class="line">  4.函数节流和防抖</span><br></pre></td></tr></table></figure></p>
<p>11.ajax工作原理？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;GET&apos;,&apos;/api&apos;,true);//true表示异步</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">      console.log(xhr.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤：1.创建xhr请求对象</span><br><span class="line">     2.创建http请求</span><br><span class="line">     3.监听状态变化</span><br><span class="line">     4.根据状态码处理结果,</span><br><span class="line">            ⑴未初始化状态。在创建完XMLHttpRequest对象时，该对象处于未初始化状态，此时XMLHttpRequest对象的readyState属性值为0。</span><br><span class="line">     </span><br><span class="line">            ⑵初始化状态。在创建完XMLHttpRequest对象后使用open()方法创建了HTTP请求时，该对象处于初始化状态。此时XMLHttpRequest对象的readyState属性值为1。</span><br><span class="line">     </span><br><span class="line">            ⑶发送数据状态。在初始化XMLHttpRequest对象后，使用send()方法发送数据时，该对象处于发送数据状态，此时XMLHttpRequest对象的readyState属性值为2。</span><br><span class="line">     </span><br><span class="line">            ⑷接收数据状态。Web服务器接收完数据并进行处理完毕之后，向客户端传送返回的结果。此时，XMLHttpRequest对象处于接收数据状态，XMLHttpRequest对象的readyState属性值为3。</span><br><span class="line">     </span><br><span class="line">            ⑸完成状态。XMLHttpRequest对象接收数据完毕后，进入完成状态，此时XMLHttpRequest对象的readyState属性值为4。此时接收完毕后的数据存入在客户端计算机的内存中，可以使用responseText属性或responseXml属性来获取数据。</span><br><span class="line">     </span><br><span class="line">      只有在XMLHttpRequest对象完成了以上5个步骤之后，才可以获取从服务器端返回的数据。因此，如果要获得从服务器端返回的数据，就必须要先判断XMLHttpRequest对象的状态</span><br><span class="line">     5.发送请求</span><br></pre></td></tr></table></figure>
<p>12.js事件代理？（传智播客，58，瓜子二手车）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</span><br><span class="line"></span><br><span class="line">举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</span><br><span class="line"></span><br><span class="line">jquery:</span><br><span class="line">$(&quot;#nav&quot;).on(&apos;click&apos;,function(e)&#123;</span><br><span class="line">    $(e.target) =&gt;是每个点击的项目</span><br><span class="line">    $(this) =&gt;nav</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">$(&apos;#nav&apos;).on(&apos;click&apos;,&apos;li&apos;,function()&#123;</span><br><span class="line">   $(this) =&gt;点击的每一项</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展 jsdom事件流阶段：</span><br><span class="line">   捕获阶段-&gt;目标阶段-&gt;冒泡阶段</span><br><span class="line">   外内   -&gt;  当前 -&gt;冒泡</span><br><span class="line">   </span><br><span class="line">   如何执行冒泡 在捕获？</span><br><span class="line">   在捕获阶段的函数暂缓执行，等冒泡执行完后在执行捕获函数。</span><br></pre></td></tr></table></figure></p>
<p>13.js中this是如何工作的（基本都问）</p>
<p>14.怎么判断引用数据类型？（为什么能用Object.prototype.toString.call()去判断？）（水滴）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.instanceof 判断不准确</span><br><span class="line">var a = [];</span><br><span class="line">a instanceof Array  true</span><br><span class="line">a instanceof Object  true </span><br><span class="line"></span><br><span class="line">2.Object.prototype.toString.call([])  &apos;[object Array]&apos;</span><br><span class="line">  Object.prototype.toString.call(&#123;&#125;)   &quot;[object Object]&quot;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">3.isPrototypeOf</span><br><span class="line">Array.prototype.isPrototypeOf([]) true</span><br><span class="line">Object.prototype.isPrototypeOf([]) true</span><br><span class="line"> </span><br><span class="line"> isPrototypeOf 与instanceOf一样 都是查找原型链上是否存在。</span><br><span class="line"></span><br><span class="line">4.[].constructor == Array.prototype.constructor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展：</span><br><span class="line">Array.toString == Function.prototype.toString  true，</span><br><span class="line">根据原型链查找，查到Function.prototype.toString就停了。不会查到Object.prototype</span><br><span class="line"></span><br><span class="line">[].toString == Array.prototype.toString  true.</span><br><span class="line">根据原型链查找，查到Array.prototype.toString就停了。不会查到Object.prototype</span><br><span class="line"></span><br><span class="line">Array,Function 都在各自的原型上重新定义了toString方法，阻断了查找。</span><br></pre></td></tr></table></figure>
<p>15.js变量提升和作用域查找？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">console.log(type a) //undefined  变量提升</span><br><span class="line">console.log(type b) //err:b is not defined ,后续代码不执行</span><br><span class="line">console.log(type c) </span><br><span class="line">var a = function()&#123;return true&#125;; //变量提升</span><br><span class="line">window.b = function()&#123;  //给window创建属性，不存在变量提升</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a() &amp;&amp; b() &amp;&amp; c())</span><br><span class="line">function c()&#123;return c&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">	a:1,</span><br><span class="line">	f()&#123;</span><br><span class="line">		return this.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(o.f()); //1</span><br><span class="line">var o1 = o;</span><br><span class="line">console.log(o1.f());//1</span><br><span class="line">var o2 = o.f;</span><br><span class="line">console.log(o2()); //undefined  =&gt;this是window，window.a undefined;</span><br><span class="line">o.a=  5;</span><br><span class="line">console.log(o1.f());//5  堆内存 和 栈内存</span><br><span class="line">var o3 = &#123;a:5&#125;; </span><br><span class="line">console.log(o.f.call(o3)) //5</span><br></pre></td></tr></table></figure></p>
<p>16.call apply bind 区别？如何实现？（基本都问）</p>
<p>17.实现跨域的方法？说一下JSOP的原理？（水滴）<br>（nginx服务器反向代理)[<a href="https://segmentfault.com/a/1190000012859206]" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012859206]</a><br>(postMessage + iframe实现页面跨域)[<a href="http://www.cnblogs.com/zhouzme/p/5758386.html]" target="_blank" rel="noopener">http://www.cnblogs.com/zhouzme/p/5758386.html]</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">jsonp;</span><br><span class="line">   利用script标签src属性不受同源策略影响，可实现跨域；</span><br><span class="line">   通过与api方，对接好 回调参数字段～ cb=fn,fn在前端是一个全局的方法。后端返回script代码&quot;fn(&#123;name:1&#125;)&quot;,浏览器会执行；</span><br><span class="line">     前端代码：</span><br><span class="line">     function b(data) &#123;</span><br><span class="line">           console.log(data)</span><br><span class="line">       &#125;</span><br><span class="line">       let script = document.createElement(&apos;script&apos;)</span><br><span class="line">       script.src = &quot;http://localhost:3002/jsonp?cb=b&quot;;</span><br><span class="line">       document.body.appendChild(script)</span><br><span class="line">     node模拟后端：</span><br><span class="line">     </span><br><span class="line">     http.createServer((req, res) =&gt; &#123;</span><br><span class="line">         let &#123;pathname, query&#125; = url.parse(req.url, true);</span><br><span class="line">         if (pathname == &apos;/jsonp&apos;) &#123;</span><br><span class="line">            let school = JSON.stringify(&#123;name:&apos;zfpx&apos;&#125;);</span><br><span class="line">            // res.end(`var a  = $&#123;school&#125;`) //在全局就可以获取到 变量a</span><br><span class="line">            //  res.end(`b($&#123;school&#125;)`)</span><br><span class="line">             res.end(`$&#123;query.cb&#125;($&#123;school&#125;)`)</span><br><span class="line">             return ;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).listen(port, () =&gt; &#123;</span><br><span class="line">         console.log(`$&#123;port&#125; 服务器启动`)</span><br><span class="line">     &#125;);</span><br><span class="line">CORS</span><br><span class="line">   服务端响应：</span><br><span class="line">       res.setHeader(&apos;Access-Control-Allow-Origin&apos;,&quot;*&quot;);//设置允许访问的源</span><br><span class="line">       res.setHeader(&apos;Access-Control-Allow-Methods&apos;,&apos;GET,POST,PUT,DELETE,OPTIONS&apos;)</span><br><span class="line">       res.setHeader(&apos;Access-Control-Allow-headers&apos;,&apos;name&apos;)</span><br><span class="line">nginx服务器反向代理</span><br><span class="line"></span><br><span class="line">   //前端a.com 请求 后端api b.com/login 会出现跨域，</span><br><span class="line">   //在a.com所在服务器启动一个nginx代理服务器，监听a.com 的80端口；</span><br><span class="line">   //配置代理规则  ^/apis/ =&gt; b.com/ ,</span><br><span class="line">   //这让我们在请求a.com/apis/login 的时候，被nginx拦截，代理到 b.com/login</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">处理页面之间的跨域</span><br><span class="line"></span><br><span class="line">window.name+iframe 需要目标服务器响应window.name。</span><br><span class="line"></span><br><span class="line">window.location.hash+iframe 同样需要目标服务器作处理。</span><br><span class="line"></span><br><span class="line">html5的 postMessage+ifrme 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a.com/index.html </span><br><span class="line"></span><br><span class="line"> &lt;iframe src=&quot;b.com/index.html&quot; id=&quot;a&quot;&gt;</span><br><span class="line"> var data= &#123;name:1&#125;</span><br><span class="line"> document.getElementById(&quot;a&quot;).contentWindow.postMessage(data, &apos;*&apos;);</span><br><span class="line"> window.addEventListener(&apos;message&apos;,function(data)&#123;</span><br><span class="line">     </span><br><span class="line"> &#125;) </span><br><span class="line"> </span><br><span class="line">b.com/index.html</span><br><span class="line">注册监听消息事件：</span><br><span class="line">window.addEventListener(&apos;message&apos;,function(data)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;) </span><br><span class="line">//向父页面post消息</span><br><span class="line">window.parent.postMessage(&#123; </span><br><span class="line">            </span><br><span class="line"> &#125;, &apos;*&apos;);</span><br></pre></td></tr></table></figure></p>
<p>18.正则相关（小米,boss，头条）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.正则捕获规则</span><br><span class="line">b.如果是嵌套捕获，得到的顺序是什么样的。</span><br><span class="line">c.正则捕获的引用和反向引用是什么</span><br><span class="line">d.正则的匹配默认是贪婪匹配么</span><br></pre></td></tr></table></figure></p>
<p>19.[].toString()为啥会返回逗号隔开的字符串</p>
<p>20.数据proxy劫持与defineProperty对比。<br><a href="https://blog.csdn.net/qq_42833001/article/details/83302149" target="_blank" rel="noopener">defineProperty 和 proxy 对比</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">es5</span><br><span class="line">defineProperty:修改或者定义一个对象的新属性， 返回这个对象</span><br><span class="line"></span><br><span class="line">1.不能监听数组变化 </span><br><span class="line">push, pop, shift, unshift,splice, sort, reverse，这些能修改原数组的方法成为变异方法；</span><br><span class="line">vue的做法是把这些方法重写来实现数组的劫持；</span><br><span class="line"></span><br><span class="line">2.必须遍历对象的每个属性，单独设置；</span><br><span class="line">Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">3.必须深层遍历嵌套对象</span><br><span class="line">vue的深度劫持；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">知识：</span><br><span class="line">基础描述符</span><br><span class="line">configrable:false,默认false,表示该属性是否可以修改 描述符配置；</span><br><span class="line">enumerable:false,默认false，表示该属性是否可以枚举</span><br><span class="line"></span><br><span class="line">设置和获取描述符</span><br><span class="line">set(newval)&#123;&#125;</span><br><span class="line">get()&#123;&#125;</span><br><span class="line"></span><br><span class="line">赋值描述符</span><br><span class="line">value:&apos;&apos;,</span><br><span class="line">writable:false,表示值是否可被修改，默认false</span><br><span class="line"></span><br><span class="line">设置和获取描述符和赋值描述符，只能有一个出现，基础描述符可以一直存在。</span><br><span class="line"></span><br><span class="line">============================</span><br><span class="line">es6</span><br><span class="line">proxy 代理，将一个对象进行包装，从而可以代理 操作对象的一些行为；</span><br><span class="line"></span><br><span class="line">1.针对对象:针对整个对象,而不是对象的某个属性; 不用 遍历属性；</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  name: &apos;Eason&apos;,</span><br><span class="line">  age: 30</span><br><span class="line">&#125;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  get (target, key, receiver) &#123;</span><br><span class="line">    console.log(&apos;get&apos;, key)</span><br><span class="line">    return Reflect.get(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value, receiver) &#123;</span><br><span class="line">    console.log(&apos;set&apos;, key, value)</span><br><span class="line">    return Reflect.set(target, key, value, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy = new Proxy(obj, handler)</span><br><span class="line">proxy.name = &apos;Zoe&apos; // set name Zoe</span><br><span class="line">proxy.age = 18 // set age 18</span><br><span class="line"></span><br><span class="line">// Reflect.get 和 Reflect.set 可以理解为类继承里的 super，即调用原来的方法</span><br><span class="line">Reflect.get():获取对象身上某个属性的值，类似于 target[name]。</span><br><span class="line">Reflect.set():将值分配给属性的函数,返回一个Boolean，如果更新成功，则返回true。</span><br><span class="line"></span><br><span class="line">2.支持数组:不需要对数组的方法进行重载，省去了众多 hack</span><br><span class="line">let arr = [1,2,3]</span><br><span class="line">let proxy = new Proxy(arr, &#123;</span><br><span class="line">    get (target, key, receiver) &#123;</span><br><span class="line">        console.log(&apos;get&apos;, key)</span><br><span class="line">        return Reflect.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set (target, key, value, receiver) &#123;</span><br><span class="line">        console.log(&apos;set&apos;, key, value)</span><br><span class="line">        return Reflect.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.push(4)</span><br><span class="line">// 能够打印出很多内容</span><br><span class="line">// get push     (寻找 proxy.push 方法)</span><br><span class="line">// get length   (获取当前的 length)</span><br><span class="line">// set 3 4      (设置 proxy[3] = 4)</span><br><span class="line">// set length 4 (设置 proxy.length = 4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.嵌套支持: get 里面递归调用 Proxy 并返回</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  info: &#123;</span><br><span class="line">    name: &apos;eason&apos;,</span><br><span class="line">    blogs: [&apos;webpack&apos;, &apos;babel&apos;, &apos;cache&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  get (target, key, receiver) &#123;</span><br><span class="line">    console.log(&apos;get&apos;, key)</span><br><span class="line">    // 递归创建并返回</span><br><span class="line">    if (typeof target[key] === &apos;object&apos; &amp;&amp; target[key] !== null) &#123;</span><br><span class="line">      return new Proxy(target[key], handler)</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.get(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value, receiver) &#123;</span><br><span class="line">    console.log(&apos;set&apos;, key, value)</span><br><span class="line">    return Reflect.set(target, key, value, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let proxy = new Proxy(obj, handler)</span><br><span class="line">// 以下两句都能够进入 set</span><br><span class="line">proxy.info.name = &apos;Zoe&apos;</span><br><span class="line">proxy.info.blogs.push(&apos;proxy&apos;)</span><br></pre></td></tr></table></figure></p>
<p>21.js为什么要有protoType？如果没有会怎么样？(阿里)</p>
<p>22.generator函数？跟async有什么区别？（阿里）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">generator函数？跟async有什么区别？</span><br><span class="line">  async函数实际上是通过gnnerator函数实现的,实际上就是将一个generator函数自动执行的结果；</span><br><span class="line">  generator 需要配合 co这样的库，才方便调用；</span><br><span class="line">  async 是结合了co和generator的思想，实现的 ；</span><br><span class="line">  </span><br><span class="line">  async function fn()&#123;</span><br><span class="line">        let content1 = await ajax(&apos;1&apos;);</span><br><span class="line">        let content2 = await ajax(&apos;2&apos;);</span><br><span class="line">        return content2;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">  fn().then(res=&gt;&#123;</span><br><span class="line">  </span><br><span class="line">    //可以获取到content2</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  实际上实现的原理：</span><br><span class="line">  </span><br><span class="line">  function co(g)&#123;</span><br><span class="line">    let ite = g();</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        function next(data)&#123;</span><br><span class="line">            let &#123;value,done&#125; = ite.next(data);</span><br><span class="line">            if(!done)&#123;</span><br><span class="line">                if(value instanceOf Promise)&#123;</span><br><span class="line">                    value.then(res=&gt;&#123;</span><br><span class="line">                        next(res);</span><br><span class="line">                    &#125;,reject)</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    next(value)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  function fn()&#123;</span><br><span class="line">  </span><br><span class="line">    return co( </span><br><span class="line">            function *()&#123;</span><br><span class="line">               let content1 = yield ajax(&apos;1&apos;);</span><br><span class="line">               let content2 = yield ajax(&apos;2&apos;);</span><br><span class="line">               return content2;</span><br><span class="line">               </span><br><span class="line">         &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">`</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">23.</span><br><span class="line">mouseover和mouseenter的区别</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```$javascript</span><br><span class="line"></span><br><span class="line">mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/81eb68ae5eb1" target="_blank" rel="noopener">阮一峰es6要点总结——Proxy</a></p>
<h1 id="HTML-CSS相关"><a href="#HTML-CSS相关" class="headerlink" title="HTML+CSS相关"></a>HTML+CSS相关</h1><p>1.meta标签常用有哪些，列举？viewport属性有哪些分别代表什么（水滴）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">忽略页面中数字识别为电话 忽略email识别</span><br><span class="line">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;/&gt;</span><br><span class="line">关键字</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;楚楚推，楚楚推平台&quot;&gt;</span><br><span class="line">网页描述</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;楚楚推，分享生活，分享爱。&quot;&gt;</span><br><span class="line"></span><br><span class="line">允许加载哪个域的资源，防止xss攻击</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</span><br><span class="line"> </span><br><span class="line"> viewport虚拟窗口</span><br><span class="line"> width：控制 viewport 的大小，可以指定的一个值，如果 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。</span><br><span class="line"> height：和 width 相对应，指定高度。</span><br><span class="line"> initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</span><br><span class="line"> maximum-scale：允许用户缩放到的最大比例。</span><br><span class="line"> minimum-scale：允许用户缩放到的最小比例。</span><br><span class="line"> user-scalable：用户是否可以手动缩放</span><br><span class="line">&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.清除浮动方法？（水滴）<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a.添加空div，增加clear：both属性</span><br><span class="line">  </span><br><span class="line">  b.给父元素定义overflow：hidden，氟元素必须设置width</span><br><span class="line">  </span><br><span class="line">  c:给父元素增加伪元素 </span><br><span class="line">        .clearfix:after &#123;</span><br><span class="line">                clear: both;</span><br><span class="line">                content: &apos;&apos;;</span><br><span class="line">                font-size: 0;</span><br><span class="line">                display: block;</span><br><span class="line">                visibility: hidden;</span><br><span class="line">                height: 0;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>3.口述css盒子模型（水滴）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content-box:</span><br><span class="line">    可以使设置的宽度和高度值应用到元素的内容框，盒子的width只包含内容。即总宽度=margin+border+padding+width</span><br><span class="line">border-box:</span><br><span class="line"> 设置的width值其实是除margin外的border+padding+element的总宽度，盒子的width包含border+padding+内容；即总宽度=margin+width</span><br></pre></td></tr></table></figure>
<p>4.实现左右固定宽度中间自适应布局有哪几种？（水滴）</p>
<p>  a. 最外层元素 {padding:0 200px};<br>     所有子元素都向左浮动<br>     第一个子元素：width：100%；float：left<br>     第二个子元素：width：200px;float:left;margin-left:-100%;position:relative;left:-200px;<br>     第三个子元素：width：200px;float:left;margin-left:-200px;position:relative;left:200px;</p>
<p>  b.<br>     前两个子元素浮动，第三个子元素通过margin来控制宽度；<br>        <div><br>        <div style="width: 200px;height: 200px;float: left;background: red"></div><br>        <div style="width: 200px;height: 200px;float: right;background: green"></div><br>        <div style="height:200px;margin:0 200px;background: blueviolet"></div><br>        </div><br>  c.<br>    flex布局；<br>  <div style="display: flex;"><br>        <div style="width: 200px;height: 200px;background: red"></div><br>        <div style="flex: 1;height: 200px;background: yellow"></div><br>        <div style="width: 200px;height: 200px;background: green"></div><br>    </div></p>
<p>5.position属性有哪几种，区别？（水滴）<br>  static、relative、absolute、fixed。</p>
<p>6.左侧固定宽度，右侧自适应？ 多种。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">a.左侧设置固定宽并且左浮动，右侧加个margin-left;</span><br><span class="line">.box1&#123;</span><br><span class="line">	background: red;</span><br><span class="line">	width: 200px;</span><br><span class="line">	float: left;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">	background: darkcyan;</span><br><span class="line">  margin-left: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.calc 计算右侧宽度,右浮动</span><br><span class="line">.box1&#123;</span><br><span class="line">  background:red;</span><br><span class="line">  width:200px;</span><br><span class="line">  float:left;</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">  background:green;</span><br><span class="line">  width:cacl(100% - 200px)</span><br><span class="line">  float:right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.flex布局</span><br><span class="line"></span><br><span class="line">.outer&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  flex-direction:row;  </span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">  width:200px;</span><br><span class="line">  background:red</span><br><span class="line">&#125;</span><br><span class="line">.box2&#123;</span><br><span class="line">  flex:1;</span><br><span class="line">  background:green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d.左侧设置固定宽并且左浮动，右侧加overflow：hidden；</span><br><span class="line"></span><br><span class="line"> .box1&#123;</span><br><span class="line">    background:red;</span><br><span class="line">    width:200px;</span><br><span class="line">    float:left;</span><br><span class="line">  &#125;</span><br><span class="line">  .box2&#123;</span><br><span class="line">    background:green;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> e.absolute+margin</span><br><span class="line">   左侧设置固定宽并且绝对定位，右侧加margin-left；</span><br><span class="line">   .box1&#123;</span><br><span class="line">         background:red;</span><br><span class="line">         width:200px;</span><br><span class="line">         position:absolute;</span><br><span class="line">         left:0;</span><br><span class="line">       &#125;</span><br><span class="line">       .box2&#123;</span><br><span class="line">         background:green;</span><br><span class="line">         margin-left:200px;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>7.用css实现一个三角形，为什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.triangle &#123;</span><br><span class="line">            width : 0;</span><br><span class="line">            height: 0;</span><br><span class="line">            border : 100px solid transparent;</span><br><span class="line">            border-top : 100px solid blue; /*这里可以设置border的top、bottom、left、right四个方向的三角*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>8.div垂直水平居中，多种方式（宽高不限）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            margin-left: -100px;</span><br><span class="line">            margin-top: -100px;</span><br><span class="line">        &#125;</span><br><span class="line">        .box1&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            transform: translate(-50%,-50%);</span><br><span class="line">        &#125;</span><br><span class="line">        .box1&#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top:0;</span><br><span class="line">            left: 0;</span><br><span class="line">            right: 0;</span><br><span class="line">            bottom: 0;</span><br><span class="line">            margin: auto;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .parent&#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            align-items: center;</span><br><span class="line">            height: 100%;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>9.img i iframe video canvas q ol nav form em dl dt dd br hr audio abbr span<br>strong sub textarea  那些是块？</p>
<p>10.块元素 和行内元素有哪些?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">常用的 </span><br><span class="line">    div ul li  p h1 </span><br><span class="line">    </span><br><span class="line">    span i img input  a em  textarea</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">快元素：独占一行；自上至下；可设置狂傲</span><br><span class="line">行内元素：不独占一行；自左至右；设置宽高无效；设置margin padding，上下方向无效</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可继承：font相关 font-size family weight font-style</span><br><span class="line">      line-height</span><br><span class="line">      text-align</span><br><span class="line">      text-indent 文本缩进</span><br><span class="line">      color 字体颜色</span><br><span class="line">      word-spacing字间隔</span><br></pre></td></tr></table></figure></p>
<p>11.css高度宽度分别为视窗的20%的盒子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一种:width:20%;padding-bottom:20%;</span><br><span class="line">第二种：width:20vw;height:20vw</span><br></pre></td></tr></table></figure></p>
<h1 id="前端框架相关"><a href="#前端框架相关" class="headerlink" title="前端框架相关"></a>前端框架相关</h1><p>1.什么是mvvm？mvvm实现原理？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">双向数据绑定</span><br><span class="line">M 数据层</span><br><span class="line">V 视图层</span><br><span class="line">VM View-Modle层，主要用于数据和视图的通讯</span><br><span class="line"></span><br><span class="line">利用Object.definedProperty 对data属性的get 和set 进行拦截和监听，并对每个data属性创建一个订阅池。</span><br><span class="line">在编译dom阶段，对dom进行解析，&quot;v-**&quot; &quot;&#123;&#123;&#125;&#125;&quot;，每编译到一处， 完成首次渲染，而且注册一个监听者，添加到data属性的订阅池中。</span><br><span class="line">数据影响视图：当数据改变，则通知该属性对应订阅池中所有的watcher，进行更新。</span><br><span class="line">视图影响数据(v-model): 通过绑定事件，然后改变data属性值，data属性值发生改变，通知所有watcher更新视图。</span><br><span class="line"></span><br><span class="line">设计思想：发布订阅模式，es6 definedProperty拦截。</span><br><span class="line"></span><br><span class="line">某一个属性，具备多个watcher，存入到一个dep中。当属性变化，才会去执行dep中的watcher。是由被监听属性（目标属性所触发），所以属于观察者模式。</span><br></pre></td></tr></table></figure>
<p>2.vue兄弟组件传递数据？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">父传子：通过给子组件绑定属性传值，:data=&quot;&quot;。子组件接收通过props设置接收的属性。</span><br><span class="line">子传父：通过事件传值，给子组件绑定事件，@事件名=&quot;父组件方法&quot;,子组件改变了数据，</span><br><span class="line">通过this.$emit(事件名,data)通知父组件。</span><br><span class="line"></span><br><span class="line">兄弟组件传值:中间件</span><br><span class="line">1.</span><br><span class="line">创建一个单独的vm实例。</span><br><span class="line">通过vm.$on(&apos;事件名&apos;,方法)绑定事件</span><br><span class="line">通过vm.$emit(事件名，data)通知兄弟组件修改数据。</span><br><span class="line">2.合并到同一个父组件下，通过父组件进行传值。</span><br><span class="line">3.vuex</span><br></pre></td></tr></table></figure></p>
<p>3.vuex的使用场景？如何使用？原理？（阿里）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">应用场景:非父子关系的组件通信及共享数据，例如兄弟组件、祖孙组件。</span><br><span class="line">当你打算开发大型单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态</span><br><span class="line"> </span><br><span class="line">1.组件销毁，仍想保留数据，再进渲染组件直接获取数据。</span><br><span class="line">  举例：form表单弹窗组件，用户填写信息后，关闭弹窗。可在组件destroyed</span><br><span class="line">  时将用户填写信息保存到state中。在created时，读取state中数据进行渲染</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">2.有些组件构建和加载是依赖异步数据。v-if=&quot;&#123;&#123;store.userInfo.vip&#125;&#125;&quot;</span><br><span class="line"> 举例：有几个组件是与用户等级挂钩的，用户等级不同，展示的组件不同，并且这些组件</span><br><span class="line">     都在不同的父组件中。</span><br><span class="line">     可以将异步请求数据的方法和请求回来的数据保存到state中，集中管理调用。</span><br><span class="line">     这样异步请求结束，所有的组件就都能得到状态，从而进行渲染。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">3.多处共用数据，多处可更改数据，互相影响。</span><br><span class="line">举例：购物车，详情页添加、删除，购物车页面添加删除</span><br><span class="line">     消息列表消息数量</span><br><span class="line">     订单相关跳转路由，订单列表跳转订单详情，订单详情跳转订单评价，</span><br><span class="line">     不同路由之间订单数据共享。</span><br><span class="line"> </span><br><span class="line">============================================</span><br><span class="line">如何使用：</span><br><span class="line"></span><br><span class="line">============================================</span><br><span class="line">原理:</span><br><span class="line">1.全局注入store：</span><br><span class="line">vuex 利用插件机制调用install进行安装vuex，install过程中利用mixin混入，全局注册混入对象，将会影响所有之后创建的Vue实例。</span><br><span class="line">混入 beforeCreate 钩子，每个实例生成都会先调用混入的beforeCreate钩子（vuexInit），vueInit检查当前options中是否有store对象，</span><br><span class="line">如果没有则会去父组件中查找。</span><br><span class="line"></span><br><span class="line">a. Vue.use(Vuex) =&gt;安装Vuex插件,调用Vuex的install方法。</span><br><span class="line"></span><br><span class="line">b. Vuex.install =  function()&#123;</span><br><span class="line">    Vue.mixin(&#123; beforeCreate: vuexInit &#125;);</span><br><span class="line">&#125;</span><br><span class="line">store注入 vue的实例组件的方式，是通过vue的 mixin机制，借助vue组件的生命周期钩子beforeCreate 完成的。</span><br><span class="line">即 每个vue组件实例化过程中，会在 beforeCreate 钩子前调用 vuexInit 方法。</span><br><span class="line"></span><br><span class="line">c.vuexInit核心代码如下：</span><br><span class="line">this.$store = typeof options.store === &apos;function&apos;</span><br><span class="line">    ? options.store()</span><br><span class="line">    : options.store</span><br><span class="line">    </span><br><span class="line">this的指向，得益于mixin机制，this将指向 vue组件实例！最终，我们可以再vue组件实例上获得vuex的store </span><br><span class="line">对象的引用 $store！</span><br><span class="line"></span><br><span class="line">源码：</span><br><span class="line">function applyMixin (Vue) &#123;</span><br><span class="line">  var version = Number(Vue.version.split(&apos;.&apos;)[0]);</span><br><span class="line"></span><br><span class="line">  if (version &gt;= 2) &#123;</span><br><span class="line">    Vue.mixin(&#123; beforeCreate: vuexInit &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    var _init = Vue.prototype._init;</span><br><span class="line">    Vue.prototype._init = function (options) &#123;</span><br><span class="line">      if ( options === void 0 ) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      options.init = options.init</span><br><span class="line">        ? [vuexInit].concat(options.init)</span><br><span class="line">        : vuexInit;</span><br><span class="line">      _init.call(this, options);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function vuexInit () &#123;</span><br><span class="line">    var options = this.$options;</span><br><span class="line">    if (options.store) &#123;</span><br><span class="line">      this.$store = typeof options.store === &apos;function&apos;</span><br><span class="line">        ? options.store()</span><br><span class="line">        : options.store;</span><br><span class="line">    &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">      this.$store = options.parent.$store;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.数据响应式，state 和 getter数据更新如何映射到各个组件实例中自动更新，并update组件。</span><br><span class="line">某一组件store更新时，如何通知其他组件进行数据更新，和UI更新！通过简单分析可知，问题的根本就是组件通信的问题！</span><br><span class="line"></span><br><span class="line">原理：vuex的state是借助vue的响应式data实现的，getter是借助vue的computed属性实现的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在 new Vuex.Store(&#123;state,getters&#125;)实例过程中，</span><br><span class="line">Store的构造函数执行了这样一个函数 resetStoreVM(this, state); this-&gt;store实例，就是我们用到的this.$store</span><br><span class="line">作用:</span><br><span class="line">    初始化了一个vue实例_vm。</span><br><span class="line">    将state注入到该实例中，由于vue的data是响应式的，所以$$state 是响应式的。当我们在更改this.$store.state.xxx时，基于vue的data的响应式机制，所有相关的state.xxx的值都会自动更新，ui自动更新。</span><br><span class="line">    </span><br><span class="line">    将store.getters作为computed属性注入到_vm上，然后将store.getter映射出一个新的对象，定义get拦截去获取_vm.xxx;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">实际应用中,我们修改this.$store.state.xxx  =&gt; this.$store._vm.data.$$state =&gt; store._vm.$$state</span><br><span class="line">get state () &#123;</span><br><span class="line">    return this._vm._data.$$state</span><br><span class="line">  &#125;</span><br><span class="line">实际应用中，我们获取getter属性， this.$store.getters.xxx ,实际上取得的 this.$store._vm.xxx 取得是_vm的计算属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 源码:</span><br><span class="line"> function resetStoreVM (store, state, hot) &#123;</span><br><span class="line">    //处理getter</span><br><span class="line">    store.getters = &#123;&#125;;</span><br><span class="line">    var wrappedGetters = store._wrappedGetters;</span><br><span class="line">    var computed = &#123;&#125;;</span><br><span class="line">    forEachValue(wrappedGetters, function (fn, key) &#123;</span><br><span class="line">      computed[key] = function () &#123; return fn(store); &#125;;</span><br><span class="line">      Object.defineProperty(store.getters, key, &#123;</span><br><span class="line">        get: function () &#123; return store._vm[key]; &#125;,</span><br><span class="line">        enumerable: true // for local getters</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    //创建vue实例，响应数据</span><br><span class="line">    store._vm = new Vue(&#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        $$state: state</span><br><span class="line">      &#125;,</span><br><span class="line">      computed: computed</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>4.用vue-router实现导航切换 类似tab栏的那种；（一个tab有三个页，下面展示的内容怎么组件实现）</p>
<p>5.vue和react区别 </p>
<p><a href="https://www.sohu.com/a/244192046_100180425" target="_blank" rel="noopener">区别</a></p>
<p>6.vue 的watch中可以使用箭头函数吗</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不能使用,箭头函数在声明时就确定了this指向，指向的是父级作用域上下文。</span><br><span class="line">当函数执行时，里面的this并不是vue实例。</span><br></pre></td></tr></table></figure>
<p>7.vue自定义组件的双向绑定怎么实现？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件;</span><br><span class="line">&lt;search-input v-model=&quot;text&quot;&quot;&gt;&lt;/search-input &gt;</span><br><span class="line">等价于&lt;search-input v-bind:value=&quot;searchText&quot;</span><br><span class="line">                   v-on:input=&quot;searchText = $event&quot;&gt;&lt;/search-input &gt;</span><br><span class="line">                   </span><br><span class="line">所以 在组件内部的input标签上，就不能用v-model了</span><br><span class="line">为了让它正常工作，这个组件内的 &lt;input&gt; 必须：</span><br><span class="line">将其 value 特性绑定到一个名叫 value 的 prop 上</span><br><span class="line">在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出</span><br><span class="line"></span><br><span class="line">Vue.component(&apos;custom-input&apos;, &#123;</span><br><span class="line">  props: [&apos;value&apos;],</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      v-bind:value=&quot;value&quot;</span><br><span class="line">      v-on:input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>8.mvc和mvvm的区别，手画一个原理流程图，类似view model viewmodel的一个流程交互图</p>
<p>9.v-if 和 v-show的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏,首次渲染消耗大，适合频繁切换</span><br><span class="line">v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果，。具备懒惰性，不适合频繁切换，首次消耗小。</span><br></pre></td></tr></table></figure></p>
<p>10.v-if跟 v-else，如果太多了你可以怎么优化，可以用什么设计模式</p>
<p>11.<keep-alive></keep-alive>的作用是什么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;&lt;/keep-alive&gt; </span><br><span class="line">包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。</span><br><span class="line">用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素</span><br><span class="line">大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是</span><br><span class="line">一个频率很高的页面，那么就可以对列表组件使用&lt;keep-alive&gt;&lt;/keep-alive&gt;进行缓存，这样用户每次返回列表的时候，</span><br><span class="line">都能从缓存中快速渲染，而不是重新渲染.</span><br><span class="line"></span><br><span class="line">使用了 keep-alive组件的两种状态 </span><br><span class="line">actived  组件被激活时调用，</span><br><span class="line">deactived 组件被移除时调用</span><br></pre></td></tr></table></figure></p>
<p>12.mixin 全局混入</p>
<p><a href="https://cn.vuejs.org/v2/guide/mixins.html" target="_blank" rel="noopener">vue官方混入</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">混入规则： </span><br><span class="line"> 混入内容值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。</span><br><span class="line"> 混入的是钩子函数时 created...等，同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</span><br><span class="line"> </span><br><span class="line"> 特点：mixin中的this指的 当前vue实例。</span><br><span class="line"> </span><br><span class="line"> 全局混入： 每个vue实例都混入该对象，包括组件的实例。</span><br><span class="line"> Vue.mixin(&#123;</span><br><span class="line">    created:function()&#123;</span><br><span class="line">        this.$options.xxx</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> new Vue(&#123;</span><br><span class="line">    el:xxx</span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> 局部混入:只在当前实例混入</span><br><span class="line"> var mixin = &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name:1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> new Vue(&#123;</span><br><span class="line">    mixins:[mixin]</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p>
<p>13.vue插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">插件通常会为 Vue 添加全局功能。插件的范围没有限制——一般有下面几种：</span><br><span class="line">添加全局方法或者属性，如: vue-custom-element</span><br><span class="line"></span><br><span class="line">添加全局资源：指令/过滤器/过渡等，如 vue-touch</span><br><span class="line"></span><br><span class="line">通过全局 mixin 方法添加一些组件选项，如: vue-router</span><br><span class="line"></span><br><span class="line">添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</span><br><span class="line"></span><br><span class="line">开发:</span><br><span class="line">let myplugin = &#123;&#125;</span><br><span class="line"> myplugin.install= （Vue,optiosn）=&gt;&#123;</span><br><span class="line">    //增加全局方法或者属性，Vue类调用的</span><br><span class="line">    Vue.globalMethod = ()=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">    // 2. 添加全局资源，全局指令 全局过滤器等</span><br><span class="line">      Vue.directive(&apos;my-directive&apos;, &#123;</span><br><span class="line">        bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">          // 逻辑...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">     // 3. 注入组件，混入对象等，比如vue-router vuex</span><br><span class="line">        Vue.mixin(&#123;</span><br><span class="line">          created: function () &#123;</span><br><span class="line">            // 逻辑...</span><br><span class="line">          &#125;,</span><br><span class="line">          conponents:&#123;&#125;</span><br><span class="line">          ...</span><br><span class="line">        &#125;)</span><br><span class="line">      //4.添加实例方法</span><br><span class="line">      Vue.prototype.$myMethod = function (methodOptions) &#123;</span><br><span class="line">          // 逻辑...</span><br><span class="line">        &#125;</span><br><span class="line">      //</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：Vue.use(myplugin);</span><br><span class="line">use方法会自动调用myPlugin.install并且传入Vue这个类</span><br></pre></td></tr></table></figure>
<p>14.Vue.extend 和 Vue.component区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Vue.component</span><br><span class="line">// 注册组件，传入一个扩展过的构造器</span><br><span class="line">Vue.component(&apos;my-component&apos;, Vue.extend(&#123; /* ... */ &#125;))</span><br><span class="line"></span><br><span class="line">// 注册组件，传入一个选项对象 (自动调用 Vue.extend)</span><br><span class="line">Vue.component(&apos;my-component&apos;, &#123; /* ... */ &#125;)</span><br><span class="line"></span><br><span class="line">// 获取注册的组件 (始终返回构造器)</span><br><span class="line">var MyComponent = Vue.component(&apos;my-component&apos;)</span><br><span class="line"></span><br><span class="line">注册组件，不管是Vue.component() 或者 局部components&#123;&#125;,都可 传入组件选项或者组件构造器；</span><br><span class="line"></span><br><span class="line">=============================================</span><br><span class="line">Vue.extend </span><br><span class="line">//使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</span><br><span class="line">// 是需要new的，或者通过 Vue.component注册组件，或者 注册局部组件 components:&#123;构造器&#125;</span><br><span class="line"></span><br><span class="line">var Profile = Vue.extend(&#123;</span><br><span class="line">  template: &apos;&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      firstName: &apos;Walter&apos;,</span><br><span class="line">      lastName: &apos;White&apos;,</span><br><span class="line">      alias: &apos;Heisenberg&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 创建 Profile 实例，并挂载到一个元素上。</span><br><span class="line">new Profile().$mount(&apos;#mount-point&apos;)</span><br><span class="line">new Profile(&#123;el:&apos;#mount-point&apos;&#125;)</span><br></pre></td></tr></table></figure>
<p>15.vue插件机制 封装组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">只用于渲染页面的组件</span><br><span class="line">使用：Vue.use(search)全局就会可以用 &lt;search-input&gt;&lt;/search-input&gt;</span><br><span class="line">import _search from &apos;./search.vue&apos;</span><br><span class="line">search.install = function(Vue,options)&#123;</span><br><span class="line">   let searchPlugin  = Vue.extend(_search)</span><br><span class="line">   //1.通过注册全局组件的方式</span><br><span class="line">   Vue.component(&apos;search-input&apos;,searchPlugin) </span><br><span class="line">   Vue.component(&apos;search-input&apos;,_search) </span><br><span class="line">   </span><br><span class="line">   //2.通过Vue.mixin 全局混入的方式</span><br><span class="line">   Vue.mixin(&#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            &apos;search-input&apos;:_search</span><br><span class="line">            </span><br><span class="line">        &#125; </span><br><span class="line">   &#125;)</span><br><span class="line">   Vue.mixin(&#123;</span><br><span class="line">           components:&#123;</span><br><span class="line">               &apos;search-input&apos;:searchPlugin </span><br><span class="line">           &#125; </span><br><span class="line">      &#125;)</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">可报漏api 可受控制的组件</span><br><span class="line">使用：Vue.use(toast)   调用this.$toast.show()</span><br><span class="line"></span><br><span class="line">import _toast from &apos;./toast.vue&apos;</span><br><span class="line">let $vm</span><br><span class="line">toast.install = function(Vue,options)&#123;</span><br><span class="line">    if(!$vm)&#123;</span><br><span class="line">        let searchPlugin  = Vue.extend(_toast)</span><br><span class="line">        let $vm = new searchPlugin(&#123; </span><br><span class="line">            el:document.createElement(&quot;div&quot;);</span><br><span class="line">        &#125;)</span><br><span class="line">        document.body.appendChild($vm.$el)</span><br><span class="line">    &#125;</span><br><span class="line">    1.toast内部method提供两个方法show 和hide；</span><br><span class="line">    </span><br><span class="line">    2.在此处扩展</span><br><span class="line">    $vm.show = function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    $vm.hide = function()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    $vm.changePropsData = function(title)&#123;</span><br><span class="line">        //title 为组件内部生声明的props</span><br><span class="line">        $vm.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">        created:funtion()&#123;</span><br><span class="line">            this.$vm = $vm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>16.vue 在计算属性的时候，computed和用method里的方法计算有什么区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">computed </span><br><span class="line">计算属性会依赖于他使用的data中的属性，只要是依赖的属性值有改变，则自动重新调用一下计算属性；</span><br><span class="line">如果他所依赖的这些属性值没有发生改变，那么计算属性的值是从缓存中来的，而不是重新编译，那么性能要高一些，</span><br><span class="line">所以vue中尽可能使用computed替代watch。</span><br><span class="line"></span><br><span class="line">method 是实时调用，实时计算；没有缓存</span><br><span class="line"></span><br><span class="line">watch 是监听属性，当属性变化就会执行响应的回调函数；</span><br></pre></td></tr></table></figure>
<p>17.vue中render，nextTick介绍一下？</p>
<p>18.component中data:function(){} 和data:{}区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">类比与引用数据类型。如果不用function return 每个组件的data都是内存的同一个地址，那一个数据改变其他也改变了，这当然就不是我们想要的。用function return 其实就相当于申明了新的变量，相互独立，自然就不会有这样的问题；js在赋值object对象时，是直接一个相同的内存地址。所以为了每个组件的data独立，采用了这种方式。</span><br><span class="line">如果不是组件的话，正常data的写法可以直接写一个对象，比如data：&#123; msg ： &apos; 下载 &apos; &#125;，但由于组件是会在多个地方引用</span><br><span class="line">的，JS中直接共享对象会造成引用传递，也就是说修改了msg后所有按钮的msg都会跟着修改，所以这里用function来每次返回一个</span><br><span class="line">对象实例。</span><br><span class="line"></span><br><span class="line">如果组件用 data:&#123;&#125;，那么多个调用组件的地方，将公用一个data，会互相影响。</span><br><span class="line">为什么会公用一个data？</span><br><span class="line">import 引入的模块，es module导入导出的都是内存地址，导出值导入互相影响</span><br></pre></td></tr></table></figure>
<p>19.vue生命周期钩子？<br>beforeCreate  实例创建之前<br>created 实例创建完成<br>beforeMount 挂载前<br>mounted 挂载后<br>beforeUpdate 更新前<br>updated  更新后<br>beforeDestory 销毁前<br>destoryed 销毁后</p>
<p> 20.vue-routers的实现</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">a.hash /#/  + onhashChange 事件</span><br><span class="line"></span><br><span class="line">改变hash，浏览器的请求不包括hash部分，不会刷新页面；通过hashchange事件监听路由变化</span><br><span class="line"></span><br><span class="line">b.history操作</span><br><span class="line">  </span><br><span class="line">  history.back() history.go() history.forward()，这些前进后退的操作会触发popstate事件；</span><br><span class="line">  window.addEventListener(&apos;popstate&apos;，fn）</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  pushState，replaceState 并不会触发popstate事件，这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。</span><br><span class="line">  只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求，也就不会刷新；</span><br><span class="line">  但是这两个方法不会触发popstate事件，需要我们手动去修改pushstate方法，增加消息通知；</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  //1.对方法进行加工,并且发布消息;</span><br><span class="line">  function apo(type)&#123;</span><br><span class="line">    var source = window.history[type];</span><br><span class="line">    return  function()&#123;</span><br><span class="line">        var event = new Event(type);</span><br><span class="line">        event.arguments = arguments;</span><br><span class="line">        window.disptchEvent(event);</span><br><span class="line">        return source.apply(this,arguments);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  window.history.pushState = aop(&apos;pushState&apos;);</span><br><span class="line">  window.history.replaceState = aop(&apos;replaceState&apos;);</span><br><span class="line"> </span><br><span class="line"> window.addEventListener(&apos;pushState&apos;,function()&#123;console.log(1)&#125;)</span><br><span class="line">  </span><br><span class="line"> window.addEventListener(&apos;replaceState&apos;,function()&#123;console.log(2)&#125;)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">2.发布订阅模式，创建event bus来实现；拦截pushState 和replaceState ,发布消息；</span><br></pre></td></tr></table></figure>
</code></pre><h1 id="前端工程化相关"><a href="#前端工程化相关" class="headerlink" title="前端工程化相关"></a>前端工程化相关</h1><p>1.webpack基本配置有哪些？(都问)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">entry </span><br><span class="line">output</span><br><span class="line">module(loader)</span><br><span class="line">plugin</span><br><span class="line">resolve(alias extentions)</span><br><span class="line"></span><br><span class="line">webpack.dllPlugin();</span><br><span class="line">webpack.dllReferencePlugin();</span><br><span class="line">webpack.commonChunkPlugin();</span><br></pre></td></tr></table></figure>
<p>2.vue-cli3脚手架的基本配置？</p>
<p><a href="https://cn.vuejs.org/v2/guide/components-registration.html#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C" target="_blank" rel="noopener">vue-cli3 支持全局注册基础化组件</a></p>
<p>3.webpack作用？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、合并js文件，压缩代码；处理图片资源等静态资源，减少http请求；</span><br><span class="line">2、css预处理，编译less/sass等浏览器不能直接识别的语言；</span><br><span class="line">3、对文件进行hash，可以防止浏览器缓存。</span><br><span class="line">4、一切皆模块，让模块更容易服用，避免重复加载或者加载不必要的模块，并且能够防止全局变量冲突。</span><br></pre></td></tr></table></figure>
<p>4.你对脚手架有研究过么?（小米）</p>
<p>5.项目打包部署你都是怎么弄的？（小米）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jekins部署，具体环境是运维来搭建的。</span><br></pre></td></tr></table></figure></p>
<h1 id="应用场景开发相关"><a href="#应用场景开发相关" class="headerlink" title="应用场景开发相关"></a>应用场景开发相关</h1><p>1.简述微信公众号授权过程？（每日优鲜）</p>
<p>2.客户端与前端的交互的原理 ，怎么交互？（瓜子二手车）</p>
<p>安卓:webview<br>1.js全局调用客户端方法：java向前端注入了全局对象ccjBridgeInstance，这个对象上面有一些客户端提供的方法 供前端调用；<br>                     url传参，native拦截；</p>
<pre><code>协议拦截，与客户端定义协议，通过动态向html插入 iframe，请求协议地址传带参数；native进行拦截
shareFriends://com.culiu.JiuKuaiJiu###分享标题###分享地址             
</code></pre><p>2.客户端调用js:window上声明响应的回调地址，window.方法名_callback，提供给客户端调用；</p>
<p>ios:UIwebview wkwebview<br>UIwebview:<br>1.js全局调用客户端方法：java向前端注入了全局对象ccjBridgeInstance，这个对象上面有一些客户端提供的方法 供前端调用；<br>                    url传参，native拦截</p>
<p>2.客户端调用js:window上声明响应的回调地址，window.方法名_callback，提供给客户端调用；</p>
<p>WKwebview:<br>js调用客户端：window.webkit.messageHandlers[方法名].possmessage(data)；去调用<br>            url传参，native拦截<br>客户端调用js:window上声明响应的回调地址，window.方法名_callback，提供给客户端调用；</p>
<p>回调方法遇到的问题：<br>连续调用相同的bridge，native只调用一次回调；<br>而且当时我们的回调地址都是直接赋给window的一个属性了，导致我们的回调一次次覆盖，只保留了最后一次；<br>解决方案：将回调收拢，每个bridge方法，对应一个回调函数池，提供给native的方法就是遍历这个回调函数池中的回调，依次执行；<br>        调用brigde时，就是向回调函数池中添加 函数；</p>
<p>#场景算法题</p>
<p>1.将aabbcccda 字符传替换成abcda？（将连续重复的字符去重）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">将连续重复的字符去重,这种会有重复项，aabbcccdc=&gt;字符传替换成abcdc</span><br><span class="line">reduce拼接，</span><br><span class="line">function switchStr(str) &#123;</span><br><span class="line">    let arr = str.split(&apos;&apos;);</span><br><span class="line">    return arr.reduce((prev,next,index,origin)=&gt;&#123;</span><br><span class="line">        if(prev.slice(prev.length-1) == next)&#123;</span><br><span class="line">            return prev;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return prev + next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,&apos;&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function switchStr(str)&#123;</span><br><span class="line">    return str.replace(/(.)(/1)+/,function(...args)&#123;</span><br><span class="line">        retrun args[1]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.js实现字符串trim方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原生：</span><br><span class="line">var a = &apos;  123  &apos;</span><br><span class="line">a.trim();</span><br><span class="line"></span><br><span class="line">js实现：</span><br><span class="line">String.prototype.trim = function()&#123;</span><br><span class="line">    return this.replace(/(^\s+|\s+$)/g,function()&#123;</span><br><span class="line">       return &quot;&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.原生js实现字符串split方法？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.函数节流？防抖？有何区别？</p>
<p><a href="https://juejin.im/post/5c87b54ce51d455f7943dddb" target="_blank" rel="noopener">防抖,节流</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数节流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          fn.call(<span class="keyword">this</span>,args);</span><br><span class="line">          flag = <span class="literal">true</span>;</span><br><span class="line">      &#125;,<span class="number">500</span>)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//防抖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        fn.call(<span class="keyword">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            fn.call(<span class="keyword">this</span>,args)</span><br><span class="line">        &#125;,<span class="number">300</span>) </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//区分： 节流在一定时间内调用多次，总是执行第一次调用的，执行完成后，才能再次调用。</span></span><br><span class="line">  <span class="comment">//      防抖在一定时间内调用多次，后续的调用会覆盖前面的调用，执行的永远是最后一次调用的。</span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.[a,b,c],写个方法将数组全排列 ，变成[abc,acb,bac,bca,cab,cba] （百度）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">思路:每次都取出一个，然后将除去这一个的其他数进行全排列。然后在将取出的那个数拼接到开头</span><br><span class="line">距离：取出a，然后b和c的全排列有两种：bc，cb； 这样就可以算出abc，acb；</span><br><span class="line">    取出b，然后a和c的全排列有两种：ac，ca； 这样就可以算出bac，bca；</span><br><span class="line">    取出c，然后a和b的全排列有两种：ab，ba； 这样就可以算出cab，cba；</span><br><span class="line">    </span><br><span class="line">    递归千万条，出口第一条：出口就是当数组为两项时，就可以自己写出 全排列。</span><br><span class="line"></span><br><span class="line">// [a,b,c]=&gt;[abc,acb,bac,bca,cab,cba]</span><br><span class="line">function permute(ary)&#123;</span><br><span class="line">    if(ary.length &lt;= 2)&#123;</span><br><span class="line">        if(ary.length == 2)&#123;</span><br><span class="line">            return [ary.join(&apos;&apos;),ary.reverse().join(&quot;&quot;)]</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return [ary[0]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let result = [];</span><br><span class="line">    ary.forEach((item,index)=&gt;&#123;</span><br><span class="line">        let all = permute(ary.slice(0,index).concat(ary.slice(index+1)));</span><br><span class="line">        all = all.map(val=&gt;&#123;</span><br><span class="line">            return item+val+&apos;&apos;;</span><br><span class="line">        &#125;)</span><br><span class="line">        result = result.concat(all);</span><br><span class="line">    &#125;)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(permute([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]));</span><br><span class="line"></span><br><span class="line">字符串全排列 abc =&gt;[abc,acb,bac,bca,cab,cba]</span><br><span class="line">const anagrams = str =&gt; &#123;</span><br><span class="line">    if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str];</span><br><span class="line">    return str.split(&apos;&apos;).reduce((acc, letter, i) =&gt;</span><br><span class="line">        acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val =&gt; letter + val)), []);</span><br><span class="line">&#125;;</span><br><span class="line">console.log(anagrams(&apos;1234&apos;));</span><br><span class="line">数组全排列 [a,b,c]=&gt;[[a,b,c],[a,c,b]...]</span><br><span class="line">    function permute(arr) &#123;</span><br><span class="line">        if(arr.length &lt;= 2)&#123;</span><br><span class="line">            if(arr.length == 2)&#123;</span><br><span class="line">                return [arr,[arr[1],arr[0]]];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return [arr];</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        return arr.reduce((prev,next,i)=&gt;&#123;</span><br><span class="line">            let pool= permute(arr.slice(0,i).concat(arr.slice(i+1)));</span><br><span class="line">            pool = pool.map(item=&gt;&#123;</span><br><span class="line">                item.unshift(next);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;);</span><br><span class="line">            return prev.concat(pool)</span><br><span class="line">        &#125;,[])</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(permute([ 1, 2, 3]));</span><br></pre></td></tr></table></figure></p>
<p>5.数组对象去重(vipkid)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//key 和 value都对比；</span><br><span class="line">//[&#123;a:11,b:12&#125;,&#123;c:21,d:22&#125;,&#123;a:12,b:11&#125;,&#123;c:21,d:22&#125;,&#123;a:1,e:&#123;name:&apos;1&apos;&#125;&#125;,&#123;a:1,e:&#123;name:&apos;1&apos;&#125;&#125;]</span><br><span class="line">function fn(ary)&#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    for(let i = 0 ;i &lt; ary.length;i++)&#123;</span><br><span class="line">        let key = JSON.stringify(ary[i]);</span><br><span class="line">        obj[key] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.keys(obj).map(item=&gt;&#123;</span><br><span class="line">        return JSON.parse(item)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//[&#123;a:11,b:12&#125;,&#123;c:21,d:22&#125;],[&#123;a:12,b:11&#125;,&#123;c:21,d:22&#125;]</span><br><span class="line">//找出两个数组对象中 key和value都相同的对象。找出&#123;c:21:d:22&#125;</span><br><span class="line"></span><br><span class="line">function fn(a1,a2)&#123;</span><br><span class="line">    let o1 = &#123;&#125;;</span><br><span class="line">    let result = []</span><br><span class="line">    for(let i = 0 ;i&lt;a1.length;i++)&#123;</span><br><span class="line">        let key = JSON.stringify(a1[i]);</span><br><span class="line">        o1[key] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i = 0 ;i&lt;a2.length;i++)&#123;</span><br><span class="line">        let key = JSON.stringify(a2[i])</span><br><span class="line">        if(o1[key])&#123;</span><br><span class="line">            result.push(a2[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.你所用到的排序方法</p>
<p>7.实现一个方法，能够把多重数组变成一个一维数组,flat方法。[1,[1,2],[3,4,5]]转换为[1,1,2,3,4,5] （vipkid）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(arr[i]) == <span class="string">'[object Array]'</span>)&#123;</span><br><span class="line">            result = result.concat(flat(arr[i]))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>8.12345数组混排 (水滴)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">利用随机数</span><br><span class="line"></span><br><span class="line">function switchAry(ary)&#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    let len = ary.length;</span><br><span class="line">    for(let i = 0 ;i&lt;len;i++)&#123;</span><br><span class="line">       let j =  Math.floor(Math.random()*ary.length); </span><br><span class="line">       let cur = ary.splice(j,1)[0];</span><br><span class="line">       result.push(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function sort(ary)&#123;</span><br><span class="line">    return ary.sort(function()&#123;</span><br><span class="line">        return Math.random() - 0.5 </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // Math.floor(Math.random()*5)  0-4，</span><br><span class="line"> // Math.ceil(Math.random()*5)   1-5</span><br><span class="line"> // Math.round(Math.random()*5)   0-5</span><br></pre></td></tr></table></figure>
<p>9.将字符串中重复出现的字符，去重；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.转成数组，去重，然后拼接；</span><br><span class="line"> function uqinue(str)&#123;</span><br><span class="line">     let ary = str.split(&quot;&quot;);</span><br><span class="line">     return Array.from(new Set(ary)).join(&quot;&quot;)    </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">2.遍历</span><br><span class="line"> function uqinue(str)&#123;</span><br><span class="line">     let result = &quot;&quot;;</span><br><span class="line">     for(let i = 0;i&lt;str.length;i++)&#123;</span><br><span class="line">         if(result.indexOf(str[i])==-1)&#123;</span><br><span class="line">         result = result + str[i]</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>10.abcaaaaaabcabcabcabbbabc 获取abc的重复次数 和索引</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 方案1，利用abc进行拆分成数组，数组长度-1为出现次数，；然后计算索引</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">str,t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ary = str.split(<span class="string">'abc'</span>);</span><br><span class="line">    <span class="keyword">let</span> n  = ary.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> iAry = [];</span><br><span class="line">    ary.reduce(<span class="function">(<span class="params">prev,next,i,</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i ==<span class="number">0</span>)&#123;</span><br><span class="line">            iAry.push(prev+next.length);</span><br><span class="line">            <span class="keyword">return</span> prev + next.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == ary.length<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iAry.push( prev+t.length+next.length);</span><br><span class="line">        <span class="keyword">return</span> prev+t.length+next.length;</span><br><span class="line"></span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;n,iAry&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'abcaaaaaabcabcabcabbbabcb'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">get</span>(a, 'abc'));</span><br><span class="line"></span><br><span class="line">//方案二：replace方法匹配，参数：[匹配到的整个串，分组，分组...，匹配到整个串的开始索引]</span><br><span class="line">function <span class="keyword">get</span>(str,t) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(t,<span class="string">'g'</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> iAry = [];</span><br><span class="line">    str.replace(reg,<span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        iAry.push(args[<span class="number">1</span>])</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;i,iAry&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'abcaaaaaabcabcabcabbbabcb'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">get</span>(a, 'abc'));</span><br></pre></td></tr></table></figure>
<p>11.Function instanceof Object （阿里，头条）<br>   Object instanceof Function<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> Function instanceof Object 返回true。</span><br><span class="line"> 原理：Function 是一个类同时也是一个函数，是Function类的一个实例;</span><br><span class="line"> Function instanceof Function 是true。</span><br><span class="line"> Function.__proto__ == Function.prototype；</span><br><span class="line"> 而Function.prototype.__proto__ 是Object.prototype；</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Object instanceof Function 返回true；</span><br><span class="line">原理：Object是一个类也是一个函数，所以是Function的一个实例。</span><br></pre></td></tr></table></figure></p>
<p>12.用二分查找递归方法，插入一个值并返回索引；有序数组[1,2,3,5,7,8],插入4，返回索引3；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   <span class="comment">//非递归,遍历找到第一个出现大于他的值，然后记住索引，向他前面插入进去。如果没找到，则直接push进去</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">ary,n</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> index;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ;i&lt;ary.length;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(ary[i]&gt;n)&#123;</span><br><span class="line">              index = i;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(i&gt;=ary.length)&#123;</span><br><span class="line">          ary.push(n)</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          ary.splice(index,<span class="number">0</span>,n)</span><br><span class="line">          <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(insert([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], <span class="number">3</span>));</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr,n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> l = [];</span><br><span class="line">            <span class="keyword">var</span> r = [];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i&lt;arr.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]&lt;n)&#123;</span><br><span class="line">                    l.push(arr[i])</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r.push(arr[i])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                index:l.length,</span><br><span class="line">                ary:l.concat([n]).concat(r)</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分插入，递归。</span></span><br><span class="line"><span class="comment">//思路：二分，用左侧最后一项进行比较，如果比插值大，说明应该插入到左侧数组中；</span></span><br><span class="line"><span class="comment">//    递归,继续二分记性比较。</span></span><br><span class="line"><span class="comment">//递归出口：当数组中只有一项时，就可以进行比较，就知道插入到哪了。</span></span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">ary,num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ary.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ary[<span class="number">0</span>]&gt;num)&#123;</span><br><span class="line">            ary.unshift(num);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ary.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="built_in">Math</span>.floor(ary.length/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> l = ary.slice(<span class="number">0</span>,m);</span><br><span class="line">    <span class="keyword">let</span> r = ary.slice(m);</span><br><span class="line">    <span class="keyword">if</span>(l[l.length<span class="number">-1</span>]&gt;num)&#123;</span><br><span class="line">        <span class="keyword">return</span> insert(l,num).concat(r)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l.concat(insert(r,num))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(insert([<span class="number">1</span>, <span class="number">2</span>, <span class="number">34</span>,<span class="number">48</span>,<span class="number">68</span>], <span class="number">34</span>));</span><br></pre></td></tr></table></figure></p>
<p>13.计算出数组的最大差值 <a href="程序设计">12,5,11,7,33,9</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjective</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...arr);</span><br><span class="line"> <span class="keyword">let</span> min = <span class="built_in">Math</span>.min(...arr);</span><br><span class="line"> <span class="keyword">return</span> max - min </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjective</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> min = arr[<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">let</span> max = arr[<span class="number">0</span>];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr[i]&lt;=min)&#123;</span><br><span class="line">         min = arr[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(arr[i]&gt;=max)&#123;</span><br><span class="line">         max = arr[i]</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">return</span> max - min ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">     arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b)</span><br><span class="line">     <span class="keyword">return</span> arr[arr.length<span class="number">-1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>14.请写出检查元素是否在屏幕可视区域的关键代码；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">图片懒加载的原理：</span><br><span class="line">方案一：1.获取图片 距离 滑动内容盒子 顶部的offsetTop</span><br><span class="line">      （需要给滑动内容盒子增加position:relative属性，使他成为父级参照物）</span><br><span class="line">        offsetParent:父级参照物</span><br><span class="line">        第一个具有position属性且非static的父级，没有的话，最终是body</span><br><span class="line">        一般情况下页面中所有元素的父级参照物都是body;</span><br><span class="line">        document.body.offsetParent =&gt;null//body 的父级参照物是null）</span><br><span class="line">       2.获取滚动窗口的scrollTop值。</span><br><span class="line">       3.获取滚动窗口的clientHeight值。</span><br><span class="line">       </span><br><span class="line">       监听滚动事件：当clientHeight+scrollTop &gt;=offsetTop时，则进入了窗口。</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">方案二:dom.getBoundingClientRect()是获取某个元素相对于视窗的位置集合;</span><br><span class="line">      &#123;top,left,right,bottom&#125;，四个值都是距离左边或者顶部的距离。</span><br><span class="line">      1.通过getBoundingclientRect().top,获取当前原理距离视窗顶部的距离</span><br><span class="line">      2.获取可视窗的高度document.body.clientHeight。</span><br><span class="line">      3.当元素距离视窗顶部距离 &lt; 视窗高度，则出现在视窗内</span><br></pre></td></tr></table></figure></p>
<p>15.将片段1 用正则表达式替换成片段2 （boss直聘）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">片段1 &lt;h1  class=&quot;h4&quot;&gt;&lt;span class=&quot;label&quot;&gt;boss直聘&lt;/span&gt;&lt;h1&gt;</span><br><span class="line"></span><br><span class="line">片段2 &lt;h1  class=\&quot;h4\&quot;&gt;&lt;span class=\&quot;label\&quot;&gt;boss直聘&lt;/span&gt;&lt;h1&gt;</span><br><span class="line">    function replaceStr(str) &#123;</span><br><span class="line">        let result = str.replace(/&quot;/g,function(...args) &#123;</span><br><span class="line">          return &quot;/&quot;+args[0]</span><br><span class="line">        &#125;)  </span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>16.计算”abcadadacvabc”中出现最多的字符？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//预设一个最大次数，利用对象存储次数 key是字符，value是次数；每次遍历都与最大次数进行比较；</span><br><span class="line">function fn(str)&#123;</span><br><span class="line">    let max;</span><br><span class="line">    let maxNum = 0 ;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    let ary = str.split(&apos;&apos;);</span><br><span class="line">    for(let i = 0 ; i&lt;ary.length;i++)&#123;</span><br><span class="line">        if(obj[ary[i]])&#123;</span><br><span class="line">            obj[ary[i]] =  obj[ary[i]] +1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            obj[ary[i]] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if( obj[ary[i]] &gt; maxNum)&#123;</span><br><span class="line">            maxNum = obj[ary[i]];</span><br><span class="line">            max = ary[i]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return `次数$&#123;maxNum&#125; 字符$&#123;max&#125;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>17.输入a=2 b=3 ,输出a=3,b=2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function fn(a,b)&#123;</span><br><span class="line">    var temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    return &#123;</span><br><span class="line">        a,</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn(a,b)&#123;</span><br><span class="line">    a = a+b;</span><br><span class="line">    b = a-b;</span><br><span class="line">    a = a-b;</span><br><span class="line">    console.log(a,b)</span><br><span class="line">&#125;</span><br><span class="line">function fn(a,b)&#123;</span><br><span class="line">    a = a -b;</span><br><span class="line">    b = a+b;</span><br><span class="line">    a = b-a;</span><br><span class="line">    return &#123;a,b&#125;</span><br><span class="line">&#125;</span><br><span class="line">function fn(a,b)&#123;</span><br><span class="line">  [b,a] = [a,b]</span><br><span class="line">  return &#123;a,b&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>18.找出整形数组中乘积最大的三位数 [-10,7,29,30,5,-10,-70]</p>
<p>思路：先排序由大到小排序，取前三位的乘机 和 末尾两位 * 首位的乘机进行比较。<br>   末尾两位可能是 负负得正，所以才要和前三位进行比较</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function get1(ary)&#123;</span><br><span class="line">    ary.sort((a,b)=&gt;b-a);</span><br><span class="line">    let sum = 1;</span><br><span class="line">    for(let i = 0;i&lt;3;i++)&#123;</span><br><span class="line">        sum = sum * ary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    let sum2 = 1;</span><br><span class="line">    if(ary.length&gt;3)&#123;</span><br><span class="line">        sum2 = ary[ary.length-2]*ary[ary.length-1]*ary[0]</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum&gt;sum2)&#123;</span><br><span class="line">        return ary.slice(0,3)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return ary.slice(0,1).concat(ary.slice(ary.length-2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>19.假设有n级台阶，每次最多允许跨m步（m&lt;=n）,那么有多少种跨越方式？<br><a href="https://segmentfault.com/a/1190000010486342" target="_blank" rel="noopener">该题解析</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">思路：采用自顶向下的思考方式</span><br><span class="line">f(n,m) = f(n-1,m)+f(n-2,m)+...+f(n-m,m)</span><br><span class="line">当m=2时，这就是一个斐波那契数列。</span><br><span class="line">同时，对于n阶变态跳，即n=m时，用公式有以下特点：</span><br><span class="line">f(n) = f(n-1)+f(n-2)+...+f(1);//①</span><br><span class="line">f(n-1) = f(n-2)+f(n-3)+...+f(1);//②</span><br><span class="line">①-② 即f(n) = 2f(n-1)，可以看出n阶变态跳的结果，实际是一个等比数列，也就是f(n) = 2^(n-1)</span><br><span class="line"></span><br><span class="line">function fn(n,m)&#123;</span><br><span class="line">    var count = 0;</span><br><span class="line">    if(n&lt;=0)&#123;</span><br><span class="line">        return 1; </span><br><span class="line">    &#125;</span><br><span class="line">    if(n&gt;=m)&#123;</span><br><span class="line">        for(let i =1 ;i&lt;=m;i++)&#123;</span><br><span class="line">            count += fn(n-i,m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        count +=fn(n,n)</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line"> &#125;</span><br><span class="line">//首先根据规律，存储前m项结果，当n&lt;m时，有f(n,m)=f(n,n)=f(n)=2^(n-1)</span><br><span class="line">//接下来我们依次计算n=m+1时的结果并存入数组</span><br><span class="line">//根据思路提示，第n项结果等于数组逆序前m项的和，我们截取数组迭代求和</span><br><span class="line">//最后返回顶层的数据，即是f(n,m)</span><br><span class="line">function f(n,m) &#123;</span><br><span class="line">    var arr = [1];</span><br><span class="line">    for (var i=1; i&lt;m;i++) &#123;</span><br><span class="line">        arr.push(Math.pow(2,i));</span><br><span class="line">    &#125;</span><br><span class="line">    for (var j=m+1; j&lt;=n; j++) &#123;</span><br><span class="line">        arr.push(arr.slice(-m).reduce((a,b) =&gt; a+b))</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//简单递归</span><br><span class="line">function fn(n)&#123;</span><br><span class="line">    if(n==1)return 1;</span><br><span class="line">    return fn(n-1) * 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20.写一个函数</p>
<p>输入：{ a:{<br>         b:{<br>            c:{<br>                d:’h’,<br>                j:’l’,<br>                o:{<br>                   p:’q’,<br>                   r:”s”<br>                }<br>                t:’u’<br>            }<br>         },<br>         v:{<br>            w:{<br>                x:{<br>                    y:’z’<br>                }<br>            }<br>         }<br>      }<br>      e:{<br>        f:{<br>           i:k<br>        },<br>        m:’n’<br>      }<br>}</p>
<p>输出结果，按照层数，把同一层的属性放在同一个子数组内；<br>[[a,e],[b,v,f,m],[c,w,i],[d,j,o,t,x],[p,r,y]]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">思路:每递归一遍，脱一层。</span><br><span class="line">function setAry(obj,result) &#123;</span><br><span class="line">    let keys = Object.keys(obj);</span><br><span class="line">    if(keys.length == 0 )&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(keys);</span><br><span class="line">    let next = &#123;&#125;;</span><br><span class="line">    for(let key in obj)&#123;</span><br><span class="line">        if(typeof obj[key] == &apos;object&apos;)&#123;</span><br><span class="line">            Object.assign(next,obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setAry(next,result) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>21.有两个链表，如何判断两个链表有交叉？</p>
<h1 id="DOM相关"><a href="#DOM相关" class="headerlink" title="DOM相关"></a>DOM相关</h1><p>1.如何判断一个dom是否在视窗中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">图片懒加载的原理：</span><br><span class="line">方案一：1.获取图片 距离 滑动内容盒子 顶部的offsetTop</span><br><span class="line">      （需要给滑动内容盒子增加position:relative属性，使他成为父级参照物）</span><br><span class="line">        offsetParent:父级参照物</span><br><span class="line">        第一个具有position属性且非static的父级，没有的话，最终是body</span><br><span class="line">        一般情况下页面中所有元素的父级参照物都是body;</span><br><span class="line">        document.body.offsetParent =&gt;null//body 的父级参照物是null）</span><br><span class="line">       2.获取滚动窗口的scrollTop值。</span><br><span class="line">       3.获取滚动窗口的clientHeight值。</span><br><span class="line">       </span><br><span class="line">       监听滚动事件：当clientHeight+scrollTop &gt;=offsetTop时，则进入了窗口。</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">方案二:dom.getBoundingClientRect()是获取某个元素相对于视窗的位置集合;</span><br><span class="line">      &#123;top,left,right,bottom&#125;，四个值都是距离左边或者顶部的距离。</span><br><span class="line">      1.通过getBoundingclientRect().top,获取当前原理距离视窗顶部的距离</span><br><span class="line">      2.获取可视窗的高度document.body.clientHeight。</span><br><span class="line">      3.当元素距离视窗顶部距离 &lt; 视窗高度，则出现在视窗内</span><br></pre></td></tr></table></figure>
<p>2.dom事件中 DOMContentLoaded和window.onload的触发实际是什么 ？图片加载完成后是一个什么情况？（苏宁）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//DOMContentLoaded 事件是DOM元素全部加载完成之后就会触发，图片等其他信息加载之前调用</span></span><br><span class="line"><span class="comment">// 在Dom节点创建完成后执行，如果有多个定义，则触发后会依次执行。</span></span><br><span class="line"><span class="comment">// jquery:</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;)</span><br><span class="line">$().ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something </span></span><br><span class="line">  <span class="comment">//jquery默认参数是document $()</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 以上三种方式都是jq提供的dom加载完成事件，都是基于DOMContentLoaded dom2级事件的。</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// 此方法为原生js DOM加载完成执行的事件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//windown.onload</span></span><br><span class="line"><span class="comment">// 加载完所有页面内容才会触发，包括所有内容,包括图片，flash等所有文件.如果页面的这些内容很多会让用户等待很 长时间.</span></span><br><span class="line"><span class="comment">//只能定义一个，如果有多个定义则只执行最后一个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line"><span class="comment">// 比如：页面中只有一个img标签，当img节点创建完后就会执行$(function()&#123;&#125;)中的代码，</span></span><br><span class="line"><span class="comment">// 当img的src指定的图片完全加载完后才会触发window.onload事件。</span></span><br></pre></td></tr></table></figure>
<p>3.原生js实现jq的after方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">思路：获取当前元素的氟元素节点 parentNode</span><br><span class="line">     获取当前元素的下一个元素节点nextElementsibling（或者nextSilbling &amp; nodeType==1，递归找出）</span><br><span class="line">     parentNode.inserBefore(被插入元素,nextElementsibling)</span><br></pre></td></tr></table></figure>
<h1 id="性能优化相关？"><a href="#性能优化相关？" class="headerlink" title="性能优化相关？"></a>性能优化相关？</h1><p>1.列举你能想到的前端性能问题和安全问题</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">安全问题：</span><br><span class="line">   a.xss攻击,就是攻击者想尽一切办法将可以执行的代码注入到网页中。</span><br><span class="line">    评论功能，写入脚本内容，入库了。 get参数后面拼接了key=脚本； 这种很被容易写进页面；</span><br><span class="line">   </span><br><span class="line">    防御：</span><br><span class="line">    转义字符：对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义</span><br><span class="line">            利用js-xss 将内容进行过滤，转义；</span><br><span class="line">    </span><br><span class="line">    csp:建立白名单，配置规则，高速浏览器哪些外部资源可以加载；</span><br><span class="line">    通常可以通过两种方式来开启 CSP：</span><br><span class="line">    设置 HTTP Header 中的 Content-Security-Policy</span><br><span class="line">    设置 meta 标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</span><br><span class="line">    </span><br><span class="line">       只允许加载本站资源</span><br><span class="line">       Content-Security-Policy: default-src ‘self’</span><br><span class="line">       只允许加载 HTTPS 协议图片</span><br><span class="line">       Content-Security-Policy: img-src https://*</span><br><span class="line">       允许加载任何来源框架</span><br><span class="line">       Content-Security-Policy: child-src &apos;none&apos;</span><br><span class="line">  b.  CSRF攻击？跨站点请求伪造如何防范</span><br><span class="line">      原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，</span><br><span class="line">      后端就以为是用户在操作，从而进行相应的逻辑。</span><br><span class="line">      </span><br><span class="line">      防御：请求时post附带验证信息，比如验证码或者 Token；</span><br><span class="line">           get请求不对数据进行修改</span><br><span class="line">           服务端验证referer</span><br><span class="line">           </span><br><span class="line">  c.点击劫持，攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击    </span><br><span class="line">      防御：当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">前端性能优化：（都问）</span><br><span class="line">  </span><br><span class="line">  前端代码的压缩 合并，减少http请求，和文件大小</span><br><span class="line">  图片处理设置最大边界，base64；雪碧图；</span><br><span class="line">  </span><br><span class="line">  少操作dom减少dom回流，或者创建文档碎片；</span><br><span class="line">  缓存dom节点，减少查找次数；</span><br><span class="line">  应用节流和防抖处理函数；比如说滚动发出请求；</span><br><span class="line">  </span><br><span class="line">  preload资源预加载属性；</span><br><span class="line">  图片懒加载；</span><br><span class="line">  静态资源放到cdn上；</span><br><span class="line">  离线存储:配置manifest配置应用程序缓存：CACHE MANIFEST，NETWORK，FALLBACK</span><br><span class="line">    优点//</span><br><span class="line">    离线浏览 - 用户可在应用离线时使用它们</span><br><span class="line">    速度 - 已缓存资源加载得更快</span><br><span class="line">    减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</span><br><span class="line">    // 更新缓存 </span><br><span class="line">    用户清空浏览器缓存</span><br><span class="line">    manifest 文件修改，可以配置一个版本号，</span><br><span class="line">    由程序来更新应用缓存</span><br><span class="line">    // 其他 //</span><br><span class="line">    站点离线存储的容量限制是5M</span><br><span class="line">  浏览器缓存机制；</span><br><span class="line">    楚楚推：图片max-age：24小时；</span><br><span class="line">            js css文件max-age：15分钟；</span><br><span class="line">            协商缓存；</span><br><span class="line">       </span><br><span class="line">  webpack性能优化：</span><br><span class="line">  有哪些方式可以减少 Webpack 的打包时间？</span><br><span class="line">    1.优化loader，通过exclude和include，优化loader的文件搜索范围；</span><br><span class="line">  module.exports = &#123;</span><br><span class="line">    module: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          // js 文件才使用 babel</span><br><span class="line">          test: /\.js$/,</span><br><span class="line">          loader: &apos;babel-loader&apos;,</span><br><span class="line">          // 只在 src 文件夹下查找</span><br><span class="line">          include: [resolve(&apos;src&apos;)],</span><br><span class="line">          // 不会去查找的路径</span><br><span class="line">          exclude: /node_modules/</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  2.使用HappyPack插件；</span><br><span class="line">  受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</span><br><span class="line">  HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        include: [resolve(&apos;src&apos;)],</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        // id 后面的内容对应下面</span><br><span class="line">        loader: &apos;happypack/loader?id=happybabel&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HappyPack(&#123;</span><br><span class="line">      id: &apos;happybabel&apos;,</span><br><span class="line">      loaders: [&apos;babel-loader?cacheDirectory&apos;],</span><br><span class="line">      // 开启 4 个线程</span><br><span class="line">      threads: 4</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  3.webpack.DllPlugin + webpack.DllReferencePlugin</span><br><span class="line">  DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本</span><br><span class="line">  才有需要重新打包，并且也实现了 将公共代码抽离成单独文件的优化方案。</span><br><span class="line">  4.resolve.extensions：用来表明文件后缀列表，默认查找顺序是 [&apos;.js&apos;, &apos;.json&apos;]，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</span><br><span class="line">  5.resolve.alias：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  有哪些方式可以让 Webpack 打出来的包更小？</span><br><span class="line">  1.按需加载，</span><br><span class="line">  原理：当使用时候再去下载对应文件，返回一个promise；</span><br><span class="line">  2.代码压缩；uglifyJS-webpack-plugin    webpack-parallel-uglify-plyugin 并行压缩js</span><br><span class="line">  3.Tree Shaking可以实现删除项目中未被引用的代码，</span><br><span class="line">   // test.js</span><br><span class="line">   export const a = 1</span><br><span class="line">   export const b = 2</span><br><span class="line">   // index.js</span><br><span class="line">   import &#123; a &#125; from &apos;./test.js&apos;</span><br><span class="line">  test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中</span><br><span class="line">  </span><br><span class="line">  4 Scope Hoisting Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: true</span><br><span class="line">  &#125;</span><br><span class="line">   Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><p>2.项目优化方法</p>
<p>3.错误检测上报日志怎么实现的?</p>
<p>  //a.通过onerror 捕获代码运行错误，捕获到错误信息后可以向目标服务器img发一个请求，get传递错误信息；<br>  window.onerror = function(msg, url, line, col, error){</p>
<p>  }<br>  //b.页面埋点，监听用户交互和pv/uv，请求服务器进行上报</p>
<p>  //c. performance.getEntriesByType(‘navigation’) 针对一些复杂页面，获取页面的性能相关信息，进行上报；</p>
<p>4.fis3 和 webpack的区别是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a.入口，</span><br><span class="line">webpack是从entry出发，将依赖的文件提取编译打包，通过commonschunkplugin、dll等提取公共代码；</span><br><span class="line">   fis3 是以file对象为中心构建编译的，所有文件同等对待，都会去分析文件依赖关系，生成一个静态资源表，</span><br><span class="line">   资源表记录每个文件的依赖关系；</span><br><span class="line">   fis3可以针对每个文件做出相应的配置，更加细致；</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">b.fis3的配置文件，fis.match到某些文件，然后对这些文件定义各自的各个阶段的插件处理、发布规则,是针对文件进行匹配的;</span><br><span class="line"> webpack配置文件，entry、output、plugins、module、resolve;</span><br><span class="line"></span><br><span class="line">c.fis3能对任何文件使用hash控制，在引用它的任何地方的路径会被自动替换为hash路径。</span><br><span class="line"> </span><br><span class="line">d.fis3，由于独有的静态资源标记，导致npm生态不太好；</span><br></pre></td></tr></table></figure></p>
<p>5.请列举最重要的前端优化点(按重要性)</p>
<p>6.：我们为什么一再强调将css放在头部，将js文件放在尾部</p>
<p><a href="https://www.cnblogs.com/caizhenbo/p/6679478.html" target="_blank" rel="noopener">浏览器解析</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在面试的过程中，经常会有人在回答页面的优化中提到将js放到body标签底部，原因是因为浏览器生成Dom树的时候是一行一行读HTML代</span><br><span class="line">码的，script标签放在最后面就不会影响前面的页面的渲染。那么问题来了，既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读</span><br><span class="line">完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样，因为dom树的生成需要整个文档解析完毕。</span><br><span class="line">  </span><br><span class="line">我们再来看一下chrome在页面渲染过程中的，绿色标志线是First Paint的时间。纳尼，为什么会出现firstpaint，页面的paint</span><br><span class="line">不是在渲染树生成之后吗？其实现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前</span><br><span class="line">开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。</span><br><span class="line">假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在</span><br><span class="line">后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。</span><br></pre></td></tr></table></figure></p>
<p>7.vue首屏加载很慢，怎么进行优化？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">a.组件异步加载;</span><br><span class="line">   局部注册异步组件(`import` 函数会返回一个 `Promise` 对象。)</span><br><span class="line">   new Vue(&#123;</span><br><span class="line">     // ...</span><br><span class="line">     components: &#123;</span><br><span class="line">       &apos;my-component&apos;: () =&gt; import(&apos;./my-async-component&apos;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   =&gt;</span><br><span class="line">   new Vue(&#123;</span><br><span class="line">        // ...</span><br><span class="line">        components: &#123;</span><br><span class="line">          &apos;my-component&apos;: Promise.resolve(&#123;...组件定义对象&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   全局注册异步组件</span><br><span class="line">   Vue.component(&quot;custom&quot;,() =&gt; import(&apos;./my-async-component&apos;))</span><br><span class="line">   =&gt;Vue.component(&quot;custom&quot;,Promise.resolve(&#123;...组件定义对象&#125;))</span><br><span class="line">   或者</span><br><span class="line">   </span><br><span class="line">    Vue.component(&apos;async-example&apos;, function (resolve, reject) &#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">        template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">Vue.component(&apos;async-webpack-example&apos;, function (resolve) &#123;</span><br><span class="line">  // 这个特殊的 `require` 语法将会告诉 webpack</span><br><span class="line">  // 自动将你的构建代码切割成多个包，这些包</span><br><span class="line">  // 会通过 Ajax 请求加载</span><br><span class="line">  require([&apos;./my-async-component&apos;], resolve)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  2.路由懒加载+分组打包；</span><br><span class="line">  没有指定webpackChunkName，每个组件打包成一个js文件；</span><br><span class="line">  指定了相同的webpackChunkName，会合并打包成一个js文件。</span><br><span class="line">  const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &apos;./Foo.vue&apos;)</span><br><span class="line">  const Bar = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &apos;./Bar.vue&apos;)</span><br><span class="line">  const Baz = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &apos;./Baz.vue&apos;)</span><br><span class="line">  const router = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">      &#123; path: &apos;/foo&apos;, </span><br><span class="line">        component: Foo，</span><br><span class="line">        children:[</span><br><span class="line">            &#123;path:&apos;/bar&apos;,component:Bar&#125;</span><br><span class="line">            &#123;path:&apos;/baz&apos;,component:Baz&#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  3.组织复杂页面的代码时，可以考虑对于打开首屏时不需要渲染的子组件，使用v-if控制其只在需要的时候被渲染。</span><br><span class="line">  </span><br><span class="line">  4.cdn加载外部的css js文件，浏览器并发请求加载。</span><br><span class="line">  </span><br><span class="line">  html直接引入外部的js 和css文件，比如vue vuex</span><br><span class="line">  </span><br><span class="line">  利用webpack的externals忽略打包文件；key是导入的键，value是项目中用到的变量</span><br><span class="line">   externals: &#123;</span><br><span class="line">      jquery: &apos;jQuery&apos; ,</span><br><span class="line">      vue:&apos;Vue&apos;</span><br><span class="line">      //将需要忽略打包的都写在这个里面，但前提是index.html文件里面必须script引入</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   使用：import $ from &apos;jquery&apos;，正常使用</span><br><span class="line">   5.开启gzip压缩支持</span><br><span class="line">   npm install compression-webpack-plugin —save-dev </span><br><span class="line">   将config/index.js 开启压缩</span><br><span class="line">       productionGzip: true,</span><br><span class="line">       productionGzipExtensions: [&apos;js&apos;, &apos;css&apos;],</span><br><span class="line">   </span><br><span class="line">   注：想要线上使用还需还得配置后端。</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   扩展常用webpak插件</span><br><span class="line">   copy-webpack-plugin ：复制文件到目标文件夹。在开发时使用热模替换，（没有生成dist 文件夹，都在内存中），如果想引用某一个js文件，直接写script标签是找不到的，因为服务器内存中没有这个文件。所以复制这个文件，到dist中。</span><br><span class="line">   compression-webpack-plugin： 生产环境时可选择让代码压缩gzip.</span><br><span class="line">   html-webpack-plugin : 生成index.html 并自动注入打包后的js css 等</span><br><span class="line">   webpack.DefinePlugin： 可以生成配置常量。编译时就有的常量。</span><br><span class="line">   extract-text-webpack-plugin： 提取使用文件的css 组成一个或多个css 文件。</span><br><span class="line">   webpack.optimize.CommonsChunkPlugin： 让多个出口文件组成一个文件</span><br><span class="line">   webpack-dev-server: 开发时使用，静态服务器，并且有热替换等功能。</span><br><span class="line">   uglifyjs-webpack-plugin： 删除警告，压缩代码等</span><br></pre></td></tr></table></figure></p>
<h1 id="扩展知识？能聊就行～"><a href="#扩展知识？能聊就行～" class="headerlink" title="扩展知识？能聊就行～"></a>扩展知识？能聊就行～</h1><p>1.简述CI/CD？</p>
<p>2.多态和重载？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重载：相同函数名，不同参数，则认为是两个不同的函数；</span><br><span class="line">js没有函数重载，可以通过参数个数，参数类型，内部模仿重载；</span><br><span class="line"></span><br><span class="line">多态的实际含义是，对象的多种形态；同一操作，作用在不同的对象上面，可以产生不同的解释和不同的执行结果。</span><br><span class="line">javascript的变量类型在运行期是可变的，这就意味着javascript对象的多态性是与生俱来的。</span><br></pre></td></tr></table></figure>
<p>3.了解服务端的反向代理吗？</p>
<p>4.订餐功能 如何实现的？<br>利用express框架搭建node服务，对前端提供api请求接口；<br>利用express-router + app.use 实现父子路由管理,实现用户订餐的增删改；<br>利用node-schedule 包实现定时任务，每天定时抓取用户订餐状态,生成订餐名单；每天定时清除，所有用户的 订餐状态；<br>利用nodemailer向行政发送 订餐人员名单;<br>let dinner = express.Router();<br>dinner.get(‘/list’,function(){</p>
<p>})</p>
<p>dinner.post(‘/set’,function(){</p>
<p>})</p>
<p>dinner.post(‘/delete’,function(){})</p>
<p>app.use(‘/dinner’,dinner)</p>
<p>表结构：<br>主键：是用户id ，用工号代替；姓名；部门；订饭状态；<br>用户进入前端页面，post提交工号，然后将该同学的订饭状态改成订餐状态；</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>1.观察者模式 和 订阅发布模式的区别</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5262488-291da39f66dbc28a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="image"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者模式和发布订阅模式最大的区别就是发布订阅模式有个事件调度中心。</span></span><br><span class="line"><span class="comment">// 观察者模式由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，会造成代码的冗余。而发布订阅模式则统一由调度中心处理，</span></span><br><span class="line"><span class="comment">// 消除了发布者和订阅者之间的依赖。</span></span><br></pre></td></tr></table></figure></p>
<h1 id="程序执行题"><a href="#程序执行题" class="headerlink" title="程序执行题"></a>程序执行题</h1><p>1.代码执行结果（boss直聘）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    name:<span class="string">'boss'</span>,</span><br><span class="line">    age:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(data.age);<span class="comment">//3</span></span><br><span class="line">observe(data);</span><br><span class="line"><span class="built_in">console</span>.log(data.age);<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">data.age = <span class="number">5</span>; <span class="comment">//val = 6</span></span><br><span class="line"><span class="built_in">console</span>.log(data.age)<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        defineReactive(data,key,data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data,key,val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data,key,&#123;</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> val +<span class="number">1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">            val = newVal+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.代码执行结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span>  res = arr.filter(<span class="function"><span class="params">value</span>  =&gt;</span>value%<span class="number">2</span>).map(<span class="function"><span class="params">item</span>=&gt;</span>item*item).reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b);</span><br><span class="line"><span class="built_in">console</span>.log(res);<span class="comment">//35</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.pop());<span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure></p>
<p>3.程序输出结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出6个undefined</span></span><br></pre></td></tr></table></figure></p>
<p>#node</p>
<p>1.express的设计思想？<br>路由控制<br>中间件<br>静态文件服务<br>模板解析</p>
<p>let app = express();<br>app.get(‘’,(req,res,next)=&gt;{</p>
<p>},(req,res,next)=&gt;{}).post(‘’,(req,res.next)=&gt;{</p>
<p>})</p>
<p>app.use(‘’,(req,res,next)=&gt;{</p>
<p>})</p>
<p>let user =  express.Router();<br>user.use(‘/login’,(req,res,next)=&gt;{</p>
<p>})</p>
<p>user.get(‘’,(req,res)=&gt;{</p>
<p>})<br>app.use(‘/user’,user)</p>
<p>设计思想<br>1.路由：二维数组的二维数据形式<br>[[cb,cb,cb],[cb,cb,cb],[cb,cb,cb],[usecb,usecb,usecb]]<br>最外层是Router，[cb,cb,cb] 表示的route，cb指的是每个route中的回调；[usecb,usecb,usecb]表示中间件的回调；</p>
<p>2.路由服务<br>express.router()，创建路由，在利用app.use中间件，形成父子级别中间路由；<br>express.router返回的一个router函数，router函数复用了app的一些方法,<br>也同样具备handler/post/get/use等方法；这样就利用方法复用，实现了一层一层的套用；</p>
<p>3.静态资源服务，调用node原生利用 http服务起的服务；</p>
<p>2.express和koa的区别？（阿里）</p>
<p>express 自带路由控制，express-router ;koa 需要单独引入<br>express 基于回调函数，koa是基于generator思想的；koa是不会出现回调地狱的；</p>
<p>3.node 思想？</p>
<p>特点：<br>线程是单线程异步。通过callback实现异步。<br>非阻塞、异步I/o，能用异步 绝不同步<br>event-driven事件驱动-发布订阅模式</p>
<p>思想：基于事件驱动，异步io，通过callback实现异步<br>     commonjs模块化，一个js就是一个模块；</p>
<p>自由回答题：<br>在一个异世界里，老虎可以吃羊，也可以吃草，并且羊比草好吃。但是吃了羊就会变成羊。假设现在有100只老虎和1只羊，且所有老虎都非常理性，那么最终会剩下多少老虎和多少羊？（头条）</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/15/Ubuntu16-04-4安装与优化/" rel="next" title="Ubuntu16.04.4安装与优化">
                <i class="fa fa-chevron-left"></i> Ubuntu16.04.4安装与优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/03/提问的智慧/" rel="prev" title="提问的智慧">
                提问的智慧 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Gray</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#http相关"><span class="nav-number">1.</span> <span class="nav-text">http相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js基础相关"><span class="nav-number">2.</span> <span class="nav-text">js基础相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML-CSS相关"><span class="nav-number">3.</span> <span class="nav-text">HTML+CSS相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#前端框架相关"><span class="nav-number">4.</span> <span class="nav-text">前端框架相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#前端工程化相关"><span class="nav-number">5.</span> <span class="nav-text">前端工程化相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用场景开发相关"><span class="nav-number">6.</span> <span class="nav-text">应用场景开发相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DOM相关"><span class="nav-number">7.</span> <span class="nav-text">DOM相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#性能优化相关？"><span class="nav-number">8.</span> <span class="nav-text">性能优化相关？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#扩展知识？能聊就行～"><span class="nav-number">9.</span> <span class="nav-text">扩展知识？能聊就行～</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式"><span class="nav-number">10.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#程序执行题"><span class="nav-number">11.</span> <span class="nav-text">程序执行题</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gray</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>




  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
